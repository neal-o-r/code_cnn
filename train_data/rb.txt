class PeopleHaveMiddleNames < ActiveRecord::Migration::Current
  def self.up
    add_column "people", "middle_name", :string
  end

  def self.down
    remove_column "people", "middle_name"
  end
end
class CreateArticles < ActiveRecord::Migration::Current
  def self.up
  end

  def self.down
  end
end
# coding: ISO-8859-15

class CurrenciesHaveSymbols < ActiveRecord::Migration::Current
  def self.up
    # We use € for default currency symbol
    add_column "currencies", "symbol", :string, default: "€"
  end

  def self.down
    remove_column "currencies", "symbol"
  end
end
class GiveMeBigNumbers < ActiveRecord::Migration::Current
  def self.up
    create_table :big_numbers do |table|
      table.column :bank_balance, :decimal, precision: 10, scale: 2
      table.column :big_bank_balance, :decimal, precision: 15, scale: 2
      table.column :world_population, :decimal, precision: 10
      table.column :my_house_population, :decimal, precision: 2
      table.column :value_of_e, :decimal
    end
  end

  def self.down
    drop_table :big_numbers
  end
end
class PeopleHaveHobbies < ActiveRecord::Migration::Current
  def self.up
    add_column "people", "hobbies", :string
  end

  def self.down
    remove_column "people", "hobbies"
  end
end
class PeopleHaveLastNames < ActiveRecord::Migration::Current
  def self.up
    add_column "people", "last_name", :string
  end

  def self.down
    remove_column "people", "last_name"
  end
end
class ValidPeopleHaveLastNames < ActiveRecord::Migration::Current
  def self.up
    add_column "people", "last_name", :string
  end

  def self.down
    remove_column "people", "last_name"
  end
end
class WeNeedThings < ActiveRecord::Migration::Current
  def self.up
    create_table("things") do |t|
      t.column :content, :text
    end
  end

  def self.down
    drop_table "things"
  end
end
class CreateArticles < ActiveRecord::Migration::Current
  def self.up
  end

  def self.down
  end
end
class PeopleHaveHobbies < ActiveRecord::Migration::Current
  def self.up
    add_column "people", "hobbies", :text
  end

  def self.down
    remove_column "people", "hobbies"
  end
end
class CreateComments < ActiveRecord::Migration::Current
  def self.up
  end

  def self.down
  end
end
class PeopleHaveDescriptions < ActiveRecord::Migration::Current
  def self.up
    add_column "people", "description", :text
  end

  def self.down
    remove_column "people", "description"
  end
end
class ValidWithTimestampsPeopleHaveLastNames < ActiveRecord::Migration::Current
  def self.up
    add_column "people", "last_name", :string
  end

  def self.down
    remove_column "people", "last_name"
  end
end
class ValidWithTimestampsWeNeedReminders < ActiveRecord::Migration::Current
  def self.up
    create_table("reminders") do |t|
      t.column :content, :text
      t.column :remind_at, :datetime
    end
  end

  def self.down
    drop_table "reminders"
  end
end
class ValidWithTimestampsInnocentJointable < ActiveRecord::Migration::Current
  def self.up
    create_table("people_reminders", id: false) do |t|
      t.column :reminder_id, :integer
      t.column :person_id, :integer
    end
  end

  def self.down
    drop_table "people_reminders"
  end
end
class MigrationVersionCheck < ActiveRecord::Migration::Current
  def self.up
    raise "incorrect migration version" unless version == 20131219224947
  end

  def self.down
  end
end
class CreateComments < ActiveRecord::Migration::Current
  def self.up
  end

  def self.down
  end
end
class PeopleHaveDescriptions < ActiveRecord::Migration::Current
  def self.up
    add_column "people", "description", :text
  end

  def self.down
    remove_column "people", "description"
  end
end
class RenameThings < ActiveRecord::Migration::Current
  def self.up
    rename_table "things", "awesome_things"
  end

  def self.down
    rename_table "awesome_things", "things"
  end
end
class WeNeedReminders < ActiveRecord::Migration::Current
  def self.up
    create_table("reminders") do |t|
      t.column :content, :text
      t.column :remind_at, :datetime
    end
  end

  def self.down
    drop_table "reminders"
  end
end
class InnocentJointable < ActiveRecord::Migration::Current
  def self.up
    create_table("people_reminders", id: false) do |t|
      t.column :reminder_id, :integer
      t.column :person_id, :integer
    end
  end

  def self.down
    drop_table "people_reminders"
  end
end
class WeNeedReminders < ActiveRecord::Migration::Current
  def self.up
    create_table("reminders") do |t|
      t.column :content, :text
      t.column :remind_at, :datetime
    end
  end

  def self.down
    drop_table "reminders"
  end
end
class InnocentJointable < ActiveRecord::Migration::Current
  def self.up
    create_table("people_reminders", id: false) do |t|
      t.column :reminder_id, :integer
      t.column :person_id, :integer
    end
  end

  def self.down
    drop_table "people_reminders"
  end
end
class AddExpressions < ActiveRecord::Migration::Current
  def self.up
    create_table("expressions") do |t|
      t.column :expression, :string
    end
  end

  def self.down
    drop_table "expressions"
  end
end
module AbcHelper
  def bare_a() end
end
module ActiveModel
  module Validations
    # == \Active \Model Absence Validator
    class AbsenceValidator < EachValidator #:nodoc:
      def validate_each(record, attr_name, value)
        record.errors.add(attr_name, :present, options) if value.present?
      end
    end

    module HelperMethods
      # Validates that the specified attributes are blank (as defined by
      # Object#blank?). Happens by default on save.
      #
      #   class Person < ActiveRecord::Base
      #     validates_absence_of :first_name
      #   end
      #
      # The first_name attribute must be in the object and it must be blank.
      #
      # Configuration options:
      # * <tt>:message</tt> - A custom error message (default is: "must be blank").
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def validates_absence_of(*attr_names)
        validates_with AbsenceValidator, _merge_attributes(attr_names)
      end
    end
  end
end
require "cases/helper"
require "models/topic"
require "models/person"
require "models/custom_reader"

class AbsenceValidationTest < ActiveModel::TestCase
  teardown do
    Topic.clear_validators!
    Person.clear_validators!
    CustomReader.clear_validators!
  end

  def test_validates_absence_of
    Topic.validates_absence_of(:title, :content)
    t = Topic.new
    t.title = "foo"
    t.content = "bar"
    assert t.invalid?
    assert_equal ["must be blank"], t.errors[:title]
    assert_equal ["must be blank"], t.errors[:content]
    t.title = ""
    t.content  = "something"
    assert t.invalid?
    assert_equal ["must be blank"], t.errors[:content]
    assert_equal [], t.errors[:title]
    t.content = ""
    assert t.valid?
  end

  def test_validates_absence_of_with_array_arguments
    Topic.validates_absence_of %w(title content)
    t = Topic.new
    t.title = "foo"
    t.content = "bar"
    assert t.invalid?
    assert_equal ["must be blank"], t.errors[:title]
    assert_equal ["must be blank"], t.errors[:content]
  end

  def test_validates_absence_of_with_custom_error_using_quotes
    Person.validates_absence_of :karma, message: "This string contains 'single' and \"double\" quotes"
    p = Person.new
    p.karma = "good"
    assert p.invalid?
    assert_equal "This string contains 'single' and \"double\" quotes", p.errors[:karma].last
  end

  def test_validates_absence_of_for_ruby_class
    Person.validates_absence_of :karma
    p = Person.new
    p.karma = "good"
    assert p.invalid?
    assert_equal ["must be blank"], p.errors[:karma]
    p.karma = nil
    assert p.valid?
  end

  def test_validates_absence_of_for_ruby_class_with_custom_reader
    CustomReader.validates_absence_of :karma
    p = CustomReader.new
    p[:karma] = "excellent"
    assert p.invalid?
    assert_equal ["must be blank"], p.errors[:karma]
    p[:karma] = ""
    assert p.valid?
  end
end
require "active_record/type"
require "active_record/connection_adapters/determine_if_preparable_visitor"
require "active_record/connection_adapters/schema_cache"
require "active_record/connection_adapters/sql_type_metadata"
require "active_record/connection_adapters/abstract/schema_dumper"
require "active_record/connection_adapters/abstract/schema_creation"
require "arel/collectors/bind"
require "arel/collectors/sql_string"

module ActiveRecord
  module ConnectionAdapters # :nodoc:
    extend ActiveSupport::Autoload

    autoload :Column
    autoload :ConnectionSpecification

    autoload_at "active_record/connection_adapters/abstract/schema_definitions" do
      autoload :IndexDefinition
      autoload :ColumnDefinition
      autoload :ChangeColumnDefinition
      autoload :ForeignKeyDefinition
      autoload :TableDefinition
      autoload :Table
      autoload :AlterTable
      autoload :ReferenceDefinition
    end

    autoload_at "active_record/connection_adapters/abstract/connection_pool" do
      autoload :ConnectionHandler
    end

    autoload_under "abstract" do
      autoload :SchemaStatements
      autoload :DatabaseStatements
      autoload :DatabaseLimits
      autoload :Quoting
      autoload :ConnectionPool
      autoload :QueryCache
      autoload :Savepoints
    end

    autoload_at "active_record/connection_adapters/abstract/transaction" do
      autoload :TransactionManager
      autoload :NullTransaction
      autoload :RealTransaction
      autoload :SavepointTransaction
      autoload :TransactionState
    end

    # Active Record supports multiple database systems. AbstractAdapter and
    # related classes form the abstraction layer which makes this possible.
    # An AbstractAdapter represents a connection to a database, and provides an
    # abstract interface for database-specific functionality such as establishing
    # a connection, escaping values, building the right SQL fragments for +:offset+
    # and +:limit+ options, etc.
    #
    # All the concrete database adapters follow the interface laid down in this class.
    # {ActiveRecord::Base.connection}[rdoc-ref:ConnectionHandling#connection] returns an AbstractAdapter object, which
    # you can use.
    #
    # Most of the methods in the adapter are useful during migrations. Most
    # notably, the instance methods provided by SchemaStatements are very useful.
    class AbstractAdapter
      ADAPTER_NAME = "Abstract".freeze
      include Quoting, DatabaseStatements, SchemaStatements
      include DatabaseLimits
      include QueryCache
      include ActiveSupport::Callbacks
      include ColumnDumper
      include Savepoints

      SIMPLE_INT = /\A\d+\z/

      define_callbacks :checkout, :checkin

      attr_accessor :visitor, :pool
      attr_reader :schema_cache, :owner, :logger
      alias :in_use? :owner

      def self.type_cast_config_to_integer(config)
        if config =~ SIMPLE_INT
          config.to_i
        else
          config
        end
      end

      def self.type_cast_config_to_boolean(config)
        if config == "false"
          false
        else
          config
        end
      end

      attr_reader :prepared_statements

      def initialize(connection, logger = nil, config = {}) # :nodoc:
        super()

        @connection          = connection
        @owner               = nil
        @instrumenter        = ActiveSupport::Notifications.instrumenter
        @logger              = logger
        @config              = config
        @pool                = nil
        @schema_cache        = SchemaCache.new self
        @quoted_column_names, @quoted_table_names = {}, {}
        @visitor             = arel_visitor

        if self.class.type_cast_config_to_boolean(config.fetch(:prepared_statements) { true })
          @prepared_statements = true
          @visitor.extend(DetermineIfPreparableVisitor)
        else
          @prepared_statements = false
        end
      end

      class Version
        include Comparable

        def initialize(version_string)
          @version = version_string.split(".").map(&:to_i)
        end

        def <=>(version_string)
          @version <=> version_string.split(".").map(&:to_i)
        end
      end

      class BindCollector < Arel::Collectors::Bind
        def compile(bvs, conn)
          casted_binds = bvs.map(&:value_for_database)
          super(casted_binds.map { |value| conn.quote(value) })
        end
      end

      class SQLString < Arel::Collectors::SQLString
        def compile(bvs, conn)
          super(bvs)
        end
      end

      def collector
        if prepared_statements
          SQLString.new
        else
          BindCollector.new
        end
      end

      def arel_visitor # :nodoc:
        Arel::Visitors::ToSql.new(self)
      end

      def valid_type?(type)
        false
      end

      def schema_creation
        SchemaCreation.new self
      end

      # this method must only be called while holding connection pool's mutex
      def lease
        if in_use?
          msg = "Cannot lease connection, "
          if @owner == Thread.current
            msg << "it is already leased by the current thread."
          else
            msg << "it is already in use by a different thread: #{@owner}. " <<
                   "Current thread: #{Thread.current}."
          end
          raise ActiveRecordError, msg
        end

        @owner = Thread.current
      end

      def schema_cache=(cache)
        cache.connection = self
        @schema_cache = cache
      end

      # this method must only be called while holding connection pool's mutex
      def expire
        if in_use?
          if @owner != Thread.current
            raise ActiveRecordError, "Cannot expire connection, " <<
              "it is owned by a different thread: #{@owner}. " <<
              "Current thread: #{Thread.current}."
          end

          @owner = nil
        else
          raise ActiveRecordError, "Cannot expire connection, it is not currently leased."
        end
      end

      # this method must only be called while holding connection pool's mutex (and a desire for segfaults)
      def steal! # :nodoc:
        if in_use?
          if @owner != Thread.current
            pool.send :remove_connection_from_thread_cache, self, @owner

            @owner = Thread.current
          end
        else
          raise ActiveRecordError, "Cannot steal connection, it is not currently leased."
        end
      end

      def unprepared_statement
        old_prepared_statements, @prepared_statements = @prepared_statements, false
        yield
      ensure
        @prepared_statements = old_prepared_statements
      end

      # Returns the human-readable name of the adapter. Use mixed case - one
      # can always use downcase if needed.
      def adapter_name
        self.class::ADAPTER_NAME
      end

      # Does this adapter support migrations?
      def supports_migrations?
        false
      end

      # Can this adapter determine the primary key for tables not attached
      # to an Active Record class, such as join tables?
      def supports_primary_key?
        false
      end

      # Does this adapter support DDL rollbacks in transactions? That is, would
      # CREATE TABLE or ALTER TABLE get rolled back by a transaction?
      def supports_ddl_transactions?
        false
      end

      def supports_bulk_alter?
        false
      end

      # Does this adapter support savepoints?
      def supports_savepoints?
        false
      end

      # Does this adapter support application-enforced advisory locking?
      def supports_advisory_locks?
        false
      end

      # Should primary key values be selected from their corresponding
      # sequence before the insert statement? If true, next_sequence_value
      # is called before each insert to set the record's primary key.
      def prefetch_primary_key?(table_name = nil)
        false
      end

      # Does this adapter support index sort order?
      def supports_index_sort_order?
        false
      end

      # Does this adapter support partial indices?
      def supports_partial_index?
        false
      end

      # Does this adapter support expression indices?
      def supports_expression_index?
        false
      end

      # Does this adapter support explain?
      def supports_explain?
        false
      end

      # Does this adapter support setting the isolation level for a transaction?
      def supports_transaction_isolation?
        false
      end

      # Does this adapter support database extensions?
      def supports_extensions?
        false
      end

      # Does this adapter support creating indexes in the same statement as
      # creating the table?
      def supports_indexes_in_create?
        false
      end

      # Does this adapter support creating foreign key constraints?
      def supports_foreign_keys?
        false
      end

      # Does this adapter support views?
      def supports_views?
        false
      end

      # Does this adapter support datetime with precision?
      def supports_datetime_with_precision?
        false
      end

      # Does this adapter support json data type?
      def supports_json?
        false
      end

      # Does this adapter support metadata comments on database objects (tables, columns, indexes)?
      def supports_comments?
        false
      end

      # Can comments for tables, columns, and indexes be specified in create/alter table statements?
      def supports_comments_in_create?
        false
      end

      # Does this adapter support multi-value insert?
      def supports_multi_insert?
        true
      end

      # This is meant to be implemented by the adapters that support extensions
      def disable_extension(name)
      end

      # This is meant to be implemented by the adapters that support extensions
      def enable_extension(name)
      end

      # This is meant to be implemented by the adapters that support advisory
      # locks
      #
      # Return true if we got the lock, otherwise false
      def get_advisory_lock(lock_id) # :nodoc:
      end

      # This is meant to be implemented by the adapters that support advisory
      # locks.
      #
      # Return true if we released the lock, otherwise false
      def release_advisory_lock(lock_id) # :nodoc:
      end

      # A list of extensions, to be filled in by adapters that support them.
      def extensions
        []
      end

      # A list of index algorithms, to be filled by adapters that support them.
      def index_algorithms
        {}
      end

      # REFERENTIAL INTEGRITY ====================================

      # Override to turn off referential integrity while executing <tt>&block</tt>.
      def disable_referential_integrity
        yield
      end

      # CONNECTION MANAGEMENT ====================================

      # Checks whether the connection to the database is still active. This includes
      # checking whether the database is actually capable of responding, i.e. whether
      # the connection isn't stale.
      def active?
      end

      # Disconnects from the database if already connected, and establishes a
      # new connection with the database. Implementors should call super if they
      # override the default implementation.
      def reconnect!
        clear_cache!
        reset_transaction
      end

      # Disconnects from the database if already connected. Otherwise, this
      # method does nothing.
      def disconnect!
        clear_cache!
        reset_transaction
      end

      # Reset the state of this connection, directing the DBMS to clear
      # transactions and other connection-related server-side state. Usually a
      # database-dependent operation.
      #
      # The default implementation does nothing; the implementation should be
      # overridden by concrete adapters.
      def reset!
        # this should be overridden by concrete adapters
      end

      ###
      # Clear any caching the database adapter may be doing, for example
      # clearing the prepared statement cache. This is database specific.
      def clear_cache!
        # this should be overridden by concrete adapters
      end

      # Returns true if its required to reload the connection between requests for development mode.
      def requires_reloading?
        false
      end

      # Checks whether the connection to the database is still active (i.e. not stale).
      # This is done under the hood by calling #active?. If the connection
      # is no longer active, then this method will reconnect to the database.
      def verify!(*ignored)
        reconnect! unless active?
      end

      # Provides access to the underlying database driver for this adapter. For
      # example, this method returns a Mysql2::Client object in case of Mysql2Adapter,
      # and a PGconn object in case of PostgreSQLAdapter.
      #
      # This is useful for when you need to call a proprietary method such as
      # PostgreSQL's lo_* methods.
      def raw_connection
        @connection
      end

      def case_sensitive_comparison(table, attribute, column, value)
        table[attribute].eq(Arel::Nodes::BindParam.new)
      end

      def case_insensitive_comparison(table, attribute, column, value)
        if can_perform_case_insensitive_comparison_for?(column)
          table[attribute].lower.eq(table.lower(Arel::Nodes::BindParam.new))
        else
          table[attribute].eq(Arel::Nodes::BindParam.new)
        end
      end

      def can_perform_case_insensitive_comparison_for?(column)
        true
      end
      private :can_perform_case_insensitive_comparison_for?

      # Check the connection back in to the connection pool
      def close
        pool.checkin self
      end

      def type_map # :nodoc:
        @type_map ||= Type::TypeMap.new.tap do |mapping|
          initialize_type_map(mapping)
        end
      end

      def new_column(name, default, sql_type_metadata, null, table_name, default_function = nil, collation = nil) # :nodoc:
        Column.new(name, default, sql_type_metadata, null, table_name, default_function, collation)
      end

      def lookup_cast_type(sql_type) # :nodoc:
        type_map.lookup(sql_type)
      end

      def column_name_for_operation(operation, node) # :nodoc:
        visitor.accept(node, collector).value
      end

      def combine_bind_parameters(
        from_clause: [],
        join_clause: [],
        where_clause: [],
        having_clause: [],
        limit: nil,
        offset: nil
      ) # :nodoc:
        result = from_clause + join_clause + where_clause + having_clause
        if limit
          result << limit
        end
        if offset
          result << offset
        end
        result
      end

      protected

        def initialize_type_map(m) # :nodoc:
          register_class_with_limit m, %r(boolean)i,       Type::Boolean
          register_class_with_limit m, %r(char)i,          Type::String
          register_class_with_limit m, %r(binary)i,        Type::Binary
          register_class_with_limit m, %r(text)i,          Type::Text
          register_class_with_precision m, %r(date)i,      Type::Date
          register_class_with_precision m, %r(time)i,      Type::Time
          register_class_with_precision m, %r(datetime)i,  Type::DateTime
          register_class_with_limit m, %r(float)i,         Type::Float
          register_class_with_limit m, %r(int)i,           Type::Integer

          m.alias_type %r(blob)i,      "binary"
          m.alias_type %r(clob)i,      "text"
          m.alias_type %r(timestamp)i, "datetime"
          m.alias_type %r(numeric)i,   "decimal"
          m.alias_type %r(number)i,    "decimal"
          m.alias_type %r(double)i,    "float"

          m.register_type(%r(decimal)i) do |sql_type|
            scale = extract_scale(sql_type)
            precision = extract_precision(sql_type)

            if scale == 0
              # FIXME: Remove this class as well
              Type::DecimalWithoutScale.new(precision: precision)
            else
              Type::Decimal.new(precision: precision, scale: scale)
            end
          end
        end

        def reload_type_map # :nodoc:
          type_map.clear
          initialize_type_map(type_map)
        end

        def register_class_with_limit(mapping, key, klass) # :nodoc:
          mapping.register_type(key) do |*args|
            limit = extract_limit(args.last)
            klass.new(limit: limit)
          end
        end

        def register_class_with_precision(mapping, key, klass) # :nodoc:
          mapping.register_type(key) do |*args|
            precision = extract_precision(args.last)
            klass.new(precision: precision)
          end
        end

        def extract_scale(sql_type) # :nodoc:
          case sql_type
          when /\((\d+)\)/ then 0
          when /\((\d+)(,(\d+))\)/ then $3.to_i
          end
        end

        def extract_precision(sql_type) # :nodoc:
          $1.to_i if sql_type =~ /\((\d+)(,\d+)?\)/
        end

        def extract_limit(sql_type) # :nodoc:
          case sql_type
          when /^bigint/i
            8
          when /\((.*)\)/
            $1.to_i
          end
        end

        def translate_exception_class(e, sql)
          begin
            message = "#{e.class.name}: #{e.message}: #{sql}"
          rescue Encoding::CompatibilityError
            message = "#{e.class.name}: #{e.message.force_encoding sql.encoding}: #{sql}"
          end

          exception = translate_exception(e, message)
          exception.set_backtrace e.backtrace
          exception
        end

        def log(sql, name = "SQL", binds = [], type_casted_binds = [], statement_name = nil)
          @instrumenter.instrument(
            "sql.active_record",
            sql:               sql,
            name:              name,
            binds:             binds,
            type_casted_binds: type_casted_binds,
            statement_name:    statement_name,
            connection_id:     object_id) { yield }
        rescue => e
          raise translate_exception_class(e, sql)
        end

        def translate_exception(exception, message)
          # override in derived class
          ActiveRecord::StatementInvalid.new(message)
        end

        def without_prepared_statement?(binds)
          !prepared_statements || binds.empty?
        end

        def column_for(table_name, column_name) # :nodoc:
          column_name = column_name.to_s
          columns(table_name).detect { |c| c.name == column_name } ||
            raise(ActiveRecordError, "No such column: #{table_name}.#{column_name}")
        end
    end
  end
end
require "action_pack"
require "active_support/rails"
require "active_support/i18n"

module AbstractController
  extend ActiveSupport::Autoload

  autoload :Base
  autoload :Caching
  autoload :Callbacks
  autoload :Collector
  autoload :DoubleRenderError, "abstract_controller/rendering"
  autoload :Helpers
  autoload :Logger
  autoload :Rendering
  autoload :Translation
  autoload :AssetPaths
  autoload :UrlFor

  def self.eager_load!
    super
    AbstractController::Caching.eager_load!
  end
end
require "abstract_unit"
require "set"

module AbstractController
  module Testing
    # Test basic dispatching.
    # ====
    # * Call process
    # * Test that the response_body is set correctly
    class SimpleController < AbstractController::Base
    end

    class Me < SimpleController
      def index
        self.response_body = "Hello world"
        "Something else"
      end
    end

    class TestBasic < ActiveSupport::TestCase
      test "dispatching works" do
        controller = Me.new
        controller.process(:index)
        assert_equal "Hello world", controller.response_body
      end
    end

    # Test Render mixin
    # ====
    class RenderingController < AbstractController::Base
      include AbstractController::Rendering
      include ActionView::Rendering

      def _prefixes
        []
      end

      def render(options = {})
        if options.is_a?(String)
          options = {_template_name: options}
        end
        super
      end

      append_view_path File.expand_path(File.join(File.dirname(__FILE__), "views"))
    end

    class Me2 < RenderingController
      def index
        render "index.erb"
      end

      def index_to_string
        self.response_body = render_to_string "index"
      end

      def action_with_ivars
        @my_ivar = "Hello"
        render "action_with_ivars.erb"
      end

      def naked_render
        render
      end

      def rendering_to_body
        self.response_body = render_to_body template: "naked_render"
      end

      def rendering_to_string
        self.response_body = render_to_string template: "naked_render"
      end
    end

    class TestRenderingController < ActiveSupport::TestCase
      def setup
        @controller = Me2.new
      end

      test "rendering templates works" do
        @controller.process(:index)
        assert_equal "Hello from index.erb", @controller.response_body
      end

      test "render_to_string works with a String as an argument" do
        @controller.process(:index_to_string)
        assert_equal "Hello from index.erb", @controller.response_body
      end

      test "rendering passes ivars to the view" do
        @controller.process(:action_with_ivars)
        assert_equal "Hello from index_with_ivars.erb", @controller.response_body
      end

      test "rendering with no template name" do
        @controller.process(:naked_render)
        assert_equal "Hello from naked_render.erb", @controller.response_body
      end

      test "rendering to a rack body" do
        @controller.process(:rendering_to_body)
        assert_equal "Hello from naked_render.erb", @controller.response_body
      end

      test "rendering to a string" do
        @controller.process(:rendering_to_string)
        assert_equal "Hello from naked_render.erb", @controller.response_body
      end
    end

    # Test rendering with prefixes
    # ====
    # * self._prefix is used when defined
    class PrefixedViews < RenderingController
      private
        def self.prefix
          name.underscore
        end

        def _prefixes
          [self.class.prefix]
        end
    end

    class Me3 < PrefixedViews
      def index
        render
      end

      def formatted
        self.formats = [:html]
        render
      end
    end

    class TestPrefixedViews < ActiveSupport::TestCase
      def setup
        @controller = Me3.new
      end

      test "templates are located inside their 'prefix' folder" do
        @controller.process(:index)
        assert_equal "Hello from me3/index.erb", @controller.response_body
      end

      test "templates included their format" do
        @controller.process(:formatted)
        assert_equal "Hello from me3/formatted.html.erb", @controller.response_body
      end
    end

    class OverridingLocalPrefixes < AbstractController::Base
      include AbstractController::Rendering
      include ActionView::Rendering
      append_view_path File.expand_path(File.join(File.dirname(__FILE__), "views"))

      def index
        render
      end

      def self.local_prefixes
        # this would usually return "abstract_controller/testing/overriding_local_prefixes"
        super + ["abstract_controller/testing/me3"]
      end

      class Inheriting < self
      end
    end

    class OverridingLocalPrefixesTest < ActiveSupport::TestCase
      test "overriding .local_prefixes adds prefix" do
        @controller = OverridingLocalPrefixes.new
        @controller.process(:index)
        assert_equal "Hello from me3/index.erb", @controller.response_body
      end

      test ".local_prefixes is inherited" do
        @controller = OverridingLocalPrefixes::Inheriting.new
        @controller.process(:index)
        assert_equal "Hello from me3/index.erb", @controller.response_body
      end
    end

    # Test rendering with layouts
    # ====
    # self._layout is used when defined
    class WithLayouts < PrefixedViews
      include ActionView::Layouts

      private
        def self.layout(formats)
          find_template(name.underscore, {formats: formats}, _prefixes: ["layouts"])
        rescue ActionView::MissingTemplate
          begin
            find_template("application", {formats: formats}, _prefixes: ["layouts"])
          rescue ActionView::MissingTemplate
          end
        end

        def render_to_body(options = {})
          options[:_layout] = options[:layout] || _default_layout({})
          super
        end
    end

    class Me4 < WithLayouts
      def index
        render
      end
    end

    class TestLayouts < ActiveSupport::TestCase
      test "layouts are included" do
        controller = Me4.new
        controller.process(:index)
        assert_equal "Me4 Enter : Hello from me4/index.erb : Exit", controller.response_body
      end
    end

    # respond_to_action?(action_name)
    # ====
    # * A method can be used as an action only if this method
    #   returns true when passed the method name as an argument
    # * Defaults to true in AbstractController
    class DefaultRespondToActionController < AbstractController::Base
      def index() self.response_body = "success" end
    end

    class ActionMissingRespondToActionController < AbstractController::Base
      # No actions
    private
      def action_missing(action_name)
        self.response_body = "success"
      end
    end

    class RespondToActionController < AbstractController::Base;
      def index() self.response_body = "success" end

      def fail()  self.response_body = "fail"    end

    private

      def method_for_action(action_name)
        action_name.to_s != "fail" && action_name
      end
    end

    class TestRespondToAction < ActiveSupport::TestCase
      def assert_dispatch(klass, body = "success", action = :index)
        controller = klass.new
        controller.process(action)
        assert_equal body, controller.response_body
      end

      test "an arbitrary method is available as an action by default" do
        assert_dispatch DefaultRespondToActionController, "success", :index
      end

      test "raises ActionNotFound when method does not exist and action_missing is not defined" do
        assert_raise(ActionNotFound) { DefaultRespondToActionController.new.process(:fail) }
      end

      test "dispatches to action_missing when method does not exist and action_missing is defined" do
        assert_dispatch ActionMissingRespondToActionController, "success", :ohai
      end

      test "a method is available as an action if method_for_action returns true" do
        assert_dispatch RespondToActionController, "success", :index
      end

      test "raises ActionNotFound if method is defined but method_for_action returns false" do
        assert_raise(ActionNotFound) { RespondToActionController.new.process(:fail) }
      end
    end

    class Me6 < AbstractController::Base
      action_methods

      def index
      end
    end

    class TestActionMethodsReloading < ActiveSupport::TestCase
      test "action_methods should be reloaded after defining a new method" do
        assert_equal Set.new(["index"]), Me6.action_methods
      end
    end
  end
end
module ActiveRecord
  module Type
    module Internal # :nodoc:
      class AbstractJson < ActiveModel::Type::Value # :nodoc:
        include ActiveModel::Type::Helpers::Mutable

        def type
          :json
        end

        def deserialize(value)
          if value.is_a?(::String)
            ::ActiveSupport::JSON.decode(value) rescue nil
          else
            value
          end
        end

        def serialize(value)
          ::ActiveSupport::JSON.encode(value)
        end

        def accessor
          ActiveRecord::Store::StringKeyedHashAccessor
        end
      end
    end
  end
end
require "active_record/connection_adapters/abstract_adapter"
require "active_record/connection_adapters/statement_pool"
require "active_record/connection_adapters/mysql/column"
require "active_record/connection_adapters/mysql/explain_pretty_printer"
require "active_record/connection_adapters/mysql/quoting"
require "active_record/connection_adapters/mysql/schema_creation"
require "active_record/connection_adapters/mysql/schema_definitions"
require "active_record/connection_adapters/mysql/schema_dumper"
require "active_record/connection_adapters/mysql/type_metadata"

require "active_support/core_ext/string/strip"
require "active_support/core_ext/regexp"

module ActiveRecord
  module ConnectionAdapters
    class AbstractMysqlAdapter < AbstractAdapter
      include MySQL::Quoting
      include MySQL::ColumnDumper

      def update_table_definition(table_name, base) # :nodoc:
        MySQL::Table.new(table_name, base)
      end

      def schema_creation # :nodoc:
        MySQL::SchemaCreation.new(self)
      end

      def arel_visitor # :nodoc:
        Arel::Visitors::MySQL.new(self)
      end

      ##
      # :singleton-method:
      # By default, the Mysql2Adapter will consider all columns of type <tt>tinyint(1)</tt>
      # as boolean. If you wish to disable this emulation you can add the following line
      # to your application.rb file:
      #
      #   ActiveRecord::ConnectionAdapters::Mysql2Adapter.emulate_booleans = false
      class_attribute :emulate_booleans
      self.emulate_booleans = true

      NATIVE_DATABASE_TYPES = {
        primary_key: "int auto_increment PRIMARY KEY",
        string:      { name: "varchar", limit: 255 },
        text:        { name: "text", limit: 65535 },
        integer:     { name: "int", limit: 4 },
        float:       { name: "float" },
        decimal:     { name: "decimal" },
        datetime:    { name: "datetime" },
        time:        { name: "time" },
        date:        { name: "date" },
        binary:      { name: "blob", limit: 65535 },
        boolean:     { name: "tinyint", limit: 1 },
        json:        { name: "json" },
      }

      INDEX_TYPES  = [:fulltext, :spatial]
      INDEX_USINGS = [:btree, :hash]

      class StatementPool < ConnectionAdapters::StatementPool
        private def dealloc(stmt)
          stmt[:stmt].close
        end
      end

      def initialize(connection, logger, connection_options, config)
        super(connection, logger, config)

        @statements = StatementPool.new(self.class.type_cast_config_to_integer(config[:statement_limit]))

        if version < "5.0.0"
          raise "Your version of MySQL (#{full_version.match(/^\d+\.\d+\.\d+/)[0]}) is too old. Active Record supports MySQL >= 5.0."
        end
      end

      CHARSETS_OF_4BYTES_MAXLEN = ["utf8mb4", "utf16", "utf16le", "utf32"]

      def internal_string_options_for_primary_key # :nodoc:
        super.tap { |options|
          options[:collation] = collation.sub(/\A[^_]+/, "utf8") if CHARSETS_OF_4BYTES_MAXLEN.include?(charset)
        }
      end

      def version #:nodoc:
        @version ||= Version.new(full_version.match(/^\d+\.\d+\.\d+/)[0])
      end

      def mariadb? # :nodoc:
        /mariadb/i.match?(full_version)
      end

      # Returns true, since this connection adapter supports migrations.
      def supports_migrations?
        true
      end

      def supports_primary_key?
        true
      end

      def supports_bulk_alter? #:nodoc:
        true
      end

      # Returns true, since this connection adapter supports prepared statement
      # caching.
      def supports_statement_cache?
        true
      end

      # Technically MySQL allows to create indexes with the sort order syntax
      # but at the moment (5.5) it doesn't yet implement them
      def supports_index_sort_order?
        true
      end

      def supports_transaction_isolation?
        true
      end

      def supports_explain?
        true
      end

      def supports_indexes_in_create?
        true
      end

      def supports_foreign_keys?
        true
      end

      def supports_views?
        true
      end

      def supports_datetime_with_precision?
        if mariadb?
          version >= "5.3.0"
        else
          version >= "5.6.4"
        end
      end

      def supports_advisory_locks?
        true
      end

      def get_advisory_lock(lock_name, timeout = 0) # :nodoc:
        select_value("SELECT GET_LOCK(#{quote(lock_name)}, #{timeout})") == 1
      end

      def release_advisory_lock(lock_name) # :nodoc:
        select_value("SELECT RELEASE_LOCK(#{quote(lock_name)})") == 1
      end

      def native_database_types
        NATIVE_DATABASE_TYPES
      end

      def index_algorithms
        { default: "ALGORITHM = DEFAULT", copy: "ALGORITHM = COPY", inplace: "ALGORITHM = INPLACE" }
      end

      # HELPER METHODS ===========================================

      # The two drivers have slightly different ways of yielding hashes of results, so
      # this method must be implemented to provide a uniform interface.
      def each_hash(result) # :nodoc:
        raise NotImplementedError
      end

      def new_column(*args) #:nodoc:
        MySQL::Column.new(*args)
      end

      # Must return the MySQL error number from the exception, if the exception has an
      # error number.
      def error_number(exception) # :nodoc:
        raise NotImplementedError
      end

      # REFERENTIAL INTEGRITY ====================================

      def disable_referential_integrity #:nodoc:
        old = select_value("SELECT @@FOREIGN_KEY_CHECKS")

        begin
          update("SET FOREIGN_KEY_CHECKS = 0")
          yield
        ensure
          update("SET FOREIGN_KEY_CHECKS = #{old}")
        end
      end

      # CONNECTION MANAGEMENT ====================================

      # Clears the prepared statements cache.
      def clear_cache!
        reload_type_map
        @statements.clear
      end

      #--
      # DATABASE STATEMENTS ======================================
      #++

      def explain(arel, binds = [])
        sql     = "EXPLAIN #{to_sql(arel, binds)}"
        start   = Time.now
        result  = exec_query(sql, "EXPLAIN", binds)
        elapsed = Time.now - start

        MySQL::ExplainPrettyPrinter.new.pp(result, elapsed)
      end

      # Executes the SQL statement in the context of this connection.
      def execute(sql, name = nil)
        log(sql, name) { @connection.query(sql) }
      end

      # Mysql2Adapter doesn't have to free a result after using it, but we use this method
      # to write stuff in an abstract way without concerning ourselves about whether it
      # needs to be explicitly freed or not.
      def execute_and_free(sql, name = nil) # :nodoc:
        yield execute(sql, name)
      end

      def begin_db_transaction
        execute "BEGIN"
      end

      def begin_isolated_db_transaction(isolation)
        execute "SET TRANSACTION ISOLATION LEVEL #{transaction_isolation_levels.fetch(isolation)}"
        begin_db_transaction
      end

      def commit_db_transaction #:nodoc:
        execute "COMMIT"
      end

      def exec_rollback_db_transaction #:nodoc:
        execute "ROLLBACK"
      end

      # In the simple case, MySQL allows us to place JOINs directly into the UPDATE
      # query. However, this does not allow for LIMIT, OFFSET and ORDER. To support
      # these, we must use a subquery.
      def join_to_update(update, select, key) # :nodoc:
        if select.limit || select.offset || select.orders.any?
          super
        else
          update.table select.source
          update.wheres = select.constraints
        end
      end

      def empty_insert_statement_value
        "VALUES ()"
      end

      # SCHEMA STATEMENTS ========================================

      # Drops the database specified on the +name+ attribute
      # and creates it again using the provided +options+.
      def recreate_database(name, options = {})
        drop_database(name)
        sql = create_database(name, options)
        reconnect!
        sql
      end

      # Create a new MySQL database with optional <tt>:charset</tt> and <tt>:collation</tt>.
      # Charset defaults to utf8.
      #
      # Example:
      #   create_database 'charset_test', charset: 'latin1', collation: 'latin1_bin'
      #   create_database 'matt_development'
      #   create_database 'matt_development', charset: :big5
      def create_database(name, options = {})
        if options[:collation]
          execute "CREATE DATABASE #{quote_table_name(name)} DEFAULT CHARACTER SET #{quote_table_name(options[:charset] || 'utf8')} COLLATE #{quote_table_name(options[:collation])}"
        else
          execute "CREATE DATABASE #{quote_table_name(name)} DEFAULT CHARACTER SET #{quote_table_name(options[:charset] || 'utf8')}"
        end
      end

      # Drops a MySQL database.
      #
      # Example:
      #   drop_database('sebastian_development')
      def drop_database(name) #:nodoc:
        execute "DROP DATABASE IF EXISTS #{quote_table_name(name)}"
      end

      def current_database
        select_value "SELECT DATABASE() as db"
      end

      # Returns the database character set.
      def charset
        show_variable "character_set_database"
      end

      # Returns the database collation strategy.
      def collation
        show_variable "collation_database"
      end

      def tables(name = nil) # :nodoc:
        ActiveSupport::Deprecation.warn(<<-MSG.squish)
          #tables currently returns both tables and views.
          This behavior is deprecated and will be changed with Rails 5.1 to only return tables.
          Use #data_sources instead.
        MSG

        if name
          ActiveSupport::Deprecation.warn(<<-MSG.squish)
            Passing arguments to #tables is deprecated without replacement.
          MSG
        end

        data_sources
      end

      def data_sources
        sql = "SELECT table_name FROM information_schema.tables "
        sql << "WHERE table_schema = #{quote(@config[:database])}"

        select_values(sql, "SCHEMA")
      end

      def truncate(table_name, name = nil)
        execute "TRUNCATE TABLE #{quote_table_name(table_name)}", name
      end

      def table_exists?(table_name)
        # Update lib/active_record/internal_metadata.rb when this gets removed
        ActiveSupport::Deprecation.warn(<<-MSG.squish)
          #table_exists? currently checks both tables and views.
          This behavior is deprecated and will be changed with Rails 5.1 to only check tables.
          Use #data_source_exists? instead.
        MSG

        data_source_exists?(table_name)
      end

      def data_source_exists?(table_name)
        return false unless table_name.present?

        schema, name = extract_schema_qualified_name(table_name)

        sql = "SELECT table_name FROM information_schema.tables "
        sql << "WHERE table_schema = #{quote(schema)} AND table_name = #{quote(name)}"

        select_values(sql, "SCHEMA").any?
      end

      def views # :nodoc:
        select_values("SHOW FULL TABLES WHERE table_type = 'VIEW'", "SCHEMA")
      end

      def view_exists?(view_name) # :nodoc:
        return false unless view_name.present?

        schema, name = extract_schema_qualified_name(view_name)

        sql = "SELECT table_name FROM information_schema.tables WHERE table_type = 'VIEW'"
        sql << " AND table_schema = #{quote(schema)} AND table_name = #{quote(name)}"

        select_values(sql, "SCHEMA").any?
      end

      # Returns an array of indexes for the given table.
      def indexes(table_name, name = nil) #:nodoc:
        indexes = []
        current_index = nil
        execute_and_free("SHOW KEYS FROM #{quote_table_name(table_name)}", "SCHEMA") do |result|
          each_hash(result) do |row|
            if current_index != row[:Key_name]
              next if row[:Key_name] == "PRIMARY" # skip the primary key
              current_index = row[:Key_name]

              mysql_index_type = row[:Index_type].downcase.to_sym
              index_type  = INDEX_TYPES.include?(mysql_index_type)  ? mysql_index_type : nil
              index_using = INDEX_USINGS.include?(mysql_index_type) ? mysql_index_type : nil
              indexes << IndexDefinition.new(row[:Table], row[:Key_name], row[:Non_unique].to_i == 0, [], [], nil, nil, index_type, index_using, row[:Index_comment].presence)
            end

            indexes.last.columns << row[:Column_name]
            indexes.last.lengths << row[:Sub_part]
          end
        end

        indexes
      end

      # Returns an array of +Column+ objects for the table specified by +table_name+.
      def columns(table_name) # :nodoc:
        table_name = table_name.to_s
        column_definitions(table_name).map do |field|
          type_metadata = fetch_type_metadata(field[:Type], field[:Extra])
          if type_metadata.type == :datetime && field[:Default] == "CURRENT_TIMESTAMP"
            default, default_function = nil, field[:Default]
          else
            default, default_function = field[:Default], nil
          end
          new_column(field[:Field], default, type_metadata, field[:Null] == "YES", table_name, default_function, field[:Collation], comment: field[:Comment].presence)
        end
      end

      def table_comment(table_name) # :nodoc:
        schema, name = extract_schema_qualified_name(table_name)

        select_value(<<-SQL.strip_heredoc, "SCHEMA")
          SELECT table_comment
          FROM information_schema.tables
          WHERE table_schema = #{quote(schema)}
            AND table_name = #{quote(name)}
        SQL
      end

      def create_table(table_name, **options) #:nodoc:
        super(table_name, options: "ENGINE=InnoDB", **options)
      end

      def bulk_change_table(table_name, operations) #:nodoc:
        sqls = operations.flat_map do |command, args|
          table, arguments = args.shift, args
          method = :"#{command}_sql"

          if respond_to?(method, true)
            send(method, table, *arguments)
          else
            raise "Unknown method called : #{method}(#{arguments.inspect})"
          end
        end.join(", ")

        execute("ALTER TABLE #{quote_table_name(table_name)} #{sqls}")
      end

      # Renames a table.
      #
      # Example:
      #   rename_table('octopuses', 'octopi')
      def rename_table(table_name, new_name)
        execute "RENAME TABLE #{quote_table_name(table_name)} TO #{quote_table_name(new_name)}"
        rename_table_indexes(table_name, new_name)
      end

      # Drops a table from the database.
      #
      # [<tt>:force</tt>]
      #   Set to +:cascade+ to drop dependent objects as well.
      #   Defaults to false.
      # [<tt>:if_exists</tt>]
      #   Set to +true+ to only drop the table if it exists.
      #   Defaults to false.
      # [<tt>:temporary</tt>]
      #   Set to +true+ to drop temporary table.
      #   Defaults to false.
      #
      # Although this command ignores most +options+ and the block if one is given,
      # it can be helpful to provide these in a migration's +change+ method so it can be reverted.
      # In that case, +options+ and the block will be used by create_table.
      def drop_table(table_name, options = {})
        execute "DROP#{' TEMPORARY' if options[:temporary]} TABLE#{' IF EXISTS' if options[:if_exists]} #{quote_table_name(table_name)}#{' CASCADE' if options[:force] == :cascade}"
      end

      def rename_index(table_name, old_name, new_name)
        if supports_rename_index?
          validate_index_length!(table_name, new_name)

          execute "ALTER TABLE #{quote_table_name(table_name)} RENAME INDEX #{quote_table_name(old_name)} TO #{quote_table_name(new_name)}"
        else
          super
        end
      end

      def change_column_default(table_name, column_name, default_or_changes) #:nodoc:
        default = extract_new_default_value(default_or_changes)
        column = column_for(table_name, column_name)
        change_column table_name, column_name, column.sql_type, default: default
      end

      def change_column_null(table_name, column_name, null, default = nil) #:nodoc:
        column = column_for(table_name, column_name)

        unless null || default.nil?
          execute("UPDATE #{quote_table_name(table_name)} SET #{quote_column_name(column_name)}=#{quote(default)} WHERE #{quote_column_name(column_name)} IS NULL")
        end

        change_column table_name, column_name, column.sql_type, null: null
      end

      def change_column(table_name, column_name, type, options = {}) #:nodoc:
        execute("ALTER TABLE #{quote_table_name(table_name)} #{change_column_sql(table_name, column_name, type, options)}")
      end

      def rename_column(table_name, column_name, new_column_name) #:nodoc:
        execute("ALTER TABLE #{quote_table_name(table_name)} #{rename_column_sql(table_name, column_name, new_column_name)}")
        rename_column_indexes(table_name, column_name, new_column_name)
      end

      def add_index(table_name, column_name, options = {}) #:nodoc:
        index_name, index_type, index_columns, _, index_algorithm, index_using, comment = add_index_options(table_name, column_name, options)
        sql = "CREATE #{index_type} INDEX #{quote_column_name(index_name)} #{index_using} ON #{quote_table_name(table_name)} (#{index_columns}) #{index_algorithm}"
        execute add_sql_comment!(sql, comment)
      end

      def add_sql_comment!(sql, comment) # :nodoc:
        sql << " COMMENT #{quote(comment)}" if comment
        sql
      end

      def foreign_keys(table_name)
        raise ArgumentError unless table_name.present?

        schema, name = extract_schema_qualified_name(table_name)

        fk_info = select_all(<<-SQL.strip_heredoc, "SCHEMA")
          SELECT fk.referenced_table_name AS 'to_table',
                 fk.referenced_column_name AS 'primary_key',
                 fk.column_name AS 'column',
                 fk.constraint_name AS 'name',
                 rc.update_rule AS 'on_update',
                 rc.delete_rule AS 'on_delete'
          FROM information_schema.key_column_usage fk
          JOIN information_schema.referential_constraints rc
          USING (constraint_schema, constraint_name)
          WHERE fk.referenced_column_name IS NOT NULL
            AND fk.table_schema = #{quote(schema)}
            AND fk.table_name = #{quote(name)}
        SQL

        fk_info.map do |row|
          options = {
            column: row["column"],
            name: row["name"],
            primary_key: row["primary_key"]
          }

          options[:on_update] = extract_foreign_key_action(row["on_update"])
          options[:on_delete] = extract_foreign_key_action(row["on_delete"])

          ForeignKeyDefinition.new(table_name, row["to_table"], options)
        end
      end

      def table_options(table_name) # :nodoc:
        table_options = {}

        create_table_info = create_table_info(table_name)

        # strip create_definitions and partition_options
        raw_table_options = create_table_info.sub(/\A.*\n\) /m, "").sub(/\n\/\*!.*\*\/\n\z/m, "").strip

        # strip AUTO_INCREMENT
        raw_table_options.sub!(/(ENGINE=\w+)(?: AUTO_INCREMENT=\d+)/, '\1')

        table_options[:options] = raw_table_options

        # strip COMMENT
        if raw_table_options.sub!(/ COMMENT='.+'/, "")
          table_options[:comment] = table_comment(table_name)
        end

        table_options
      end

      # Maps logical Rails types to MySQL-specific data types.
      def type_to_sql(type, limit = nil, precision = nil, scale = nil, unsigned = nil)
        sql = case type.to_s
              when "integer"
                integer_to_sql(limit)
              when "text"
                text_to_sql(limit)
              when "blob"
                binary_to_sql(limit)
              when "binary"
                if (0..0xfff) === limit
                  "varbinary(#{limit})"
                else
                  binary_to_sql(limit)
                end
        else
                super(type, limit, precision, scale)
        end

        sql << " unsigned" if unsigned && type != :primary_key
        sql
      end

      # SHOW VARIABLES LIKE 'name'
      def show_variable(name)
        select_value("SELECT @@#{name}", "SCHEMA")
      rescue ActiveRecord::StatementInvalid
        nil
      end

      def primary_keys(table_name) # :nodoc:
        raise ArgumentError unless table_name.present?

        schema, name = extract_schema_qualified_name(table_name)

        select_values(<<-SQL.strip_heredoc, "SCHEMA")
          SELECT column_name
          FROM information_schema.key_column_usage
          WHERE constraint_name = 'PRIMARY'
            AND table_schema = #{quote(schema)}
            AND table_name = #{quote(name)}
          ORDER BY ordinal_position
        SQL
      end

      def case_sensitive_comparison(table, attribute, column, value)
        if column.collation && !column.case_sensitive?
          table[attribute].eq(Arel::Nodes::Bin.new(Arel::Nodes::BindParam.new))
        else
          super
        end
      end

      def can_perform_case_insensitive_comparison_for?(column)
        column.case_sensitive?
      end
      private :can_perform_case_insensitive_comparison_for?

      # In MySQL 5.7.5 and up, ONLY_FULL_GROUP_BY affects handling of queries that use
      # DISTINCT and ORDER BY. It requires the ORDER BY columns in the select list for
      # distinct queries, and requires that the ORDER BY include the distinct column.
      # See https://dev.mysql.com/doc/refman/5.7/en/group-by-handling.html
      def columns_for_distinct(columns, orders) # :nodoc:
        order_columns = orders.reject(&:blank?).map { |s|
          # Convert Arel node to string
          s = s.to_sql unless s.is_a?(String)
          # Remove any ASC/DESC modifiers
          s.gsub(/\s+(?:ASC|DESC)\b/i, "")
        }.reject(&:blank?).map.with_index { |column, i| "#{column} AS alias_#{i}" }

        [super, *order_columns].join(", ")
      end

      def strict_mode?
        self.class.type_cast_config_to_boolean(@config.fetch(:strict, true))
      end

      def valid_type?(type)
        !native_database_types[type].nil?
      end

      protected

        def initialize_type_map(m) # :nodoc:
          super

          register_class_with_limit m, %r(char)i, MysqlString

          m.register_type %r(tinytext)i,   Type::Text.new(limit: 2**8 - 1)
          m.register_type %r(tinyblob)i,   Type::Binary.new(limit: 2**8 - 1)
          m.register_type %r(text)i,       Type::Text.new(limit: 2**16 - 1)
          m.register_type %r(blob)i,       Type::Binary.new(limit: 2**16 - 1)
          m.register_type %r(mediumtext)i, Type::Text.new(limit: 2**24 - 1)
          m.register_type %r(mediumblob)i, Type::Binary.new(limit: 2**24 - 1)
          m.register_type %r(longtext)i,   Type::Text.new(limit: 2**32 - 1)
          m.register_type %r(longblob)i,   Type::Binary.new(limit: 2**32 - 1)
          m.register_type %r(^float)i,     Type::Float.new(limit: 24)
          m.register_type %r(^double)i,    Type::Float.new(limit: 53)
          m.register_type %r(^json)i,      MysqlJson.new

          register_integer_type m, %r(^bigint)i,    limit: 8
          register_integer_type m, %r(^int)i,       limit: 4
          register_integer_type m, %r(^mediumint)i, limit: 3
          register_integer_type m, %r(^smallint)i,  limit: 2
          register_integer_type m, %r(^tinyint)i,   limit: 1

          m.register_type %r(^tinyint\(1\))i, Type::Boolean.new if emulate_booleans
          m.alias_type %r(year)i,          "integer"
          m.alias_type %r(bit)i,           "binary"

          m.register_type(%r(enum)i) do |sql_type|
            limit = sql_type[/^enum\((.+)\)/i, 1]
              .split(",").map{|enum| enum.strip.length - 2}.max
            MysqlString.new(limit: limit)
          end

          m.register_type(%r(^set)i) do |sql_type|
            limit = sql_type[/^set\((.+)\)/i, 1]
              .split(",").map{|set| set.strip.length - 1}.sum - 1
            MysqlString.new(limit: limit)
          end
        end

        def register_integer_type(mapping, key, options) # :nodoc:
          mapping.register_type(key) do |sql_type|
            if /\bunsigned\z/ === sql_type
              Type::UnsignedInteger.new(options)
            else
              Type::Integer.new(options)
            end
          end
        end

        def extract_precision(sql_type)
          if /time/ === sql_type
            super || 0
          else
            super
          end
        end

        def fetch_type_metadata(sql_type, extra = "")
          MySQL::TypeMetadata.new(super(sql_type), extra: extra, strict: strict_mode?)
        end

        def add_index_length(option_strings, column_names, options = {})
          if options.is_a?(Hash) && length = options[:length]
            case length
            when Hash
              column_names.each {|name| option_strings[name] += "(#{length[name]})" if length.has_key?(name) && length[name].present?}
            when Integer
              column_names.each {|name| option_strings[name] += "(#{length})"}
            end
          end

          return option_strings
        end

        def quoted_columns_for_index(column_names, options = {})
          option_strings = Hash[column_names.map {|name| [name, ""]}]

          # add index length
          option_strings = add_index_length(option_strings, column_names, options)

          # add index sort order
          option_strings = add_index_sort_order(option_strings, column_names, options)

          column_names.map {|name| quote_column_name(name) + option_strings[name]}
        end

      # See https://dev.mysql.com/doc/refman/5.7/en/error-messages-server.html
        ER_DUP_ENTRY            = 1062
        ER_NO_REFERENCED_ROW_2  = 1452
        ER_DATA_TOO_LONG        = 1406
        ER_LOCK_DEADLOCK        = 1213

        def translate_exception(exception, message)
          case error_number(exception)
          when ER_DUP_ENTRY
            RecordNotUnique.new(message)
          when ER_NO_REFERENCED_ROW_2
            InvalidForeignKey.new(message)
          when ER_DATA_TOO_LONG
            ValueTooLong.new(message)
          when ER_LOCK_DEADLOCK
            Deadlocked.new(message)
          else
            super
          end
        end

        def add_column_sql(table_name, column_name, type, options = {})
          td = create_table_definition(table_name)
          cd = td.new_column_definition(column_name, type, options)
          schema_creation.accept(AddColumnDefinition.new(cd))
        end

        def change_column_sql(table_name, column_name, type, options = {})
          column = column_for(table_name, column_name)

          unless options_include_default?(options)
            options[:default] = column.default
          end

          unless options.has_key?(:null)
            options[:null] = column.null
          end

          td = create_table_definition(table_name)
          cd = td.new_column_definition(column.name, type, options)
          schema_creation.accept(ChangeColumnDefinition.new(cd, column.name))
        end

        def rename_column_sql(table_name, column_name, new_column_name)
          column  = column_for(table_name, column_name)
          options = {
            default: column.default,
            null: column.null,
            auto_increment: column.auto_increment?
          }

          current_type = select_one("SHOW COLUMNS FROM #{quote_table_name(table_name)} LIKE '#{column_name}'", "SCHEMA")["Type"]
          td = create_table_definition(table_name)
          cd = td.new_column_definition(new_column_name, current_type, options)
          schema_creation.accept(ChangeColumnDefinition.new(cd, column.name))
        end

        def remove_column_sql(table_name, column_name, type = nil, options = {})
          "DROP #{quote_column_name(column_name)}"
        end

        def remove_columns_sql(table_name, *column_names)
          column_names.map {|column_name| remove_column_sql(table_name, column_name) }
        end

        def add_index_sql(table_name, column_name, options = {})
          index_name, index_type, index_columns, _, index_algorithm, index_using = add_index_options(table_name, column_name, options)
          index_algorithm[0, 0] = ", " if index_algorithm.present?
          "ADD #{index_type} INDEX #{quote_column_name(index_name)} #{index_using} (#{index_columns})#{index_algorithm}"
        end

        def remove_index_sql(table_name, options = {})
          index_name = index_name_for_remove(table_name, options)
          "DROP INDEX #{index_name}"
        end

        def add_timestamps_sql(table_name, options = {})
          [add_column_sql(table_name, :created_at, :datetime, options), add_column_sql(table_name, :updated_at, :datetime, options)]
        end

        def remove_timestamps_sql(table_name, options = {})
          [remove_column_sql(table_name, :updated_at), remove_column_sql(table_name, :created_at)]
        end

      private

      # MySQL is too stupid to create a temporary table for use subquery, so we have
      # to give it some prompting in the form of a subsubquery. Ugh!
        def subquery_for(key, select)
          subsubselect = select.clone
          subsubselect.projections = [key]

          # Materialize subquery by adding distinct
          # to work with MySQL 5.7.6 which sets optimizer_switch='derived_merge=on'
          subsubselect.distinct unless select.limit || select.offset || select.orders.any?

          subselect = Arel::SelectManager.new(select.engine)
          subselect.project Arel.sql(key.name)
          subselect.from subsubselect.as("__active_record_temp")
        end

        def supports_rename_index?
          mariadb? ? false : version >= "5.7.6"
        end

        def configure_connection
          variables = @config.fetch(:variables, {}).stringify_keys

          # By default, MySQL 'where id is null' selects the last inserted id; Turn this off.
          variables["sql_auto_is_null"] = 0

          # Increase timeout so the server doesn't disconnect us.
          wait_timeout = @config[:wait_timeout]
          wait_timeout = 2147483 unless wait_timeout.is_a?(Integer)
          variables["wait_timeout"] = self.class.type_cast_config_to_integer(wait_timeout)

          defaults = [":default", :default].to_set

          # Make MySQL reject illegal values rather than truncating or blanking them, see
          # http://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_strict_all_tables
          # If the user has provided another value for sql_mode, don't replace it.
          if sql_mode = variables.delete("sql_mode")
            sql_mode = quote(sql_mode)
          elsif !defaults.include?(strict_mode?)
            if strict_mode?
              sql_mode = "CONCAT(@@sql_mode, ',STRICT_ALL_TABLES')"
            else
              sql_mode = "REPLACE(@@sql_mode, 'STRICT_TRANS_TABLES', '')"
              sql_mode = "REPLACE(#{sql_mode}, 'STRICT_ALL_TABLES', '')"
              sql_mode = "REPLACE(#{sql_mode}, 'TRADITIONAL', '')"
            end
            sql_mode = "CONCAT(#{sql_mode}, ',NO_AUTO_VALUE_ON_ZERO')"
          end
          sql_mode_assignment = "@@SESSION.sql_mode = #{sql_mode}, " if sql_mode

          # NAMES does not have an equals sign, see
          # http://dev.mysql.com/doc/refman/5.7/en/set-statement.html#id944430
          # (trailing comma because variable_assignments will always have content)
          if @config[:encoding]
            encoding = "NAMES #{@config[:encoding]}"
            encoding << " COLLATE #{@config[:collation]}" if @config[:collation]
            encoding << ", "
          end

          # Gather up all of the SET variables...
          variable_assignments = variables.map do |k, v|
            if defaults.include?(v)
              "@@SESSION.#{k} = DEFAULT" # Sets the value to the global or compile default
            elsif !v.nil?
              "@@SESSION.#{k} = #{quote(v)}"
            end
            # or else nil; compact to clear nils out
          end.compact.join(", ")

          # ...and send them all in one query
          @connection.query  "SET #{encoding} #{sql_mode_assignment} #{variable_assignments}"
        end

        def column_definitions(table_name) # :nodoc:
          execute_and_free("SHOW FULL FIELDS FROM #{quote_table_name(table_name)}", "SCHEMA") do |result|
            each_hash(result)
          end
        end

        def extract_foreign_key_action(specifier) # :nodoc:
          case specifier
          when "CASCADE"; :cascade
          when "SET NULL"; :nullify
          end
        end

        def create_table_info(table_name) # :nodoc:
          select_one("SHOW CREATE TABLE #{quote_table_name(table_name)}")["Create Table"]
        end

        def create_table_definition(*args) # :nodoc:
          MySQL::TableDefinition.new(*args)
        end

        def extract_schema_qualified_name(string) # :nodoc:
          schema, name = string.to_s.scan(/[^`.\s]+|`[^`]*`/)
          schema, name = @config[:database], schema unless name
          [schema, name]
        end

        def integer_to_sql(limit) # :nodoc:
          case limit
          when 1; "tinyint"
          when 2; "smallint"
          when 3; "mediumint"
          when nil, 4; "int"
          when 5..8; "bigint"
          else raise(ActiveRecordError, "No integer type has byte size #{limit}")
          end
        end

        def text_to_sql(limit) # :nodoc:
          case limit
          when 0..0xff;               "tinytext"
          when nil, 0x100..0xffff;    "text"
          when 0x10000..0xffffff;     "mediumtext"
          when 0x1000000..0xffffffff; "longtext"
          else raise(ActiveRecordError, "No text type has byte length #{limit}")
          end
        end

        def binary_to_sql(limit) # :nodoc:
          case limit
          when 0..0xff;               "tinyblob"
          when nil, 0x100..0xffff;    "blob"
          when 0x10000..0xffffff;     "mediumblob"
          when 0x1000000..0xffffffff; "longblob"
          else raise(ActiveRecordError, "No binary type has byte length #{limit}")
          end
        end

        class MysqlJson < Type::Internal::AbstractJson # :nodoc:
          def changed_in_place?(raw_old_value, new_value)
            # Normalization is required because MySQL JSON data format includes
            # the space between the elements.
            super(serialize(deserialize(raw_old_value)), new_value)
          end
        end

        class MysqlString < Type::String # :nodoc:
          def serialize(value)
            case value
            when true then MySQL::Quoting::QUOTED_TRUE
            when false then MySQL::Quoting::QUOTED_FALSE
            else super
            end
          end

          private

            def cast_value(value)
              case value
              when true then MySQL::Quoting::QUOTED_TRUE
              when false then MySQL::Quoting::QUOTED_FALSE
              else super
              end
            end
        end

        ActiveRecord::Type.register(:json, MysqlJson, adapter: :mysql2)
        ActiveRecord::Type.register(:string, MysqlString, adapter: :mysql2)
        ActiveRecord::Type.register(:unsigned_integer, Type::UnsignedInteger, adapter: :mysql2)
    end
  end
end
module ActionView
  # This class defines the interface for a renderer. Each class that
  # subclasses +AbstractRenderer+ is used by the base +Renderer+ class to
  # render a specific type of object.
  #
  # The base +Renderer+ class uses its +render+ method to delegate to the
  # renderers. These currently consist of
  #
  #   PartialRenderer - Used for rendering partials
  #   TemplateRenderer - Used for rendering other types of templates
  #   StreamingTemplateRenderer - Used for streaming
  #
  # Whenever the +render+ method is called on the base +Renderer+ class, a new
  # renderer object of the correct type is created, and the +render+ method on
  # that new object is called in turn. This abstracts the setup and rendering
  # into a separate classes for partials and templates.
  class AbstractRenderer #:nodoc:
    delegate :find_template, :find_file, :template_exists?, :any_templates?, :with_fallbacks, :with_layout_format, :formats, to: :@lookup_context

    def initialize(lookup_context)
      @lookup_context = lookup_context
    end

    def render
      raise NotImplementedError
    end

    protected

      def extract_details(options)
        @lookup_context.registered_details.each_with_object({}) do |key, details|
          value = options[key]

          details[key] = Array(value) if value
        end
      end

      def instrument(name, **options)
        options[:identifier] ||= (@template && @template.identifier) || @path

        ActiveSupport::Notifications.instrument("render_#{name}.action_view", options) do |payload|
          yield payload
        end
      end

      def prepend_formats(formats)
        formats = Array(formats)
        return if formats.empty? || @lookup_context.html_fallback_for_js

        @lookup_context.formats = formats | @lookup_context.formats
      end
  end
end
require "rack/utils"
require "rack/request"
require "rack/session/abstract/id"
require "action_dispatch/middleware/cookies"
require "action_dispatch/request/session"

module ActionDispatch
  module Session
    class SessionRestoreError < StandardError #:nodoc:
      def initialize(const_error = nil)
        if const_error
          ActiveSupport::Deprecation.warn("Passing #original_exception is deprecated and has no effect. " \
                                          "Exceptions will automatically capture the original exception.", caller)
        end

        super("Session contains objects whose class definition isn't available.\n" +
          "Remember to require the classes for all objects kept in the session.\n" +
          "(Original exception: #{$!.message} [#{$!.class}])\n")
        set_backtrace $!.backtrace
      end

      def original_exception
        ActiveSupport::Deprecation.warn("#original_exception is deprecated. Use #cause instead.", caller)
        cause
      end
    end

    module Compatibility
      def initialize(app, options = {})
        options[:key] ||= "_session_id"
        super
      end

      def generate_sid
        sid = SecureRandom.hex(16)
        sid.encode!(Encoding::UTF_8)
        sid
      end

    protected

      def initialize_sid
        @default_options.delete(:sidbits)
        @default_options.delete(:secure_random)
      end

      private
        def make_request(env)
          ActionDispatch::Request.new env
        end
    end

    module StaleSessionCheck
      def load_session(env)
        stale_session_check! { super }
      end

      def extract_session_id(env)
        stale_session_check! { super }
      end

      def stale_session_check!
        yield
      rescue ArgumentError => argument_error
        if argument_error.message =~ %r{undefined class/module ([\w:]*\w)}
          begin
            # Note that the regexp does not allow $1 to end with a ':'
            $1.constantize
          rescue LoadError, NameError
            raise ActionDispatch::Session::SessionRestoreError
          end
          retry
        else
          raise
        end
      end
    end

    module SessionObject # :nodoc:
      def prepare_session(req)
        Request::Session.create(self, req, @default_options)
      end

      def loaded_session?(session)
        !session.is_a?(Request::Session) || session.loaded?
      end
    end

    class AbstractStore < Rack::Session::Abstract::Persisted
      include Compatibility
      include StaleSessionCheck
      include SessionObject

      private

        def set_cookie(request, session_id, cookie)
          request.cookie_jar[key] = cookie
        end
    end
  end
end
require "abstract_unit"
require "action_dispatch/middleware/session/abstract_store"

module ActionDispatch
  module Session
    class AbstractStoreTest < ActiveSupport::TestCase
      class MemoryStore < AbstractStore
        def initialize(app)
          @sessions = {}
          super
        end

        def find_session(env, sid)
          sid ||= 1
          session = @sessions[sid] ||= {}
          [sid, session]
        end

        def write_session(env, sid, session, options)
          @sessions[sid] = session
        end
      end

      def test_session_is_set
        env = {}
        as = MemoryStore.new app
        as.call(env)

        assert @env
        assert Request::Session.find ActionDispatch::Request.new @env
      end

      def test_new_session_object_is_merged_with_old
        env = {}
        as = MemoryStore.new app
        as.call(env)

        assert @env
        session = Request::Session.find ActionDispatch::Request.new @env
        session["foo"] = "bar"

        as.call(@env)
        session1 = Request::Session.find ActionDispatch::Request.new @env

        assert_not_equal session, session1
        assert_equal session.to_hash, session1.to_hash
      end

      private
        def app(&block)
          @env = nil
          lambda { |env| @env = env }
        end
    end
  end
end
$:.unshift(File.dirname(__FILE__) + "/lib")
$:.unshift(File.dirname(__FILE__) + "/fixtures/helpers")
$:.unshift(File.dirname(__FILE__) + "/fixtures/alternate_helpers")

require "active_support/core_ext/kernel/reporting"

# These are the normal settings that will be set up by Railties
# TODO: Have these tests support other combinations of these values
silence_warnings do
  Encoding.default_internal = "UTF-8"
  Encoding.default_external = "UTF-8"
end

require "drb"
begin
  require "drb/unix"
rescue LoadError
  puts "'drb/unix' is not available"
end

if ENV["TRAVIS"]
  PROCESS_COUNT = 0
else
  PROCESS_COUNT = (ENV["N"] || 4).to_i
end

require "active_support/testing/autorun"
require "abstract_controller"
require "abstract_controller/railties/routes_helpers"
require "action_controller"
require "action_view"
require "action_view/testing/resolvers"
require "action_dispatch"
require "active_support/dependencies"
require "active_model"

require "pp" # require 'pp' early to prevent hidden_methods from not picking up the pretty-print methods until too late

module Rails
  class << self
    def env
      @_env ||= ActiveSupport::StringInquirer.new(ENV["RAILS_ENV"] || ENV["RACK_ENV"] || "test")
    end

    def root; end;
  end
end

ActiveSupport::Dependencies.hook!

Thread.abort_on_exception = true

# Show backtraces for deprecated behavior for quicker cleanup.
ActiveSupport::Deprecation.debug = true

# Disable available locale checks to avoid warnings running the test suite.
I18n.enforce_available_locales = false

FIXTURE_LOAD_PATH = File.join(File.dirname(__FILE__), "fixtures")

SharedTestRoutes = ActionDispatch::Routing::RouteSet.new

SharedTestRoutes.draw do
  ActiveSupport::Deprecation.silence do
    get ":controller(/:action)"
  end
end

module ActionDispatch
  module SharedRoutes
    def before_setup
      @routes = SharedTestRoutes
      super
    end
  end
end

module ActiveSupport
  class TestCase
    if RUBY_ENGINE == "ruby" && PROCESS_COUNT > 0
      parallelize_me!
    end
  end
end

class RoutedRackApp
  attr_reader :routes

  def initialize(routes, &blk)
    @routes = routes
    @stack = ActionDispatch::MiddlewareStack.new(&blk).build(@routes)
  end

  def call(env)
    @stack.call(env)
  end
end

class ActionDispatch::IntegrationTest < ActiveSupport::TestCase
  def self.build_app(routes = nil)
    RoutedRackApp.new(routes || ActionDispatch::Routing::RouteSet.new) do |middleware|
      middleware.use ActionDispatch::ShowExceptions, ActionDispatch::PublicExceptions.new("#{FIXTURE_LOAD_PATH}/public")
      middleware.use ActionDispatch::DebugExceptions
      middleware.use ActionDispatch::Callbacks
      middleware.use ActionDispatch::Cookies
      middleware.use ActionDispatch::Flash
      middleware.use Rack::MethodOverride
      middleware.use Rack::Head
      yield(middleware) if block_given?
    end
  end

  self.app = build_app

  app.routes.draw do
    ActiveSupport::Deprecation.silence do
      get ":controller(/:action)"
    end
  end

  class DeadEndRoutes < ActionDispatch::Routing::RouteSet
    # Stub Rails dispatcher so it does not get controller references and
    # simply return the controller#action as Rack::Body.
    class NullController < ::ActionController::Metal
      def initialize(controller_name)
        @controller = controller_name
      end

      def make_response!(request)
        self.class.make_response! request
      end

      def dispatch(action, req, res)
        [200, {"Content-Type" => "text/html"}, ["#{@controller}##{action}"]]
      end
    end

    class NullControllerRequest < DelegateClass(ActionDispatch::Request)
      def controller_class
        NullController.new params[:controller]
      end
    end

    def make_request(env)
      NullControllerRequest.new super
    end
  end

  def self.stub_controllers(config = ActionDispatch::Routing::RouteSet::DEFAULT_CONFIG)
    yield DeadEndRoutes.new(config)
  end

  def with_routing(&block)
    temporary_routes = ActionDispatch::Routing::RouteSet.new
    old_app, self.class.app = self.class.app, self.class.build_app(temporary_routes)
    old_routes = SharedTestRoutes
    silence_warnings { Object.const_set(:SharedTestRoutes, temporary_routes) }

    yield temporary_routes
  ensure
    self.class.app = old_app
    remove!
    silence_warnings { Object.const_set(:SharedTestRoutes, old_routes) }
  end

  def with_autoload_path(path)
    path = File.join(File.dirname(__FILE__), "fixtures", path)
    if ActiveSupport::Dependencies.autoload_paths.include?(path)
      yield
    else
      begin
        ActiveSupport::Dependencies.autoload_paths << path
        yield
      ensure
        ActiveSupport::Dependencies.autoload_paths.reject! {|p| p == path}
        ActiveSupport::Dependencies.clear
      end
    end
  end
end

# Temporary base class
class Rack::TestCase < ActionDispatch::IntegrationTest
  def self.testing(klass = nil)
    if klass
      @testing = "/#{klass.name.underscore}".sub!(/_controller$/, "")
    else
      @testing
    end
  end

  def get(thing, *args)
    if thing.is_a?(Symbol)
      super("#{self.class.testing}/#{thing}", *args)
    else
      super
    end
  end

  def assert_body(body)
    assert_equal body, Array(response.body).join
  end

  def assert_status(code)
    assert_equal code, response.status
  end

  def assert_response(body, status = 200, headers = {})
    assert_body body
    assert_status status
    headers.each do |header, value|
      assert_header header, value
    end
  end

  def assert_content_type(type)
    assert_equal type, response.headers["Content-Type"]
  end

  def assert_header(name, value)
    assert_equal value, response.headers[name]
  end
end

module ActionController
  class API
    extend AbstractController::Railties::RoutesHelpers.with(SharedTestRoutes)
  end

  class Base
    # This stub emulates the Railtie including the URL helpers from a Rails application
    extend AbstractController::Railties::RoutesHelpers.with(SharedTestRoutes)
    include SharedTestRoutes.mounted_helpers

    self.view_paths = FIXTURE_LOAD_PATH

    def self.test_routes(&block)
      routes = ActionDispatch::Routing::RouteSet.new
      routes.draw(&block)
      include routes.url_helpers
    end
  end

  class TestCase
    include ActionDispatch::TestProcess
    include ActionDispatch::SharedRoutes
  end
end

class ::ApplicationController < ActionController::Base
end

module ActionDispatch
  class DebugExceptions
    private
      remove_method :stderr_logger
    # Silence logger
      def stderr_logger
        nil
      end
  end
end

module ActionDispatch
  module RoutingVerbs
    def send_request(uri_or_host, method, path)
      host = uri_or_host.host unless path
      path ||= uri_or_host.path

      params = {"PATH_INFO"      => path,
                "REQUEST_METHOD" => method,
                "HTTP_HOST"      => host}

      routes.call(params)
    end

    def request_path_params(path, options = {})
      method = options[:method] || "GET"
      resp = send_request URI("http://localhost" + path), method.to_s.upcase, nil
      status = resp.first
      if status == 404
        raise ActionController::RoutingError, "No route matches #{path.inspect}"
      end
      controller.request.path_parameters
    end

    def get(uri_or_host, path = nil)
      send_request(uri_or_host, "GET", path)[2].join
    end

    def post(uri_or_host, path = nil)
      send_request(uri_or_host, "POST", path)[2].join
    end

    def put(uri_or_host, path = nil)
      send_request(uri_or_host, "PUT", path)[2].join
    end

    def delete(uri_or_host, path = nil)
      send_request(uri_or_host, "DELETE", path)[2].join
    end

    def patch(uri_or_host, path = nil)
      send_request(uri_or_host, "PATCH", path)[2].join
    end
  end
end

module RoutingTestHelpers
  def url_for(set, options)
    route_name = options.delete :use_route
    set.url_for options.merge(only_path: true), route_name
  end

  def make_set(strict = true)
    tc = self
    TestSet.new ->(c) { tc.controller = c }, strict
  end

  class TestSet < ActionDispatch::Routing::RouteSet
    class Request < DelegateClass(ActionDispatch::Request)
      def initialize(target, helpers, block, strict)
        super(target)
        @helpers = helpers
        @block = block
        @strict = strict
      end

      def controller_class
        helpers = @helpers
        block = @block
        Class.new(@strict ? super : ActionController::Base) {
          include helpers
          define_method(:process) { |name| block.call(self) }
          def to_a; [200, {}, []]; end
        }
      end
    end

    attr_reader :strict

    def initialize(block, strict = false)
      @block = block
      @strict = strict
      super()
    end

    private

      def make_request(env)
        Request.new super, url_helpers, @block, strict
      end
  end
end

class ResourcesController < ActionController::Base
  def index() head :ok end
  alias_method :show, :index
end

class CommentsController < ResourcesController; end
class AccountsController <  ResourcesController; end
class ImagesController < ResourcesController; end

# Skips the current run on Rubinius using Minitest::Assertions#skip
def rubinius_skip(message = "")
  skip message if RUBY_ENGINE == "rbx"
end
# Skips the current run on JRuby using Minitest::Assertions#skip
def jruby_skip(message = "")
  skip message if defined?(JRUBY_VERSION)
end

require "active_support/testing/method_call_assertions"

class ForkingExecutor
  class Server
    include DRb::DRbUndumped

    def initialize
      @queue = Queue.new
    end

    def record(reporter, result)
      reporter.record result
    end

    def <<(o)
      o[2] = DRbObject.new(o[2]) if o
      @queue << o
    end
    def pop; @queue.pop; end
  end

  def initialize(size)
    @size  = size
    @queue = Server.new
    file   = File.join Dir.tmpdir, Dir::Tmpname.make_tmpname("rails-tests", "fd")
    @url   = "drbunix://#{file}"
    @pool  = nil
    DRb.start_service @url, @queue
  end

  def <<(work); @queue << work; end

  def shutdown
    pool = @size.times.map {
      fork {
        DRb.stop_service
        queue = DRbObject.new_with_uri @url
        while job = queue.pop
          klass    = job[0]
          method   = job[1]
          reporter = job[2]
          result = Minitest.run_one_method klass, method
          if result.error?
            translate_exceptions result
          end
          queue.record reporter, result
        end
      }
    }
    @size.times { @queue << nil }
    pool.each { |pid| Process.waitpid pid }
  end

  private
    def translate_exceptions(result)
      result.failures.map! { |e|
        begin
          Marshal.dump e
          e
        rescue TypeError
          ex = Exception.new e.message
          ex.set_backtrace e.backtrace
          Minitest::UnexpectedError.new ex
        end
      }
    end
end

if RUBY_ENGINE == "ruby" && PROCESS_COUNT > 0
  # Use N processes (N defaults to 4)
  Minitest.parallel_executor = ForkingExecutor.new(PROCESS_COUNT)
end

class ActiveSupport::TestCase
  include ActiveSupport::Testing::MethodCallAssertions
end
module ActiveModel
  module Validations
    class AcceptanceValidator < EachValidator # :nodoc:
      def initialize(options)
        super({ allow_nil: true, accept: ["1", true] }.merge!(options))
        setup!(options[:class])
      end

      def validate_each(record, attribute, value)
        unless acceptable_option?(value)
          record.errors.add(attribute, :accepted, options.except(:accept, :allow_nil))
        end
      end

      private

        def setup!(klass)
          klass.include(LazilyDefineAttributes.new(AttributeDefinition.new(attributes)))
        end

        def acceptable_option?(value)
          Array(options[:accept]).include?(value)
        end

        class LazilyDefineAttributes < Module
          def initialize(attribute_definition)
            define_method(:respond_to_missing?) do |method_name, include_private=false|
              super(method_name, include_private) || attribute_definition.matches?(method_name)
            end

            define_method(:method_missing) do |method_name, *args, &block|
              if attribute_definition.matches?(method_name)
                attribute_definition.define_on(self.class)
                send(method_name, *args, &block)
              else
                super(method_name, *args, &block)
              end
            end
          end
        end

        class AttributeDefinition
          def initialize(attributes)
            @attributes = attributes.map(&:to_s)
          end

          def matches?(method_name)
            attr_name = convert_to_reader_name(method_name)
            attributes.include?(attr_name)
          end

          def define_on(klass)
            attr_readers = attributes.reject { |name| klass.attribute_method?(name) }
            attr_writers = attributes.reject { |name| klass.attribute_method?("#{name}=") }
            klass.send(:attr_reader, *attr_readers)
            klass.send(:attr_writer, *attr_writers)
          end

          protected

            attr_reader :attributes

          private

            def convert_to_reader_name(method_name)
              method_name.to_s.chomp("=")
            end
        end
    end

    module HelperMethods
      # Encapsulates the pattern of wanting to validate the acceptance of a
      # terms of service check box (or similar agreement).
      #
      #   class Person < ActiveRecord::Base
      #     validates_acceptance_of :terms_of_service
      #     validates_acceptance_of :eula, message: 'must be abided'
      #   end
      #
      # If the database column does not exist, the +terms_of_service+ attribute
      # is entirely virtual. This check is performed only if +terms_of_service+
      # is not +nil+ and by default on save.
      #
      # Configuration options:
      # * <tt>:message</tt> - A custom error message (default is: "must be
      #   accepted").
      # * <tt>:accept</tt> - Specifies a value that is considered accepted.
      #   Also accepts an array of possible values. The default value is
      #   an array ["1", true], which makes it easy to relate to an HTML
      #   checkbox. This should be set to, or include, +true+ if you are validating
      #   a database column, since the attribute is typecast from "1" to +true+
      #   before validation.
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information.
      def validates_acceptance_of(*attr_names)
        validates_with AcceptanceValidator, _merge_attributes(attr_names)
      end
    end
  end
end
require "cases/helper"

require "models/topic"
require "models/reply"
require "models/person"

class AcceptanceValidationTest < ActiveModel::TestCase
  def teardown
    Topic.clear_validators!
  end

  def test_terms_of_service_agreement_no_acceptance
    Topic.validates_acceptance_of(:terms_of_service)

    t = Topic.new("title" => "We should not be confirmed")
    assert t.valid?
  end

  def test_terms_of_service_agreement
    Topic.validates_acceptance_of(:terms_of_service)

    t = Topic.new("title" => "We should be confirmed","terms_of_service" => "")
    assert t.invalid?
    assert_equal ["must be accepted"], t.errors[:terms_of_service]

    t.terms_of_service = "1"
    assert t.valid?
  end

  def test_eula
    Topic.validates_acceptance_of(:eula, message: "must be abided")

    t = Topic.new("title" => "We should be confirmed","eula" => "")
    assert t.invalid?
    assert_equal ["must be abided"], t.errors[:eula]

    t.eula = "1"
    assert t.valid?
  end

  def test_terms_of_service_agreement_with_accept_value
    Topic.validates_acceptance_of(:terms_of_service, accept: "I agree.")

    t = Topic.new("title" => "We should be confirmed", "terms_of_service" => "")
    assert t.invalid?
    assert_equal ["must be accepted"], t.errors[:terms_of_service]

    t.terms_of_service = "I agree."
    assert t.valid?
  end

  def test_terms_of_service_agreement_with_multiple_accept_values
    Topic.validates_acceptance_of(:terms_of_service, accept: [1, "I concur."])

    t = Topic.new("title" => "We should be confirmed", "terms_of_service" => "")
    assert t.invalid?
    assert_equal ["must be accepted"], t.errors[:terms_of_service]

    t.terms_of_service = 1
    assert t.valid?

    t.terms_of_service = "I concur."
    assert t.valid?
  end

  def test_validates_acceptance_of_for_ruby_class
    Person.validates_acceptance_of :karma

    p = Person.new
    p.karma = ""

    assert p.invalid?
    assert_equal ["must be accepted"], p.errors[:karma]

    p.karma = "1"
    assert p.valid?
  ensure
    Person.clear_validators!
  end

  def test_validates_acceptance_of_true
    Topic.validates_acceptance_of(:terms_of_service)

    assert Topic.new(terms_of_service: true).valid?
  end
end
require "abstract_unit"

class StarStarMimeController < ActionController::Base
  layout nil

  def index
    render
  end
end

class StarStarMimeControllerTest < ActionController::TestCase
  def test_javascript_with_format
    @request.accept = "text/javascript"
    get :index, format: "js"
    assert_match "function addition(a,b){ return a+b; }", @response.body
  end

  def test_javascript_with_no_format
    @request.accept = "text/javascript"
    get :index
    assert_match "function addition(a,b){ return a+b; }", @response.body
  end

  def test_javascript_with_no_format_only_star_star
    @request.accept = "*/*"
    get :index
    assert_match "function addition(a,b){ return a+b; }", @response.body
  end
end

class AbstractPostController < ActionController::Base
  self.view_paths = File.dirname(__FILE__) + "/../../fixtures/post_test/"
end

# For testing layouts which are set automatically
class PostController < AbstractPostController
  around_action :with_iphone

  def index
    respond_to(:html, :iphone, :js)
  end

protected

  def with_iphone
    request.format = "iphone" if request.env["HTTP_ACCEPT"] == "text/iphone"
    yield
  end
end

class SuperPostController < PostController
end

class MimeControllerLayoutsTest < ActionController::TestCase
  tests PostController

  def setup
    super
    @request.host = "www.example.com"
    Mime::Type.register_alias("text/html", :iphone)
  end

  def teardown
    super
    Mime::Type.unregister(:iphone)
  end

  def test_missing_layout_renders_properly
    get :index
    assert_equal '<html><div id="html">Hello Firefox</div></html>', @response.body

    @request.accept = "text/iphone"
    get :index
    assert_equal "Hello iPhone", @response.body
  end

  def test_format_with_inherited_layouts
    @controller = SuperPostController.new

    get :index
    assert_equal '<html><div id="html">Super Firefox</div></html>', @response.body

    @request.accept = "text/iphone"
    get :index
    assert_equal '<html><div id="super_iphone">Super iPhone</div></html>', @response.body
  end

  def test_non_navigational_format_with_no_template_fallbacks_to_html_template_with_no_layout
    get :index, format: :js
    assert_equal "Hello Firefox", @response.body
  end
end
module ActiveModel
  module Type
    module Helpers
      class AcceptsMultiparameterTime < Module # :nodoc:
        def initialize(defaults: {})
          define_method(:cast) do |value|
            if value.is_a?(Hash)
              value_from_multiparameter_assignment(value)
            else
              super(value)
            end
          end

          define_method(:assert_valid_value) do |value|
            if value.is_a?(Hash)
              value_from_multiparameter_assignment(value)
            else
              super(value)
            end
          end

          define_method(:value_from_multiparameter_assignment) do |values_hash|
            defaults.each do |k, v|
              values_hash[k] ||= v
            end
            return unless values_hash[1] && values_hash[2] && values_hash[3]
            values = values_hash.sort.map(&:last)
            ::Time.send(default_timezone, *values)
          end
          private :value_from_multiparameter_assignment
        end
      end
    end
  end
end
require "abstract_unit"
require "action_controller/metal/strong_parameters"
require "active_support/core_ext/hash/transform_values"

class ParametersAccessorsTest < ActiveSupport::TestCase
  setup do
    ActionController::Parameters.permit_all_parameters = false

    @params = ActionController::Parameters.new(
      person: {
        age: "32",
        name: {
          first: "David",
          last: "Heinemeier Hansson"
        },
        addresses: [{city: "Chicago", state: "Illinois"}]
      }
    )
  end

  test "[] retains permitted status" do
    @params.permit!
    assert @params[:person].permitted?
    assert @params[:person][:name].permitted?
  end

  test "[] retains unpermitted status" do
    assert_not @params[:person].permitted?
    assert_not @params[:person][:name].permitted?
  end

  test "as_json returns the JSON representation of the parameters hash" do
    assert_not @params.as_json.key? "parameters"
    assert_not @params.as_json.key? "permitted"
    assert @params.as_json.key? "person"
  end

  test "each carries permitted status" do
    @params.permit!
    @params.each { |key, value| assert(value.permitted?) if key == "person" }
  end

  test "each carries unpermitted status" do
    @params.each { |key, value| assert_not(value.permitted?) if key == "person" }
  end

  test "each_pair carries permitted status" do
    @params.permit!
    @params.each_pair { |key, value| assert(value.permitted?) if key == "person" }
  end

  test "each_pair carries unpermitted status" do
    @params.each_pair { |key, value| assert_not(value.permitted?) if key == "person" }
  end

  test "except retains permitted status" do
    @params.permit!
    assert @params.except(:person).permitted?
    assert @params[:person].except(:name).permitted?
  end

  test "except retains unpermitted status" do
    assert_not @params.except(:person).permitted?
    assert_not @params[:person].except(:name).permitted?
  end

  test "fetch retains permitted status" do
    @params.permit!
    assert @params.fetch(:person).permitted?
    assert @params[:person].fetch(:name).permitted?
  end

  test "fetch retains unpermitted status" do
    assert_not @params.fetch(:person).permitted?
    assert_not @params[:person].fetch(:name).permitted?
  end

  test "reject retains permitted status" do
    assert_not @params.reject { |k| k == "person" }.permitted?
  end

  test "reject retains unpermitted status" do
    @params.permit!
    assert @params.reject { |k| k == "person" }.permitted?
  end

  test "select retains permitted status" do
    @params.permit!
    assert @params.select { |k| k == "person" }.permitted?
  end

  test "select retains unpermitted status" do
    assert_not @params.select { |k| k == "person" }.permitted?
  end

  test "slice retains permitted status" do
    @params.permit!
    assert @params.slice(:person).permitted?
  end

  test "slice retains unpermitted status" do
    assert_not @params.slice(:person).permitted?
  end

  test "transform_keys retains permitted status" do
    @params.permit!
    assert @params.transform_keys { |k| k }.permitted?
  end

  test "transform_keys retains unpermitted status" do
    assert_not @params.transform_keys { |k| k }.permitted?
  end

  test "transform_values retains permitted status" do
    @params.permit!
    assert @params.transform_values { |v| v }.permitted?
  end

  test "transform_values retains unpermitted status" do
    assert_not @params.transform_values { |v| v }.permitted?
  end

  test "values_at retains permitted status" do
    @params.permit!
    assert @params.values_at(:person).first.permitted?
    assert @params[:person].values_at(:name).first.permitted?
  end

  test "values_at retains unpermitted status" do
    assert_not @params.values_at(:person).first.permitted?
    assert_not @params[:person].values_at(:name).first.permitted?
  end

  test "equality with a hash is deprecated" do
    hash1 = { foo: :bar }
    params1 = ActionController::Parameters.new(hash1)
    assert_deprecated("will be removed in Rails 5.1") do
      assert(params1 == hash1)
    end
  end

  test "is equal to Parameters instance with same params" do
    params1 = ActionController::Parameters.new(a: 1, b: 2)
    params2 = ActionController::Parameters.new(a: 1, b: 2)
    assert(params1 == params2)
  end

  test "is equal to Parameters instance with same permitted params" do
    params1 = ActionController::Parameters.new(a: 1, b: 2).permit(:a)
    params2 = ActionController::Parameters.new(a: 1, b: 2).permit(:a)
    assert(params1 == params2)
  end

  test "is equal to Parameters instance with same different source params, but same permitted params" do
    params1 = ActionController::Parameters.new(a: 1, b: 2).permit(:a)
    params2 = ActionController::Parameters.new(a: 1, c: 3).permit(:a)
    assert(params1 == params2)
    assert(params2 == params1)
  end

  test "is not equal to an unpermitted Parameters instance with same params" do
    params1 = ActionController::Parameters.new(a: 1).permit(:a)
    params2 = ActionController::Parameters.new(a: 1)
    assert(params1 != params2)
    assert(params2 != params1)
  end

  test "is not equal to Parameters instance with different permitted params" do
    params1 = ActionController::Parameters.new(a: 1, b: 2).permit(:a, :b)
    params2 = ActionController::Parameters.new(a: 1, b: 2).permit(:a)
    assert(params1 != params2)
    assert(params2 != params1)
  end

  test "equality with simple types works" do
    assert(@params != "Hello")
    assert(@params != 42)
    assert(@params != false)
  end

  test "inspect shows both class name, parameters and permitted flag" do
    assert_equal(
      '<ActionController::Parameters {"person"=>{"age"=>"32", '\
        '"name"=>{"first"=>"David", "last"=>"Heinemeier Hansson"}, ' \
        '"addresses"=>[{"city"=>"Chicago", "state"=>"Illinois"}]}} permitted: false>',
      @params.inspect
    )
  end

  test "inspect prints updated permitted flag in the output" do
    assert_match(/permitted: false/, @params.inspect)

    @params.permit!

    assert_match(/permitted: true/, @params.inspect)
  end

  if Hash.method_defined?(:dig)
    test "#dig delegates the dig method to its values" do
      assert_equal "David", @params.dig(:person, :name, :first)
      assert_equal "Chicago", @params.dig(:person, :addresses, 0, :city)
    end

    test "#dig converts hashes to parameters" do
      assert_kind_of ActionController::Parameters, @params.dig(:person)
      assert_kind_of ActionController::Parameters, @params.dig(:person, :addresses, 0)
      assert @params.dig(:person, :addresses).all? do |value|
        value.is_a?(ActionController::Parameters)
      end
    end
  else
    test "ActionController::Parameters does not respond to #dig on Ruby 2.2" do
      assert_not ActionController::Parameters.method_defined?(:dig)
      assert_not @params.respond_to?(:dig)
    end
  end
end
class Array
  # Returns the tail of the array from +position+.
  #
  #   %w( a b c d ).from(0)  # => ["a", "b", "c", "d"]
  #   %w( a b c d ).from(2)  # => ["c", "d"]
  #   %w( a b c d ).from(10) # => []
  #   %w().from(0)           # => []
  #   %w( a b c d ).from(-2) # => ["c", "d"]
  #   %w( a b c ).from(-10)  # => []
  def from(position)
    self[position, length] || []
  end

  # Returns the beginning of the array up to +position+.
  #
  #   %w( a b c d ).to(0)  # => ["a"]
  #   %w( a b c d ).to(2)  # => ["a", "b", "c"]
  #   %w( a b c d ).to(10) # => ["a", "b", "c", "d"]
  #   %w().to(0)           # => []
  #   %w( a b c d ).to(-2) # => ["a", "b", "c"]
  #   %w( a b c ).to(-10)  # => []
  def to(position)
    if position >= 0
      take position + 1
    else
      self[0..position]
    end
  end

  # Returns a copy of the Array without the specified elements.
  #
  #   people = ["David", "Rafael", "Aaron", "Todd"]
  #   people.without "Aaron", "Todd"
  #     => ["David", "Rafael"]
  #
  # Note: This is an optimization of `Enumerable#without` that uses `Array#-`
  # instead of `Array#reject` for performance reasons.
  def without(*elements)
    self - elements
  end

  # Equal to <tt>self[1]</tt>.
  #
  #   %w( a b c d e ).second # => "b"
  def second
    self[1]
  end

  # Equal to <tt>self[2]</tt>.
  #
  #   %w( a b c d e ).third # => "c"
  def third
    self[2]
  end

  # Equal to <tt>self[3]</tt>.
  #
  #   %w( a b c d e ).fourth # => "d"
  def fourth
    self[3]
  end

  # Equal to <tt>self[4]</tt>.
  #
  #   %w( a b c d e ).fifth # => "e"
  def fifth
    self[4]
  end

  # Equal to <tt>self[41]</tt>. Also known as accessing "the reddit".
  #
  #   (1..42).to_a.forty_two # => 42
  def forty_two
    self[41]
  end

  # Equal to <tt>self[-3]</tt>.
  #
  #   %w( a b c d e ).third_to_last # => "c"
  def third_to_last
    self[-3]
  end

  # Equal to <tt>self[-2]</tt>.
  #
  #   %w( a b c d e ).second_to_last # => "d"
  def second_to_last
    self[-2]
  end
end
require "abstract_unit"
require "active_support/core_ext/array"

class AccessTest < ActiveSupport::TestCase
  def test_from
    assert_equal %w( a b c d ), %w( a b c d ).from(0)
    assert_equal %w( c d ), %w( a b c d ).from(2)
    assert_equal %w(), %w( a b c d ).from(10)
    assert_equal %w( d e ), %w( a b c d e ).from(-2)
    assert_equal %w(), %w( a b c d e ).from(-10)
  end

  def test_to
    assert_equal %w( a ), %w( a b c d ).to(0)
    assert_equal %w( a b c ), %w( a b c d ).to(2)
    assert_equal %w( a b c d ), %w( a b c d ).to(10)
    assert_equal %w( a b c ), %w( a b c d ).to(-2)
    assert_equal %w(), %w( a b c ).to(-10)
  end

  def test_specific_accessor
    array = (1..42).to_a

    assert_equal array[1], array.second
    assert_equal array[2], array.third
    assert_equal array[3], array.fourth
    assert_equal array[4], array.fifth
    assert_equal array[41], array.forty_two
    assert_equal array[-3], array.third_to_last
    assert_equal array[-2], array.second_to_last
  end

  def test_without
    assert_equal [1, 2, 4], [1, 2, 3, 4, 5].without(3, 5)
  end
end
class Account
  include ActiveModel::ForbiddenAttributesProtection

  public :sanitize_for_mass_assignment
end
module ActionCable
  module Helpers
    module ActionCableHelper
      # Returns an "action-cable-url" meta tag with the value of the URL specified in your
      # configuration. Ensure this is above your JavaScript tag:
      #
      #   <head>
      #     <%= action_cable_meta_tag %>
      #     <%= javascript_include_tag 'application', 'data-turbolinks-track' => true %>
      #   </head>
      #
      # This is then used by Action Cable to determine the URL of your WebSocket server.
      # Your CoffeeScript can then connect to the server without needing to specify the
      # URL directly:
      #
      #   #= require cable
      #   @App = {}
      #   App.cable = Cable.createConsumer()
      #
      # Make sure to specify the correct server location in each of your environment
      # config files:
      #
      #   config.action_cable.mount_path = "/cable123"
      #   <%= action_cable_meta_tag %> would render:
      #   => <meta name="action-cable-url" content="/cable123" />
      #
      #   config.action_cable.url = "ws://actioncable.com"
      #   <%= action_cable_meta_tag %> would render:
      #   => <meta name="action-cable-url" content="ws://actioncable.com" />
      #
      def action_cable_meta_tag
        tag "meta", name: "action-cable-url", content: (
          ActionCable.server.config.url ||
          ActionCable.server.config.mount_path ||
          raise("No Action Cable URL configured -- please configure this at config.action_cable.url")
        )
      end
    end
  end
end
#--
# Copyright (c) 2015-2016 Basecamp, LLC
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#++

require "active_support"
require "active_support/rails"
require "action_cable/version"

module ActionCable
  extend ActiveSupport::Autoload

  INTERNAL = {
    message_types: {
      welcome: "welcome".freeze,
      ping: "ping".freeze,
      confirmation: "confirm_subscription".freeze,
      rejection: "reject_subscription".freeze
    },
    default_mount_path: "/cable".freeze,
    protocols: ["actioncable-v1-json".freeze, "actioncable-unsupported".freeze].freeze
  }

  # Singleton instance of the server
  module_function def server
    @server ||= ActionCable::Server::Base.new
  end

  autoload :Server
  autoload :Connection
  autoload :Channel
  autoload :RemoteConnections
  autoload :SubscriptionAdapter
end
begin
  require "bundler/inline"
rescue LoadError => e
  $stderr.puts "Bundler version 1.10 or later is required. Please update your Bundler"
  raise e
end

gemfile(true) do
  source "https://rubygems.org"
  # Activate the gem you are reporting the issue against.
  gem "rails", "5.0.0"
end

require "rack/test"
require "action_controller/railtie"

class TestApp < Rails::Application
  config.root = File.dirname(__FILE__)
  config.session_store :cookie_store, key: "cookie_store_key"
  secrets.secret_token    = "secret_token"
  secrets.secret_key_base = "secret_key_base"

  config.logger = Logger.new($stdout)
  Rails.logger  = config.logger

  routes.draw do
    get "/" => "test#index"
  end
end

class TestController < ActionController::Base
  include Rails.application.routes.url_helpers

  def index
    render plain: "Home"
  end
end

require "minitest/autorun"

# Ensure backward compatibility with Minitest 4
Minitest::Test = MiniTest::Unit::TestCase unless defined?(Minitest::Test)

class BugTest < Minitest::Test
  include Rack::Test::Methods

  def test_returns_success
    get "/"
    assert last_response.ok?
  end

  private
    def app
      Rails.application
    end
end
begin
  require "bundler/inline"
rescue LoadError => e
  $stderr.puts "Bundler version 1.10 or later is required. Please update your Bundler"
  raise e
end

gemfile(true) do
  source "https://rubygems.org"
  gem "rails", github: "rails/rails"
end

require "action_controller/railtie"

class TestApp < Rails::Application
  config.root = File.dirname(__FILE__)
  config.session_store :cookie_store, key: "cookie_store_key"
  secrets.secret_token    = "secret_token"
  secrets.secret_key_base = "secret_key_base"

  config.logger = Logger.new($stdout)
  Rails.logger  = config.logger

  routes.draw do
    get "/" => "test#index"
  end
end

class TestController < ActionController::Base
  include Rails.application.routes.url_helpers

  def index
    render plain: "Home"
  end
end

require "minitest/autorun"
require "rack/test"

class BugTest < Minitest::Test
  include Rack::Test::Methods

  def test_returns_success
    get "/"
    assert last_response.ok?
  end

  private
    def app
      Rails.application
    end
end
require "active_support/rails"
require "abstract_controller"
require "action_dispatch"
require "action_controller/metal/live"
require "action_controller/metal/strong_parameters"

module ActionController
  extend ActiveSupport::Autoload

  autoload :API
  autoload :Base
  autoload :Metal
  autoload :Middleware
  autoload :Renderer
  autoload :FormBuilder

  eager_autoload do
    autoload :Caching
  end

  autoload_under "metal" do
    autoload :ConditionalGet
    autoload :Cookies
    autoload :DataStreaming
    autoload :EtagWithTemplateDigest
    autoload :Flash
    autoload :ForceSSL
    autoload :Head
    autoload :Helpers
    autoload :HttpAuthentication
    autoload :BasicImplicitRender
    autoload :ImplicitRender
    autoload :Instrumentation
    autoload :MimeResponds
    autoload :ParamsWrapper
    autoload :Redirecting
    autoload :Renderers
    autoload :Rendering
    autoload :RequestForgeryProtection
    autoload :Rescue
    autoload :Streaming
    autoload :StrongParameters
    autoload :Testing
    autoload :UrlFor
  end

  autoload_under "api" do
    autoload :ApiRendering
  end

  autoload :TestCase,           "action_controller/test_case"
  autoload :TemplateAssertions, "action_controller/test_case"
end

# Common Active Support usage in Action Controller
require "active_support/core_ext/module/attribute_accessors"
require "active_support/core_ext/load_error"
require "active_support/core_ext/module/attr_internal"
require "active_support/core_ext/name_error"
require "active_support/core_ext/uri"
require "active_support/inflector"
#--
# Copyright (c) 2004-2016 David Heinemeier Hansson
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#++

require "active_support"
require "active_support/rails"
require "active_support/core_ext/module/attribute_accessors"

require "action_pack"
require "rack"

module Rack
  autoload :Test, "rack/test"
end

module ActionDispatch
  extend ActiveSupport::Autoload

  class IllegalStateError < StandardError
  end

  eager_autoload do
    autoload_under "http" do
      autoload :Request
      autoload :Response
    end
  end

  autoload_under "middleware" do
    autoload :RequestId
    autoload :Callbacks
    autoload :Cookies
    autoload :DebugExceptions
    autoload :DebugLocks
    autoload :ExceptionWrapper
    autoload :Executor
    autoload :Flash
    autoload :ParamsParser
    autoload :PublicExceptions
    autoload :Reloader
    autoload :RemoteIp
    autoload :ShowExceptions
    autoload :SSL
    autoload :Static
  end

  autoload :Journey
  autoload :MiddlewareStack, "action_dispatch/middleware/stack"
  autoload :Routing

  module Http
    extend ActiveSupport::Autoload

    autoload :Cache
    autoload :Headers
    autoload :MimeNegotiation
    autoload :Parameters
    autoload :ParameterFilter
    autoload :Upload
    autoload :UploadedFile, "action_dispatch/http/upload"
    autoload :URL
  end

  module Session
    autoload :AbstractStore,     "action_dispatch/middleware/session/abstract_store"
    autoload :CookieStore,       "action_dispatch/middleware/session/cookie_store"
    autoload :MemCacheStore,     "action_dispatch/middleware/session/mem_cache_store"
    autoload :CacheStore,        "action_dispatch/middleware/session/cache_store"
  end

  mattr_accessor :test_app

  autoload_under "testing" do
    autoload :Assertions
    autoload :Integration
    autoload :IntegrationTest, "action_dispatch/testing/integration"
    autoload :TestProcess
    autoload :TestRequest
    autoload :TestResponse
    autoload :AssertionResponse
  end
end

autoload :Mime, "action_dispatch/http/mime_type"

ActiveSupport.on_load(:action_view) do
  ActionView::Base.default_formats ||= Mime::SET.symbols
  ActionView::Template::Types.delegate_to Mime
end
#--
# Copyright (c) 2004-2016 David Heinemeier Hansson
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#++

require "abstract_controller"
require "action_mailer/version"

# Common Active Support usage in Action Mailer
require "active_support/rails"
require "active_support/core_ext/class"
require "active_support/core_ext/module/attr_internal"
require "active_support/core_ext/string/inflections"
require "active_support/lazy_load_hooks"

module ActionMailer
  extend ::ActiveSupport::Autoload

  eager_autoload do
    autoload :Collector
  end

  autoload :Base
  autoload :DeliveryMethods
  autoload :InlinePreviewInterceptor
  autoload :MailHelper
  autoload :Preview
  autoload :Previews, "action_mailer/preview"
  autoload :TestCase
  autoload :TestHelper
  autoload :MessageDelivery
  autoload :DeliveryJob
end

autoload :Mime, "action_dispatch/http/mime_type"

ActiveSupport.on_load(:action_view) do
  ActionView::Base.default_formats ||= Mime::SET.symbols
  ActionView::Template::Types.delegate_to Mime
end
require "abstract_unit"
require "controller/fake_controllers"

class ActionPackAssertionsController < ActionController::Base
  def nothing() head :ok end

  def hello_xml_world() render template: "test/hello_xml_world"; end

  def hello_xml_world_pdf
    self.content_type = "application/pdf"
    render template: "test/hello_xml_world"
  end

  def hello_xml_world_pdf_header
    response.headers["Content-Type"] = "application/pdf; charset=utf-8"
    render template: "test/hello_xml_world"
  end

  def redirect_internal() redirect_to "/nothing"; end

  def redirect_to_action() redirect_to action: "flash_me", id: 1, params: { "panda" => "fun" }; end

  def redirect_to_controller() redirect_to controller: "elsewhere", action: "flash_me"; end

  def redirect_to_controller_with_symbol() redirect_to controller: :elsewhere, action: :flash_me; end

  def redirect_to_path() redirect_to "/some/path" end

  def redirect_invalid_external_route() redirect_to "ht_tp://www.rubyonrails.org" end

  def redirect_to_named_route() redirect_to route_one_url end

  def redirect_external() redirect_to "http://www.rubyonrails.org"; end

  def redirect_external_protocol_relative() redirect_to "//www.rubyonrails.org"; end

  def response404() head "404 AWOL" end

  def response500() head "500 Sorry" end

  def response599() head "599 Whoah!" end

  def flash_me
    flash["hello"] = "my name is inigo montoya..."
    render plain: "Inconceivable!"
  end

  def flash_me_naked
    flash.clear
    render plain: "wow!"
  end

  def assign_this
    @howdy = "ho"
    render inline: "Mr. Henke"
  end

  def render_based_on_parameters
    render plain: "Mr. #{params[:name]}"
  end

  def render_url
    render html: "<div>#{url_for(action: 'flash_me', only_path: true)}</div>"
  end

  def render_text_with_custom_content_type
    render body: "Hello!", content_type: Mime[:rss]
  end

  def session_stuffing
    session["xmas"] = "turkey"
    render plain: "ho ho ho"
  end

  def raise_exception_on_get
    raise "get" if request.get?
    render plain: "request method: #{request.env['REQUEST_METHOD']}"
  end

  def raise_exception_on_post
    raise "post" if request.post?
    render plain: "request method: #{request.env['REQUEST_METHOD']}"
  end

  def render_file_absolute_path
    render file: File.expand_path("../../../README.rdoc", __FILE__)
  end

  def render_file_relative_path
    render file: "README.rdoc"
  end
end

# Used to test that assert_response includes the exception message
# in the failure message when an action raises and assert_response
# is expecting something other than an error.
class AssertResponseWithUnexpectedErrorController < ActionController::Base
  def index
    raise "FAIL"
  end

  def show
    render plain: "Boom", status: 500
  end
end

module Admin
  class InnerModuleController < ActionController::Base
    def index
      head :ok
    end

    def redirect_to_index
      redirect_to admin_inner_module_path
    end

    def redirect_to_absolute_controller
      redirect_to controller: "/content"
    end

    def redirect_to_fellow_controller
      redirect_to controller: "user"
    end

    def redirect_to_top_level_named_route
      redirect_to top_level_url(id: "foo")
    end
  end
end

class ActionPackAssertionsControllerTest < ActionController::TestCase
  def test_render_file_absolute_path
    get :render_file_absolute_path
    assert_match(/\A= Action Pack/, @response.body)
  end

  def test_render_file_relative_path
    get :render_file_relative_path
    assert_match(/\A= Action Pack/, @response.body)
  end

  def test_get_request
    assert_raise(RuntimeError) { get :raise_exception_on_get }
    get :raise_exception_on_post
    assert_equal "request method: GET", @response.body
  end

  def test_post_request
    assert_raise(RuntimeError) { post :raise_exception_on_post }
    post :raise_exception_on_get
    assert_equal "request method: POST", @response.body
  end

  def test_get_post_request_switch
    post :raise_exception_on_get
    assert_equal "request method: POST", @response.body
    get :raise_exception_on_post
    assert_equal "request method: GET", @response.body
    post :raise_exception_on_get
    assert_equal "request method: POST", @response.body
    get :raise_exception_on_post
    assert_equal "request method: GET", @response.body
  end

  def test_string_constraint
    with_routing do |set|
      set.draw do
        get "photos", to: "action_pack_assertions#nothing", constraints: {subdomain: "admin"}
      end
    end
  end

  def test_assert_redirect_to_named_route_failure
    with_routing do |set|
      set.draw do
        get "route_one", to: "action_pack_assertions#nothing", as: :route_one
        get "route_two", to: "action_pack_assertions#nothing", id: "two", as: :route_two

        ActiveSupport::Deprecation.silence do
          get ":controller/:action"
        end
      end
      process :redirect_to_named_route
      assert_raise(ActiveSupport::TestCase::Assertion) do
        assert_redirected_to "http://test.host/route_two"
      end
      assert_raise(ActiveSupport::TestCase::Assertion) do
        assert_redirected_to %r(^http://test.host/route_two)
      end
      assert_raise(ActiveSupport::TestCase::Assertion) do
        assert_redirected_to controller: "action_pack_assertions", action: "nothing", id: "two"
      end
      assert_raise(ActiveSupport::TestCase::Assertion) do
        assert_redirected_to route_two_url
      end
    end
  end

  def test_assert_redirect_to_nested_named_route
    @controller = Admin::InnerModuleController.new

    with_routing do |set|
      set.draw do
        get "admin/inner_module", to: "admin/inner_module#index", as: :admin_inner_module

        ActiveSupport::Deprecation.silence do
          get ":controller/:action"
        end
      end
      process :redirect_to_index
      # redirection is <{"action"=>"index", "controller"=>"admin/admin/inner_module"}>
      assert_redirected_to admin_inner_module_path
    end
  end

  def test_assert_redirected_to_top_level_named_route_from_nested_controller
    @controller = Admin::InnerModuleController.new

    with_routing do |set|
      set.draw do
        get "/action_pack_assertions/:id", to: "action_pack_assertions#index", as: :top_level

        ActiveSupport::Deprecation.silence do
          get ":controller/:action"
        end
      end
      process :redirect_to_top_level_named_route
      # assert_redirected_to "http://test.host/action_pack_assertions/foo" would pass because of exact match early return
      assert_redirected_to "/action_pack_assertions/foo"
      assert_redirected_to %r(/action_pack_assertions/foo)
    end
  end

  def test_assert_redirected_to_top_level_named_route_with_same_controller_name_in_both_namespaces
    @controller = Admin::InnerModuleController.new

    with_routing do |set|
      set.draw do
        # this controller exists in the admin namespace as well which is the only difference from previous test
        get "/user/:id", to: "user#index", as: :top_level

        ActiveSupport::Deprecation.silence do
          get ":controller/:action"
        end
      end
      process :redirect_to_top_level_named_route
      # assert_redirected_to top_level_url('foo') would pass because of exact match early return
      assert_redirected_to top_level_path("foo")
    end
  end

  def test_assert_redirect_failure_message_with_protocol_relative_url
    begin
      process :redirect_external_protocol_relative
      assert_redirected_to "/foo"
    rescue ActiveSupport::TestCase::Assertion => ex
      assert_no_match(
        /#{request.protocol}#{request.host}\/\/www.rubyonrails.org/,
        ex.message,
        "protocol relative url was incorrectly normalized"
      )
    end
  end

  def test_template_objects_exist
    process :assign_this
    assert !@controller.instance_variable_defined?(:"@hi")
    assert @controller.instance_variable_get(:"@howdy")
  end

  def test_template_objects_missing
    process :nothing
    assert !@controller.instance_variable_defined?(:@howdy)
  end

  def test_empty_flash
    process :flash_me_naked
    assert flash.empty?
  end

  def test_flash_exist
    process :flash_me
    assert flash.any?
    assert flash["hello"].present?
  end

  def test_flash_does_not_exist
    process :nothing
    assert flash.empty?
  end

  def test_session_exist
    process :session_stuffing
    assert_equal "turkey", session["xmas"]
  end

  def session_does_not_exist
    process :nothing
    assert session.empty?
  end

  def test_redirection_location
    process :redirect_internal
    assert_equal "http://test.host/nothing", @response.redirect_url

    process :redirect_external
    assert_equal "http://www.rubyonrails.org", @response.redirect_url

    process :redirect_external_protocol_relative
    assert_equal "//www.rubyonrails.org", @response.redirect_url
  end

  def test_no_redirect_url
    process :nothing
    assert_nil @response.redirect_url
  end

  def test_server_error_response_code
    process :response500
    assert @response.server_error?

    process :response599
    assert @response.server_error?

    process :response404
    assert !@response.server_error?
  end

  def test_missing_response_code
    process :response404
    assert @response.not_found?
  end

  def test_client_error_response_code
    process :response404
    assert @response.client_error?
  end

  def test_redirect_url_match
    process :redirect_external
    assert @response.redirect?
    assert_match(/rubyonrails/, @response.redirect_url)
    assert !/perloffrails/.match(@response.redirect_url)
  end

  def test_redirection
    process :redirect_internal
    assert @response.redirect?

    process :redirect_external
    assert @response.redirect?

    process :nothing
    assert !@response.redirect?
  end

  def test_successful_response_code
    process :nothing
    assert @response.successful?
  end

  def test_response_object
    process :nothing
    assert_kind_of ActionDispatch::TestResponse, @response
  end

  def test_render_based_on_parameters
    process :render_based_on_parameters,
      method: "GET",
      params: { name: "David" }
    assert_equal "Mr. David", @response.body
  end

  def test_assert_redirection_fails_with_incorrect_controller
    process :redirect_to_controller
    assert_raise(ActiveSupport::TestCase::Assertion) do
      assert_redirected_to controller: "action_pack_assertions", action: "flash_me"
    end
  end

  def test_assert_redirection_with_extra_controller_option
    get :redirect_to_action
    assert_redirected_to controller: "action_pack_assertions", action: "flash_me", id: 1, params: { panda: "fun" }
  end

  def test_redirected_to_url_leading_slash
    process :redirect_to_path
    assert_redirected_to "/some/path"
  end

  def test_redirected_to_url_no_leading_slash_fails
    process :redirect_to_path
    assert_raise ActiveSupport::TestCase::Assertion do
      assert_redirected_to "some/path"
    end
  end

  def test_redirect_invalid_external_route
    process :redirect_invalid_external_route
    assert_redirected_to "http://test.hostht_tp://www.rubyonrails.org"
  end

  def test_redirected_to_url_full_url
    process :redirect_to_path
    assert_redirected_to "http://test.host/some/path"
  end

  def test_assert_redirection_with_symbol
    process :redirect_to_controller_with_symbol
    assert_nothing_raised {
      assert_redirected_to controller: "elsewhere", action: "flash_me"
    }
    process :redirect_to_controller_with_symbol
    assert_nothing_raised {
      assert_redirected_to controller: :elsewhere, action: :flash_me
    }
  end

  def test_redirected_to_with_nested_controller
    @controller = Admin::InnerModuleController.new
    get :redirect_to_absolute_controller
    assert_redirected_to controller: "/content"

    get :redirect_to_fellow_controller
    assert_redirected_to controller: "admin/user"
  end

  def test_assert_response_uses_exception_message
    @controller = AssertResponseWithUnexpectedErrorController.new
    e = assert_raise RuntimeError, "Expected non-success response" do
      get :index
    end
    assert_response :success
    assert_includes "FAIL", e.message
  end

  def test_assert_response_failure_response_with_no_exception
    @controller = AssertResponseWithUnexpectedErrorController.new
    get :show
    assert_response 500
    assert_equal "Boom", response.body
  end
end

class ActionPackHeaderTest < ActionController::TestCase
  tests ActionPackAssertionsController

  def test_rendering_xml_sets_content_type
    process :hello_xml_world
    assert_equal("application/xml; charset=utf-8", @response.headers["Content-Type"])
  end

  def test_rendering_xml_respects_content_type
    process :hello_xml_world_pdf
    assert_equal("application/pdf; charset=utf-8", @response.headers["Content-Type"])
  end

  def test_rendering_xml_respects_content_type_when_set_in_the_header
    process :hello_xml_world_pdf_header
    assert_equal("application/pdf; charset=utf-8", @response.headers["Content-Type"])
  end

  def test_render_text_with_custom_content_type
    get :render_text_with_custom_content_type
    assert_equal "application/rss+xml; charset=utf-8", @response.headers["Content-Type"]
  end
end
#--
# Copyright (c) 2004-2016 David Heinemeier Hansson
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#++

require "action_pack/version"
module Rails
  module Generators
    module Actions
      def initialize(*) # :nodoc:
        super
        @in_group = nil
        @after_bundle_callbacks = []
      end

      # Adds an entry into +Gemfile+ for the supplied gem.
      #
      #   gem "rspec", group: :test
      #   gem "technoweenie-restful-authentication", lib: "restful-authentication", source: "http://gems.github.com/"
      #   gem "rails", "3.0", git: "git://github.com/rails/rails"
      def gem(*args)
        options = args.extract_options!
        name, version = args

        # Set the message to be shown in logs. Uses the git repo if one is given,
        # otherwise use name (version).
        parts, message = [ quote(name) ], name.dup
        if version ||= options.delete(:version)
          parts   << quote(version)
          message << " (#{version})"
        end
        message = options[:git] if options[:git]

        log :gemfile, message

        options.each do |option, value|
          parts << "#{option}: #{quote(value)}"
        end

        in_root do
          str = "gem #{parts.join(", ")}"
          str = "  " + str if @in_group
          str = "\n" + str
          append_file "Gemfile", str, verbose: false
        end
      end

      # Wraps gem entries inside a group.
      #
      #   gem_group :development, :test do
      #     gem "rspec-rails"
      #   end
      def gem_group(*names, &block)
        name = names.map(&:inspect).join(", ")
        log :gemfile, "group #{name}"

        in_root do
          append_file "Gemfile", "\ngroup #{name} do", force: true

          @in_group = true
          instance_eval(&block)
          @in_group = false

          append_file "Gemfile", "\nend\n", force: true
        end
      end

      # Add the given source to +Gemfile+
      #
      # If block is given, gem entries in block are wrapped into the source group.
      #
      #   add_source "http://gems.github.com/"
      #
      #   add_source "http://gems.github.com/" do
      #     gem "rspec-rails"
      #   end
      def add_source(source, options={}, &block)
        log :source, source

        in_root do
          if block
            append_file "Gemfile", "\nsource #{quote(source)} do", force: true
            @in_group = true
            instance_eval(&block)
            @in_group = false
            append_file "Gemfile", "\nend\n", force: true
          else
            prepend_file "Gemfile", "source #{quote(source)}\n", verbose: false
          end
        end
      end

      # Adds a line inside the Application class for <tt>config/application.rb</tt>.
      #
      # If options <tt>:env</tt> is specified, the line is appended to the corresponding
      # file in <tt>config/environments</tt>.
      #
      #   environment do
      #     "config.action_controller.asset_host = 'cdn.provider.com'"
      #   end
      #
      #   environment(nil, env: "development") do
      #     "config.action_controller.asset_host = 'localhost:3000'"
      #   end
      def environment(data=nil, options={})
        sentinel = /class [a-z_:]+ < Rails::Application/i
        env_file_sentinel = /Rails\.application\.configure do/
        data = yield if !data && block_given?

        in_root do
          if options[:env].nil?
            inject_into_file "config/application.rb", "\n    #{data}", after: sentinel, verbose: false
          else
            Array(options[:env]).each do |env|
              inject_into_file "config/environments/#{env}.rb", "\n  #{data}", after: env_file_sentinel, verbose: false
            end
          end
        end
      end
      alias :application :environment

      # Run a command in git.
      #
      #   git :init
      #   git add: "this.file that.rb"
      #   git add: "onefile.rb", rm: "badfile.cxx"
      def git(commands={})
        if commands.is_a?(Symbol)
          run "git #{commands}"
        else
          commands.each do |cmd, options|
            run "git #{cmd} #{options}"
          end
        end
      end

      # Create a new file in the <tt>vendor/</tt> directory. Code can be specified
      # in a block or a data string can be given.
      #
      #   vendor("sekrit.rb") do
      #     sekrit_salt = "#{Time.now}--#{3.years.ago}--#{rand}--"
      #     "salt = '#{sekrit_salt}'"
      #   end
      #
      #   vendor("foreign.rb", "# Foreign code is fun")
      def vendor(filename, data=nil, &block)
        log :vendor, filename
        create_file("vendor/#{filename}", data, verbose: false, &block)
      end

      # Create a new file in the lib/ directory. Code can be specified
      # in a block or a data string can be given.
      #
      #   lib("crypto.rb") do
      #     "crypted_special_value = '#{rand}--#{Time.now}--#{rand(1337)}--'"
      #   end
      #
      #   lib("foreign.rb", "# Foreign code is fun")
      def lib(filename, data=nil, &block)
        log :lib, filename
        create_file("lib/#{filename}", data, verbose: false, &block)
      end

      # Create a new +Rakefile+ with the provided code (either in a block or a string).
      #
      #   rakefile("bootstrap.rake") do
      #     project = ask("What is the UNIX name of your project?")
      #
      #     <<-TASK
      #       namespace :#{project} do
      #         task :bootstrap do
      #           puts "I like boots!"
      #         end
      #       end
      #     TASK
      #   end
      #
      #   rakefile('seed.rake', 'puts "Planting seeds"')
      def rakefile(filename, data=nil, &block)
        log :rakefile, filename
        create_file("lib/tasks/#{filename}", data, verbose: false, &block)
      end

      # Create a new initializer with the provided code (either in a block or a string).
      #
      #   initializer("globals.rb") do
      #     data = ""
      #
      #     ['MY_WORK', 'ADMINS', 'BEST_COMPANY_EVAR'].each do |const|
      #       data << "#{const} = :entp\n"
      #     end
      #
      #     data
      #   end
      #
      #   initializer("api.rb", "API_KEY = '123456'")
      def initializer(filename, data=nil, &block)
        log :initializer, filename
        create_file("config/initializers/#{filename}", data, verbose: false, &block)
      end

      # Generate something using a generator from Rails or a plugin.
      # The second parameter is the argument string that is passed to
      # the generator or an Array that is joined.
      #
      #   generate(:authenticated, "user session")
      def generate(what, *args)
        log :generate, what
        argument = args.flat_map(&:to_s).join(" ")

        in_root { run_ruby_script("bin/rails generate #{what} #{argument}", verbose: false) }
      end

      # Runs the supplied rake task (invoked with 'rake ...')
      #
      #   rake("db:migrate")
      #   rake("db:migrate", env: "production")
      #   rake("gems:install", sudo: true)
      def rake(command, options={})
        execute_command :rake, command, options
      end

      # Runs the supplied rake task (invoked with 'rails ...')
      #
      #   rails("db:migrate")
      #   rails("db:migrate", env: "production")
      #   rails("gems:install", sudo: true)
      def rails_command(command, options={})
        execute_command :rails, command, options
      end

      # Just run the capify command in root
      #
      #   capify!
      def capify!
        log :capify, ""
        in_root { run("#{extify(:capify)} .", verbose: false) }
      end

      # Make an entry in Rails routing file <tt>config/routes.rb</tt>
      #
      #   route "root 'welcome#index'"
      def route(routing_code)
        log :route, routing_code
        sentinel = /\.routes\.draw do\s*\n/m

        in_root do
          inject_into_file "config/routes.rb", "  #{routing_code}\n", after: sentinel, verbose: false, force: false
        end
      end

      # Reads the given file at the source root and prints it in the console.
      #
      #   readme "README"
      def readme(path)
        log File.read(find_in_source_paths(path))
      end

      # Registers a callback to be executed after bundle and spring binstubs
      # have run.
      #
      #   after_bundle do
      #     git add: '.'
      #   end
      def after_bundle(&block)
        @after_bundle_callbacks << block
      end

      protected

        # Define log for backwards compatibility. If just one argument is sent,
        # invoke say, otherwise invoke say_status. Differently from say and
        # similarly to say_status, this method respects the quiet? option given.
        def log(*args)
          if args.size == 1
            say args.first.to_s unless options.quiet?
          else
            args << (self.behavior == :invoke ? :green : :red)
            say_status(*args)
          end
        end

        # Runs the supplied command using either "rake ..." or "rails ..."
        # based on the executor parameter provided.
        def execute_command(executor, command, options={})
          log executor, command
          env  = options[:env] || ENV["RAILS_ENV"] || "development"
          sudo = options[:sudo] && RbConfig::CONFIG["host_os"] !~ /mswin|mingw/ ? "sudo " : ""
          in_root { run("#{sudo}#{extify(executor)} #{command} RAILS_ENV=#{env}", verbose: false) }
        end

        # Add an extension to the given name based on the platform.
        def extify(name)
          if RbConfig::CONFIG["host_os"] =~ /mswin|mingw/
            "#{name}.bat"
          else
            name
          end
        end

        # Surround string with single quotes if there is no quotes.
        # Otherwise fall back to double quotes
        def quote(value)
          return value.inspect unless value.is_a? String

          if value.include?("'")
            value.inspect
          else
            "'#{value}'"
          end
        end
    end
  end
end
require "generators/generators_test_helper"
require "rails/generators/rails/app/app_generator"
require "env_helpers"

class ActionsTest < Rails::Generators::TestCase
  include GeneratorsTestHelper
  include EnvHelpers

  tests Rails::Generators::AppGenerator
  arguments [destination_root]

  def setup
    Rails.application = TestApp::Application
    super
  end

  def teardown
    Rails.application = TestApp::Application.instance
  end

  def test_invoke_other_generator_with_shortcut
    action :invoke, "model", ["my_model"]
    assert_file "app/models/my_model.rb", /MyModel/
  end

  def test_invoke_other_generator_with_full_namespace
    action :invoke, "rails:model", ["my_model"]
    assert_file "app/models/my_model.rb", /MyModel/
  end

  def test_create_file_should_write_data_to_file_path
    action :create_file, "lib/test_file.rb", "heres test data"
    assert_file "lib/test_file.rb", "heres test data"
  end

  def test_create_file_should_write_block_contents_to_file_path
    action(:create_file, "lib/test_file.rb"){ "heres block data" }
    assert_file "lib/test_file.rb", "heres block data"
  end

  def test_add_source_adds_source_to_gemfile
    run_generator
    action :add_source, "http://gems.github.com"
    assert_file "Gemfile", /source 'http:\/\/gems\.github\.com'/
  end

  def test_add_source_with_block_adds_source_to_gemfile_with_gem
    run_generator
    action :add_source, "http://gems.github.com" do
      gem "rspec-rails"
    end
    assert_file "Gemfile", /source 'http:\/\/gems\.github\.com' do\n  gem 'rspec-rails'\nend/
  end

  def test_add_source_with_block_adds_source_to_gemfile_after_gem
    run_generator
    action :gem, "will-paginate"
    action :add_source, "http://gems.github.com" do
      gem "rspec-rails"
    end
    assert_file "Gemfile", /gem 'will-paginate'\nsource 'http:\/\/gems\.github\.com' do\n  gem 'rspec-rails'\nend/
  end

  def test_gem_should_put_gem_dependency_in_gemfile
    run_generator
    action :gem, "will-paginate"
    assert_file "Gemfile", /gem 'will\-paginate'/
  end

  def test_gem_with_version_should_include_version_in_gemfile
    run_generator

    action :gem, "rspec", ">=2.0.0.a5"

    assert_file "Gemfile", /gem 'rspec', '>=2.0.0.a5'/
  end

  def test_gem_should_insert_on_separate_lines
    run_generator

    File.open("Gemfile", "a") {|f| f.write("# Some content...") }

    action :gem, "rspec"
    action :gem, "rspec-rails"

    assert_file "Gemfile", /^gem 'rspec'$/
    assert_file "Gemfile", /^gem 'rspec-rails'$/
  end

  def test_gem_should_include_options
    run_generator

    action :gem, "rspec", github: "dchelimsky/rspec", tag: "1.2.9.rc1"

    assert_file "Gemfile", /gem 'rspec', github: 'dchelimsky\/rspec', tag: '1\.2\.9\.rc1'/
  end

  def test_gem_with_non_string_options
    run_generator

    action :gem, "rspec", require: false
    action :gem, "rspec-rails", group: [:development, :test]

    assert_file "Gemfile", /^gem 'rspec', require: false$/
    assert_file "Gemfile", /^gem 'rspec-rails', group: \[:development, :test\]$/
  end

  def test_gem_falls_back_to_inspect_if_string_contains_single_quote
    run_generator

    action :gem, "rspec", ">=2.0'0"

    assert_file "Gemfile", /^gem 'rspec', ">=2\.0'0"$/
  end

  def test_gem_works_even_if_frozen_string_is_passed_as_argument
    run_generator

    action :gem, "frozen_gem".freeze, "1.0.0".freeze

    assert_file "Gemfile", /^gem 'frozen_gem', '1.0.0'$/
  end

  def test_gem_group_should_wrap_gems_in_a_group
    run_generator

    action :gem_group, :development, :test do
      gem "rspec-rails"
    end

    action :gem_group, :test do
      gem "fakeweb"
    end

    assert_file "Gemfile", /\ngroup :development, :test do\n  gem 'rspec-rails'\nend\n\ngroup :test do\n  gem 'fakeweb'\nend/
  end

  def test_environment_should_include_data_in_environment_initializer_block
    run_generator
    autoload_paths = 'config.autoload_paths += %w["#{Rails.root}/app/extras"]'
    action :environment, autoload_paths
    assert_file "config/application.rb", /  class Application < Rails::Application\n    #{Regexp.escape(autoload_paths)}/
  end

  def test_environment_should_include_data_in_environment_initializer_block_with_env_option
    run_generator
    autoload_paths = 'config.autoload_paths += %w["#{Rails.root}/app/extras"]'
    action :environment, autoload_paths, env: "development"
    assert_file "config/environments/development.rb", /Rails\.application\.configure do\n  #{Regexp.escape(autoload_paths)}/
  end

  def test_environment_with_block_should_include_block_contents_in_environment_initializer_block
    run_generator

    action :environment do
      _ = "# This wont be added"# assignment to silence parse-time warning "unused literal ignored"
      "# This will be added"
    end

    assert_file "config/application.rb" do |content|
      assert_match(/# This will be added/, content)
      assert_no_match(/# This wont be added/, content)
    end
  end

  def test_git_with_symbol_should_run_command_using_git_scm
    assert_called_with(generator, :run, ["git init"]) do
      action :git, :init
    end
  end

  def test_git_with_hash_should_run_each_command_using_git_scm
    assert_called_with(generator, :run, [ ["git rm README"], ["git add ."] ]) do
      action :git, rm: "README", add: "."
    end
  end

  def test_vendor_should_write_data_to_file_in_vendor
    action :vendor, "vendor_file.rb", "# vendor data"
    assert_file "vendor/vendor_file.rb", "# vendor data"
  end

  def test_lib_should_write_data_to_file_in_lib
    action :lib, "my_library.rb", "class MyLibrary"
    assert_file "lib/my_library.rb", "class MyLibrary"
  end

  def test_rakefile_should_write_date_to_file_in_lib_tasks
    action :rakefile, "myapp.rake", "task run: [:environment]"
    assert_file "lib/tasks/myapp.rake", "task run: [:environment]"
  end

  def test_initializer_should_write_date_to_file_in_config_initializers
    action :initializer, "constants.rb", "MY_CONSTANT = 42"
    assert_file "config/initializers/constants.rb", "MY_CONSTANT = 42"
  end

  def test_generate_should_run_script_generate_with_argument_and_options
    assert_called_with(generator, :run_ruby_script, ["bin/rails generate model MyModel", verbose: false]) do
      action :generate, "model", "MyModel"
    end
  end

  def test_rails_should_run_rake_command_with_default_env
    assert_called_with(generator, :run, ["rake log:clear RAILS_ENV=development", verbose: false]) do
      with_rails_env nil do
        action :rake, "log:clear"
      end
    end
  end

  def test_rails_with_env_option_should_run_rake_command_in_env
    assert_called_with(generator, :run, ["rake log:clear RAILS_ENV=production", verbose: false]) do
      action :rake, "log:clear", env: "production"
    end
  end

  test "rails command with RAILS_ENV variable should run rake command in env" do
    assert_called_with(generator, :run, ["rake log:clear RAILS_ENV=production", verbose: false]) do
      with_rails_env "production" do
        action :rake, "log:clear"
      end
    end
  end

  test "env option should win over RAILS_ENV variable when running rake" do
    assert_called_with(generator, :run, ["rake log:clear RAILS_ENV=production", verbose: false]) do
      with_rails_env "staging" do
        action :rake, "log:clear", env: "production"
      end
    end
  end

  test "rails command with sudo option should run rake command with sudo" do
    assert_called_with(generator, :run, ["sudo rake log:clear RAILS_ENV=development", verbose: false]) do
      with_rails_env nil do
        action :rake, "log:clear", sudo: true
      end
    end
  end

  test "rails command should run rails_command with default env" do
    assert_called_with(generator, :run, ["rails log:clear RAILS_ENV=development", verbose: false]) do
      with_rails_env nil do
        action :rails_command, "log:clear"
      end
    end
  end

  test "rails command with env option should run rails_command with same env" do
    assert_called_with(generator, :run, ["rails log:clear RAILS_ENV=production", verbose: false]) do
      action :rails_command, "log:clear", env: "production"
    end
  end

  test "rails command with RAILS_ENV variable should run rails_command in env" do
    assert_called_with(generator, :run, ["rails log:clear RAILS_ENV=production", verbose: false]) do
      with_rails_env "production" do
        action :rails_command, "log:clear"
      end
    end
  end

  def test_env_option_should_win_over_rails_env_variable_when_running_rails
    assert_called_with(generator, :run, ["rails log:clear RAILS_ENV=production", verbose: false]) do
      with_rails_env "staging" do
        action :rails_command, "log:clear", env: "production"
      end
    end
  end

  test "rails command with sudo option should run rails_command with sudo" do
    assert_called_with(generator, :run, ["sudo rails log:clear RAILS_ENV=development", verbose: false]) do
      with_rails_env nil do
        action :rails_command, "log:clear", sudo: true
      end
    end
  end

  def test_capify_should_run_the_capify_command
    assert_called_with(generator, :run, ["capify .", verbose: false]) do
      action :capify!
    end
  end

  def test_route_should_add_data_to_the_routes_block_in_config_routes
    run_generator
    route_command = "route '/login', controller: 'sessions', action: 'new'"
    action :route, route_command
    assert_file "config/routes.rb", /#{Regexp.escape(route_command)}/
  end

  def test_route_should_be_idempotent
    run_generator
    route_path = File.expand_path("config/routes.rb", destination_root)

    # runs first time, not asserting
    action :route, "root 'welcome#index'"
    content_1 = File.read(route_path)

    # runs second time
    action :route, "root 'welcome#index'"
    content_2 = File.read(route_path)

    assert_equal content_1, content_2
  end

  def test_route_should_add_data_with_an_new_line
    run_generator
    action :route, "root 'welcome#index'"
    route_path = File.expand_path("config/routes.rb", destination_root)
    content = File.read(route_path)

    # Remove all of the comments and blank lines from the routes file
    content.gsub!(/^  \#.*\n/, "")
    content.gsub!(/^\n/, "")

    File.open(route_path, "wb") { |file| file.write(content) }

    routes = <<-F
Rails.application.routes.draw do
  root 'welcome#index'
end
F

    assert_file "config/routes.rb", routes

    action :route, "resources :product_lines"

    routes = <<-F
Rails.application.routes.draw do
  resources :product_lines
  root 'welcome#index'
end
F
    assert_file "config/routes.rb", routes
  end

  def test_readme
    run_generator
    assert_called(Rails::Generators::AppGenerator, :source_root, times: 2, returns: destination_root) do
      assert_match "application up and running", action(:readme, "README.md")
    end
  end

  def test_readme_with_quiet
    generator(default_arguments, quiet: true)
    run_generator
    assert_called(Rails::Generators::AppGenerator, :source_root, times: 2, returns: destination_root) do
      assert_no_match "application up and running", action(:readme, "README.md")
    end
  end

  def test_log
    assert_equal("YES\n", action(:log, "YES"))
  end

  def test_log_with_status
    assert_equal("         yes  YES\n", action(:log, :yes, "YES"))
  end

  def test_log_with_quiet
    generator(default_arguments, quiet: true)
    assert_equal("", action(:log, "YES"))
  end

  def test_log_with_status_with_quiet
    generator(default_arguments, quiet: true)
    assert_equal("", action(:log, :yes, "YES"))
  end

  protected

    def action(*args, &block)
      capture(:stdout){ generator.send(*args, &block) }
    end
end
#--
# Copyright (c) 2004-2016 David Heinemeier Hansson
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#++

require "active_support"
require "active_support/rails"
require "action_view/version"

module ActionView
  extend ActiveSupport::Autoload

  ENCODING_FLAG = '#.*coding[:=]\s*(\S+)[ \t]*'

  eager_autoload do
    autoload :Base
    autoload :Context
    autoload :CompiledTemplates, "action_view/context"
    autoload :Digestor
    autoload :Helpers
    autoload :LookupContext
    autoload :Layouts
    autoload :PathSet
    autoload :RecordIdentifier
    autoload :Rendering
    autoload :RoutingUrlFor
    autoload :Template
    autoload :ViewPaths

    autoload_under "renderer" do
      autoload :Renderer
      autoload :AbstractRenderer
      autoload :PartialRenderer
      autoload :TemplateRenderer
      autoload :StreamingTemplateRenderer
    end

    autoload_at "action_view/template/resolver" do
      autoload :Resolver
      autoload :PathResolver
      autoload :OptimizedFileSystemResolver
      autoload :FallbackFileSystemResolver
    end

    autoload_at "action_view/buffers" do
      autoload :OutputBuffer
      autoload :StreamingBuffer
    end

    autoload_at "action_view/flows" do
      autoload :OutputFlow
      autoload :StreamingFlow
    end

    autoload_at "action_view/template/error" do
      autoload :MissingTemplate
      autoload :ActionViewError
      autoload :EncodingError
      autoload :MissingRequestError
      autoload :TemplateError
      autoload :WrongEncodingError
    end
  end

  autoload :TestCase

  def self.eager_load!
    super
    ActionView::Helpers.eager_load!
    ActionView::Template.eager_load!
  end
end

require "active_support/core_ext/string/output_safety"

ActiveSupport.on_load(:i18n) do
  I18n.load_path << "#{File.dirname(__FILE__)}/action_view/locale/en.yml"
end
#--
# Copyright (c) 2014-2016 David Heinemeier Hansson
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#++

require "active_support"
require "active_support/rails"
require "active_job/version"
require "global_id"

module ActiveJob
  extend ActiveSupport::Autoload

  autoload :Base
  autoload :QueueAdapters
  autoload :ConfiguredJob
  autoload :TestCase
  autoload :TestHelper
end
require "active_support/core_ext/module/attribute_accessors"
require "active_support/core_ext/enumerable"

module ActionView
  # = Active Model Helpers
  module Helpers
    module ActiveModelHelper
    end

    module ActiveModelInstanceTag
      def object
        @active_model_object ||= begin
          object = super
          object.respond_to?(:to_model) ? object.to_model : object
        end
      end

      def content_tag(*)
        error_wrapping(super)
      end

      def tag(type, options, *)
        tag_generate_errors?(options) ? error_wrapping(super) : super
      end

      def error_wrapping(html_tag)
        if object_has_errors?
          Base.field_error_proc.call(html_tag, self)
        else
          html_tag
        end
      end

      def error_message
        object.errors[@method_name]
      end

      private

        def object_has_errors?
          object.respond_to?(:errors) && object.errors.respond_to?(:[]) && error_message.present?
        end

        def tag_generate_errors?(options)
          options["type"] != "hidden"
        end
    end
  end
end
require "abstract_unit"

class ActiveModelHelperTest < ActionView::TestCase
  tests ActionView::Helpers::ActiveModelHelper

  silence_warnings do
    class Post < Struct.new(:author_name, :body, :updated_at)
      include ActiveModel::Conversion
      include ActiveModel::Validations

      def persisted?
        false
      end
    end
  end

  def setup
    super

    @post = Post.new
    @post.errors[:author_name] << "can't be empty"
    @post.errors[:body] << "foo"
    @post.errors[:updated_at] << "bar"

    @post.author_name = ""
    @post.body        = "Back to the hill and over it again!"
    @post.updated_at  = Date.new(2004, 6, 15)
  end

  def test_text_area_with_errors
    assert_dom_equal(
      %(<div class="field_with_errors"><textarea id="post_body" name="post[body]">\nBack to the hill and over it again!</textarea></div>),
      text_area("post", "body")
    )
  end

  def test_text_field_with_errors
    assert_dom_equal(
      %(<div class="field_with_errors"><input id="post_author_name" name="post[author_name]" type="text" value="" /></div>),
      text_field("post", "author_name")
    )
  end

  def test_select_with_errors
    assert_dom_equal(
      %(<div class="field_with_errors"><select name="post[author_name]" id="post_author_name"><option value="a">a</option>\n<option value="b">b</option></select></div>),
      select("post", "author_name", [:a, :b])
    )
  end

  def test_select_with_errors_and_blank_option
    expected_dom = %(<div class="field_with_errors"><select name="post[author_name]" id="post_author_name"><option value="">Choose one...</option>\n<option value="a">a</option>\n<option value="b">b</option></select></div>)
    assert_dom_equal(expected_dom, select("post", "author_name", [:a, :b], include_blank: "Choose one..."))
    assert_dom_equal(expected_dom, select("post", "author_name", [:a, :b], prompt: "Choose one..."))
  end

  def test_date_select_with_errors
    assert_dom_equal(
      %(<div class="field_with_errors"><select id="post_updated_at_1i" name="post[updated_at(1i)]">\n<option selected="selected" value="2004">2004</option>\n<option value="2005">2005</option>\n</select>\n<input id="post_updated_at_2i" name="post[updated_at(2i)]" type="hidden" value="6" />\n<input id="post_updated_at_3i" name="post[updated_at(3i)]" type="hidden" value="1" />\n</div>),
      date_select("post", "updated_at", discard_month: true, discard_day: true, start_year: 2004, end_year: 2005)
    )
  end

  def test_datetime_select_with_errors
    assert_dom_equal(
      %(<div class="field_with_errors"><input id="post_updated_at_1i" name="post[updated_at(1i)]" type="hidden" value="2004" />\n<input id="post_updated_at_2i" name="post[updated_at(2i)]" type="hidden" value="6" />\n<input id="post_updated_at_3i" name="post[updated_at(3i)]" type="hidden" value="1" />\n<select id="post_updated_at_4i" name="post[updated_at(4i)]">\n<option selected="selected" value="00">00</option>\n<option value="01">01</option>\n<option value="02">02</option>\n<option value="03">03</option>\n<option value="04">04</option>\n<option value="05">05</option>\n<option value="06">06</option>\n<option value="07">07</option>\n<option value="08">08</option>\n<option value="09">09</option>\n<option value="10">10</option>\n<option value="11">11</option>\n<option value="12">12</option>\n<option value="13">13</option>\n<option value="14">14</option>\n<option value="15">15</option>\n<option value="16">16</option>\n<option value="17">17</option>\n<option value="18">18</option>\n<option value="19">19</option>\n<option value="20">20</option>\n<option value="21">21</option>\n<option value="22">22</option>\n<option value="23">23</option>\n</select>\n : <select id="post_updated_at_5i" name="post[updated_at(5i)]">\n<option selected="selected" value="00">00</option>\n</select>\n</div>),
      datetime_select("post", "updated_at", discard_year: true, discard_month: true, discard_day: true, minute_step: 60)
    )
  end

  def test_time_select_with_errors
    assert_dom_equal(
      %(<div class="field_with_errors"><input id="post_updated_at_1i" name="post[updated_at(1i)]" type="hidden" value="2004" />\n<input id="post_updated_at_2i" name="post[updated_at(2i)]" type="hidden" value="6" />\n<input id="post_updated_at_3i" name="post[updated_at(3i)]" type="hidden" value="15" />\n<select id="post_updated_at_4i" name="post[updated_at(4i)]">\n<option selected="selected" value="00">00</option>\n<option value="01">01</option>\n<option value="02">02</option>\n<option value="03">03</option>\n<option value="04">04</option>\n<option value="05">05</option>\n<option value="06">06</option>\n<option value="07">07</option>\n<option value="08">08</option>\n<option value="09">09</option>\n<option value="10">10</option>\n<option value="11">11</option>\n<option value="12">12</option>\n<option value="13">13</option>\n<option value="14">14</option>\n<option value="15">15</option>\n<option value="16">16</option>\n<option value="17">17</option>\n<option value="18">18</option>\n<option value="19">19</option>\n<option value="20">20</option>\n<option value="21">21</option>\n<option value="22">22</option>\n<option value="23">23</option>\n</select>\n : <select id="post_updated_at_5i" name="post[updated_at(5i)]">\n<option selected="selected" value="00">00</option>\n</select>\n</div>),
      time_select("post", "updated_at", minute_step: 60)
    )
  end

  def test_hidden_field_does_not_render_errors
    assert_dom_equal(
      %(<input id="post_author_name" name="post[author_name]" type="hidden" value="" />),
      hidden_field("post", "author_name")
    )
  end

  def test_field_error_proc
    old_proc = ActionView::Base.field_error_proc
    ActionView::Base.field_error_proc = Proc.new do |html_tag, instance|
      raw(%(<div class=\"field_with_errors\">#{html_tag} <span class="error">#{[instance.error_message].join(', ')}</span></div>))
    end

    assert_dom_equal(
      %(<div class="field_with_errors"><input id="post_author_name" name="post[author_name]" type="text" value="" /> <span class="error">can't be empty</span></div>),
      text_field("post", "author_name")
    )
  ensure
    ActionView::Base.field_error_proc = old_proc if old_proc
  end
end
#--
# Copyright (c) 2004-2016 David Heinemeier Hansson
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#++

require "active_support"
require "active_support/rails"
require "active_model/version"

module ActiveModel
  extend ActiveSupport::Autoload

  autoload :AttributeAssignment
  autoload :AttributeMethods
  autoload :BlockValidator, "active_model/validator"
  autoload :Callbacks
  autoload :Conversion
  autoload :Dirty
  autoload :EachValidator, "active_model/validator"
  autoload :ForbiddenAttributesProtection
  autoload :Lint
  autoload :Model
  autoload :Name, "active_model/naming"
  autoload :Naming
  autoload :SecurePassword
  autoload :Serialization
  autoload :TestCase
  autoload :Translation
  autoload :Validations
  autoload :Validator

  eager_autoload do
    autoload :Errors
    autoload :RangeError, "active_model/errors"
    autoload :StrictValidationFailed, "active_model/errors"
    autoload :UnknownAttributeError, "active_model/errors"
  end

  module Serializers
    extend ActiveSupport::Autoload

    eager_autoload do
      autoload :JSON
    end
  end

  def self.eager_load!
    super
    ActiveModel::Serializers.eager_load!
  end
end

ActiveSupport.on_load(:i18n) do
  I18n.load_path << File.dirname(__FILE__) + "/active_model/locale/en.yml"
end
module ActionCable
  module Server
    class Worker
      module ActiveRecordConnectionManagement
        extend ActiveSupport::Concern

        included do
          if defined?(ActiveRecord::Base)
            set_callback :work, :around, :with_database_connections
          end
        end

        def with_database_connections
          connection.logger.tag(ActiveRecord::Base.logger) { yield }
        end
      end
    end
  end
end
begin
  require "bundler/inline"
rescue LoadError => e
  $stderr.puts "Bundler version 1.10 or later is required. Please update your Bundler"
  raise e
end

gemfile(true) do
  source "https://rubygems.org"
  # Activate the gem you are reporting the issue against.
  gem "activerecord", "5.0.0"
  gem "sqlite3"
end

require "active_record"
require "minitest/autorun"
require "logger"

# Ensure backward compatibility with Minitest 4
Minitest::Test = MiniTest::Unit::TestCase unless defined?(Minitest::Test)

# This connection will do for database-independent bug reports.
ActiveRecord::Base.establish_connection(adapter: "sqlite3", database: ":memory:")
ActiveRecord::Base.logger = Logger.new(STDOUT)

ActiveRecord::Schema.define do
  create_table :posts, force: true do |t|
  end

  create_table :comments, force: true do |t|
    t.integer :post_id
  end
end

class Post < ActiveRecord::Base
  has_many :comments
end

class Comment < ActiveRecord::Base
  belongs_to :post
end

class BugTest < Minitest::Test
  def test_association_stuff
    post = Post.create!
    post.comments << Comment.create!

    assert_equal 1, post.comments.count
    assert_equal 1, Comment.count
    assert_equal post.id, Comment.first.post.id
  end
end
begin
  require "bundler/inline"
rescue LoadError => e
  $stderr.puts "Bundler version 1.10 or later is required. Please update your Bundler"
  raise e
end

gemfile(true) do
  source "https://rubygems.org"
  gem "rails", github: "rails/rails"
  gem "sqlite3"
end

require "active_record"
require "minitest/autorun"
require "logger"

# This connection will do for database-independent bug reports.
ActiveRecord::Base.establish_connection(adapter: "sqlite3", database: ":memory:")
ActiveRecord::Base.logger = Logger.new(STDOUT)

ActiveRecord::Schema.define do
  create_table :posts, force: true do |t|
  end

  create_table :comments, force: true do |t|
    t.integer :post_id
  end
end

class Post < ActiveRecord::Base
  has_many :comments
end

class Comment < ActiveRecord::Base
  belongs_to :post
end

class BugTest < Minitest::Test
  def test_association_stuff
    post = Post.create!
    post.comments << Comment.create!

    assert_equal 1, post.comments.count
    assert_equal 1, Comment.count
    assert_equal post.id, Comment.first.post.id
  end
end
#--
# Copyright (c) 2004-2016 David Heinemeier Hansson
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#++

require "active_support"
require "active_support/rails"
require "active_model"
require "arel"

require "active_record/version"
require "active_record/attribute_set"

module ActiveRecord
  extend ActiveSupport::Autoload

  autoload :Attribute
  autoload :Base
  autoload :Callbacks
  autoload :Core
  autoload :ConnectionHandling
  autoload :CounterCache
  autoload :DynamicMatchers
  autoload :Enum
  autoload :InternalMetadata
  autoload :Explain
  autoload :Inheritance
  autoload :Integration
  autoload :LegacyYamlAdapter
  autoload :Migration
  autoload :Migrator, "active_record/migration"
  autoload :ModelSchema
  autoload :NestedAttributes
  autoload :NoTouching
  autoload :TouchLater
  autoload :Persistence
  autoload :QueryCache
  autoload :Querying
  autoload :CollectionCacheKey
  autoload :ReadonlyAttributes
  autoload :RecordInvalid, "active_record/validations"
  autoload :Reflection
  autoload :RuntimeRegistry
  autoload :Sanitization
  autoload :Schema
  autoload :SchemaDumper
  autoload :SchemaMigration
  autoload :Scoping
  autoload :Serialization
  autoload :StatementCache
  autoload :Store
  autoload :Suppressor
  autoload :TableMetadata
  autoload :Timestamp
  autoload :Transactions
  autoload :Translation
  autoload :Validations
  autoload :SecureToken

  eager_autoload do
    autoload :ActiveRecordError, "active_record/errors"
    autoload :ConnectionNotEstablished, "active_record/errors"
    autoload :ConnectionAdapters, "active_record/connection_adapters/abstract_adapter"

    autoload :Aggregations
    autoload :Associations
    autoload :AttributeAssignment
    autoload :AttributeMethods
    autoload :AutosaveAssociation

    autoload :Relation
    autoload :AssociationRelation
    autoload :NullRelation

    autoload_under "relation" do
      autoload :QueryMethods
      autoload :FinderMethods
      autoload :Calculations
      autoload :PredicateBuilder
      autoload :SpawnMethods
      autoload :Batches
      autoload :Delegation
    end

    autoload :Result
  end

  module Coders
    autoload :YAMLColumn, "active_record/coders/yaml_column"
    autoload :JSON, "active_record/coders/json"
  end

  module AttributeMethods
    extend ActiveSupport::Autoload

    eager_autoload do
      autoload :BeforeTypeCast
      autoload :Dirty
      autoload :PrimaryKey
      autoload :Query
      autoload :Read
      autoload :TimeZoneConversion
      autoload :Write
      autoload :Serialization
    end
  end

  module Locking
    extend ActiveSupport::Autoload

    eager_autoload do
      autoload :Optimistic
      autoload :Pessimistic
    end
  end

  module ConnectionAdapters
    extend ActiveSupport::Autoload

    eager_autoload do
      autoload :AbstractAdapter
    end
  end

  module Scoping
    extend ActiveSupport::Autoload

    eager_autoload do
      autoload :Named
      autoload :Default
    end
  end

  module Tasks
    extend ActiveSupport::Autoload

    autoload :DatabaseTasks
    autoload :SQLiteDatabaseTasks, "active_record/tasks/sqlite_database_tasks"
    autoload :MySQLDatabaseTasks,  "active_record/tasks/mysql_database_tasks"
    autoload :PostgreSQLDatabaseTasks,
      "active_record/tasks/postgresql_database_tasks"
  end

  autoload :TestFixtures, "active_record/fixtures"

  def self.eager_load!
    super
    ActiveRecord::Locking.eager_load!
    ActiveRecord::Scoping.eager_load!
    ActiveRecord::Associations.eager_load!
    ActiveRecord::AttributeMethods.eager_load!
    ActiveRecord::ConnectionAdapters.eager_load!
  end
end

ActiveSupport.on_load(:active_record) do
  Arel::Table.engine = self
end

ActiveSupport.on_load(:i18n) do
  I18n.load_path << File.dirname(__FILE__) + "/active_record/locale/en.yml"
end
require "abstract_unit"

# Define the essentials
class ActiveRecordTestConnector
  cattr_accessor :able_to_connect
  cattr_accessor :connected

  # Set our defaults
  self.connected = false
  self.able_to_connect = true
end

# Try to grab AR
unless defined?(ActiveRecord) && defined?(FixtureSet)
  begin
    PATH_TO_AR = "#{File.dirname(__FILE__)}/../../activerecord/lib"
    raise LoadError, "#{PATH_TO_AR} doesn't exist" unless File.directory?(PATH_TO_AR)
    $LOAD_PATH.unshift PATH_TO_AR
    require "active_record"
  rescue LoadError => e
    $stderr.print "Failed to load Active Record. Skipping Active Record assertion tests: #{e}"
    ActiveRecordTestConnector.able_to_connect = false
  end
end
$stderr.flush

# Define the rest of the connector
class ActiveRecordTestConnector
  class << self
    def setup
      unless connected || !able_to_connect
        setup_connection
        load_schema
        require_fixture_models
        self.connected = true
      end
    rescue Exception => e  # errors from ActiveRecord setup
      $stderr.puts "\nSkipping ActiveRecord assertion tests: #{e}"
      #$stderr.puts "  #{e.backtrace.join("\n  ")}\n"
      self.able_to_connect = false
    end

    private
      def setup_connection
        if Object.const_defined?(:ActiveRecord)
          defaults = { database: ":memory:" }
          adapter = defined?(JRUBY_VERSION) ? "jdbcsqlite3" : "sqlite3"
          options = defaults.merge adapter: adapter, timeout: 500
          ActiveRecord::Base.establish_connection(options)
          ActiveRecord::Base.configurations = { "sqlite3_ar_integration" => options }
          ActiveRecord::Base.connection

          Object.send(:const_set, :QUOTED_TYPE, ActiveRecord::Base.connection.quote_column_name("type")) unless Object.const_defined?(:QUOTED_TYPE)
        else
          raise "Can't setup connection since ActiveRecord isn't loaded."
        end
      end

      # Load actionpack sqlite3 tables
      def load_schema
        File.read(File.dirname(__FILE__) + "/fixtures/db_definitions/sqlite.sql").split(";").each do |sql|
          ActiveRecord::Base.connection.execute(sql) unless sql.blank?
        end
      end

      def require_fixture_models
        Dir.glob(File.dirname(__FILE__) + "/fixtures/*.rb").each {|f| require f}
      end
  end
end

class ActiveRecordTestCase < ActionController::TestCase
  include ActiveRecord::TestFixtures

  # Set our fixture path
  if ActiveRecordTestConnector.able_to_connect
    self.fixture_path = [FIXTURE_LOAD_PATH]
    self.use_transactional_tests = false
  end

  def self.fixtures(*args)
    super if ActiveRecordTestConnector.connected
  end

  def run(*args)
    super if ActiveRecordTestConnector.connected
  end
end

ActiveRecordTestConnector.setup
require "cases/helper"

class PostgresqlActiveSchemaTest < ActiveRecord::PostgreSQLTestCase
  def setup
    ActiveRecord::ConnectionAdapters::PostgreSQLAdapter.class_eval do
      def execute(sql, name = nil) sql end
    end
  end

  teardown do
    ActiveRecord::ConnectionAdapters::PostgreSQLAdapter.class_eval do
      remove_method :execute
    end
  end

  def test_create_database_with_encoding
    assert_equal %(CREATE DATABASE "matt" ENCODING = 'utf8'), create_database(:matt)
    assert_equal %(CREATE DATABASE "aimonetti" ENCODING = 'latin1'), create_database(:aimonetti, encoding: :latin1)
    assert_equal %(CREATE DATABASE "aimonetti" ENCODING = 'latin1'), create_database(:aimonetti, "encoding" => :latin1)
  end

  def test_create_database_with_collation_and_ctype
    assert_equal %(CREATE DATABASE "aimonetti" ENCODING = 'UTF8' LC_COLLATE = 'ja_JP.UTF8' LC_CTYPE = 'ja_JP.UTF8'), create_database(:aimonetti, encoding: :"UTF8", collation: :"ja_JP.UTF8", ctype: :"ja_JP.UTF8")
  end

  def test_add_index
    # add_index calls index_name_exists? which can't work since execute is stubbed
    ActiveRecord::ConnectionAdapters::PostgreSQLAdapter.send(:define_method, :index_name_exists?) { |*| false }

    expected = %(CREATE UNIQUE INDEX  "index_people_on_last_name" ON "people"  ("last_name") WHERE state = 'active')
    assert_equal expected, add_index(:people, :last_name, unique: true, where: "state = 'active'")

    expected = %(CREATE UNIQUE INDEX  "index_people_on_lower_last_name" ON "people"  (lower(last_name)))
    assert_equal expected, add_index(:people, "lower(last_name)", unique: true)

    expected = %(CREATE UNIQUE INDEX  "index_people_on_last_name_varchar_pattern_ops" ON "people"  (last_name varchar_pattern_ops))
    assert_equal expected, add_index(:people, "last_name varchar_pattern_ops", unique: true)

    expected = %(CREATE  INDEX CONCURRENTLY "index_people_on_last_name" ON "people"  ("last_name"))
    assert_equal expected, add_index(:people, :last_name, algorithm: :concurrently)

    %w(gin gist hash btree).each do |type|
      expected = %(CREATE  INDEX  "index_people_on_last_name" ON "people" USING #{type} ("last_name"))
      assert_equal expected, add_index(:people, :last_name, using: type)

      expected = %(CREATE  INDEX CONCURRENTLY "index_people_on_last_name" ON "people" USING #{type} ("last_name"))
      assert_equal expected, add_index(:people, :last_name, using: type, algorithm: :concurrently)

      expected = %(CREATE UNIQUE INDEX  "index_people_on_last_name" ON "people" USING #{type} ("last_name") WHERE state = 'active')
      assert_equal expected, add_index(:people, :last_name, using: type, unique: true, where: "state = 'active'")

      expected = %(CREATE UNIQUE INDEX  "index_people_on_lower_last_name" ON "people" USING #{type} (lower(last_name)))
      assert_equal expected, add_index(:people, "lower(last_name)", using: type, unique: true)
    end

    assert_raise ArgumentError do
      add_index(:people, :last_name, algorithm: :copy)
    end

    ActiveRecord::ConnectionAdapters::PostgreSQLAdapter.send :remove_method, :index_name_exists?
  end

  def test_remove_index
    # remove_index calls index_name_for_remove which can't work since execute is stubbed
    ActiveRecord::ConnectionAdapters::PostgreSQLAdapter.send(:define_method, :index_name_for_remove) do |*|
      "index_people_on_last_name"
    end

    expected = %(DROP INDEX CONCURRENTLY "index_people_on_last_name")
    assert_equal expected, remove_index(:people, name: "index_people_on_last_name", algorithm: :concurrently)

    assert_raise ArgumentError do
      add_index(:people, :last_name, algorithm: :copy)
    end

    ActiveRecord::ConnectionAdapters::PostgreSQLAdapter.send :remove_method, :index_name_for_remove
  end

  def test_remove_index_when_name_is_specified
    expected = %(DROP INDEX CONCURRENTLY "index_people_on_last_name")
    assert_equal expected, remove_index(:people, name: "index_people_on_last_name", algorithm: :concurrently)
  end

  private
    def method_missing(method_symbol, *arguments)
      ActiveRecord::Base.connection.send(method_symbol, *arguments)
    end
end
#--
# Copyright (c) 2005-2016 David Heinemeier Hansson
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#++

require "securerandom"
require "active_support/dependencies/autoload"
require "active_support/version"
require "active_support/logger"
require "active_support/lazy_load_hooks"
require "active_support/core_ext/date_and_time/compatibility"

module ActiveSupport
  extend ActiveSupport::Autoload

  autoload :Concern
  autoload :Dependencies
  autoload :DescendantsTracker
  autoload :ExecutionWrapper
  autoload :Executor
  autoload :FileUpdateChecker
  autoload :EventedFileUpdateChecker
  autoload :LogSubscriber
  autoload :Notifications
  autoload :Reloader

  eager_autoload do
    autoload :BacktraceCleaner
    autoload :ProxyObject
    autoload :Benchmarkable
    autoload :Cache
    autoload :Callbacks
    autoload :Configurable
    autoload :Deprecation
    autoload :Gzip
    autoload :Inflector
    autoload :JSON
    autoload :KeyGenerator
    autoload :MessageEncryptor
    autoload :MessageVerifier
    autoload :Multibyte
    autoload :NumberHelper
    autoload :OptionMerger
    autoload :OrderedHash
    autoload :OrderedOptions
    autoload :StringInquirer
    autoload :TaggedLogging
    autoload :XmlMini
    autoload :ArrayInquirer
  end

  autoload :Rescuable
  autoload :SafeBuffer, "active_support/core_ext/string/output_safety"
  autoload :TestCase

  def self.eager_load!
    super

    NumberHelper.eager_load!
  end

  cattr_accessor :test_order # :nodoc:

  def self.halt_callback_chains_on_return_false
    Callbacks.halt_and_display_warning_on_return_false
  end

  def self.halt_callback_chains_on_return_false=(value)
    Callbacks.halt_and_display_warning_on_return_false = value
  end

  def self.to_time_preserves_timezone
    DateAndTime::Compatibility.preserve_timezone
  end

  def self.to_time_preserves_timezone=(value)
    DateAndTime::Compatibility.preserve_timezone = value
  end
end

autoload :I18n, "active_support/i18n"
require "active_support/core_ext/object/acts_like"

class Time
  # Duck-types as a Time-like class. See Object#acts_like?.
  def acts_like_time?
    true
  end
end
require "abstract_unit"
require "active_support/core_ext/object"

class ObjectTests < ActiveSupport::TestCase
  class DuckTime
    def acts_like_time?
      true
    end
  end

  def test_duck_typing
    object = Object.new
    time   = Time.now
    date   = Date.today
    dt     = DateTime.new
    duck   = DuckTime.new

    assert !object.acts_like?(:time)
    assert !object.acts_like?(:date)

    assert time.acts_like?(:time)
    assert !time.acts_like?(:date)

    assert !date.acts_like?(:time)
    assert date.acts_like?(:date)

    assert dt.acts_like?(:time)
    assert dt.acts_like?(:date)

    assert duck.acts_like?(:time)
    assert !duck.acts_like?(:date)
  end
end
require "cases/helper"

module ActiveRecord
  module ConnectionAdapters
    class AdapterLeasingTest < ActiveRecord::TestCase
      class Pool < ConnectionPool
        def insert_connection_for_test!(c)
          synchronize do
            adopt_connection(c)
            @available.add c
          end
        end
      end

      def setup
        @adapter = AbstractAdapter.new nil, nil
      end

      def test_in_use?
        assert_not @adapter.in_use?, "adapter is not in use"
        assert @adapter.lease, "lease adapter"
        assert @adapter.in_use?, "adapter is in use"
      end

      def test_lease_twice
        assert @adapter.lease, "should lease adapter"
        assert_raises(ActiveRecordError) do
          @adapter.lease
        end
      end

      def test_expire_mutates_in_use
        assert @adapter.lease, "lease adapter"
        assert @adapter.in_use?, "adapter is in use"
        @adapter.expire
        assert_not @adapter.in_use?, "adapter is in use"
      end

      def test_close
        pool = Pool.new(ConnectionSpecification.new("primary", {}, nil))
        pool.insert_connection_for_test! @adapter
        @adapter.pool = pool

        # Make sure the pool marks the connection in use
        assert_equal @adapter, pool.connection
        assert @adapter.in_use?

        # Close should put the adapter back in the pool
        @adapter.close
        assert_not @adapter.in_use?

        assert_equal @adapter, pool.connection
      end
    end
  end
end
require "active_model/type/registry"

module ActiveRecord
  # :stopdoc:
  module Type
    class AdapterSpecificRegistry < ActiveModel::Type::Registry
      def add_modifier(options, klass, **args)
        registrations << DecorationRegistration.new(options, klass, **args)
      end

      private

        def registration_klass
          Registration
        end

        def find_registration(symbol, *args)
          registrations
            .select { |registration| registration.matches?(symbol, *args) }
            .max
        end
    end

    class Registration
      def initialize(name, block, adapter: nil, override: nil)
        @name = name
        @block = block
        @adapter = adapter
        @override = override
      end

      def call(_registry, *args, adapter: nil, **kwargs)
        if kwargs.any? # https://bugs.ruby-lang.org/issues/10856
          block.call(*args, **kwargs)
        else
          block.call(*args)
        end
      end

      def matches?(type_name, *args, **kwargs)
        type_name == name && matches_adapter?(**kwargs)
      end

      def <=>(other)
        if conflicts_with?(other)
          raise TypeConflictError.new("Type #{name} was registered for all
                                      adapters, but shadows a native type with
                                      the same name for #{other.adapter}".squish)
        end
        priority <=> other.priority
      end

      protected

        attr_reader :name, :block, :adapter, :override

        def priority
          result = 0
          if adapter
            result |= 1
          end
          if override
            result |= 2
          end
          result
        end

        def priority_except_adapter
          priority & 0b111111100
        end

      private

        def matches_adapter?(adapter: nil, **)
          (self.adapter.nil? || adapter == self.adapter)
        end

        def conflicts_with?(other)
          same_priority_except_adapter?(other) &&
            has_adapter_conflict?(other)
        end

        def same_priority_except_adapter?(other)
          priority_except_adapter == other.priority_except_adapter
        end

        def has_adapter_conflict?(other)
          (override.nil? && other.adapter) ||
            (adapter && other.override.nil?)
        end
    end

    class DecorationRegistration < Registration
      def initialize(options, klass, adapter: nil)
        @options = options
        @klass = klass
        @adapter = adapter
      end

      def call(registry, *args, **kwargs)
        subtype = registry.lookup(*args, **kwargs.except(*options.keys))
        klass.new(subtype)
      end

      def matches?(*args, **kwargs)
        matches_adapter?(**kwargs) && matches_options?(**kwargs)
      end

      def priority
        super | 4
      end

      protected

        attr_reader :options, :klass

      private

        def matches_options?(**kwargs)
          options.all? do |key, value|
            kwargs[key] == value
          end
        end
    end
  end

  class TypeConflictError < StandardError
  end
  # :startdoc:
end
require "cases/helper"

module ActiveRecord
  class AdapterSpecificRegistryTest < ActiveRecord::TestCase
    test "a class can be registered for a symbol" do
      registry = Type::AdapterSpecificRegistry.new
      registry.register(:foo, ::String)
      registry.register(:bar, ::Array)

      assert_equal "", registry.lookup(:foo)
      assert_equal [], registry.lookup(:bar)
    end

    test "a block can be registered" do
      registry = Type::AdapterSpecificRegistry.new
      registry.register(:foo) do |*args|
        [*args, "block for foo"]
      end
      registry.register(:bar) do |*args|
        [*args, "block for bar"]
      end

      assert_equal [:foo, 1, "block for foo"], registry.lookup(:foo, 1)
      assert_equal [:foo, 2, "block for foo"], registry.lookup(:foo, 2)
      assert_equal [:bar, 1, 2, 3, "block for bar"], registry.lookup(:bar, 1, 2, 3)
    end

    test "filtering by adapter" do
      registry = Type::AdapterSpecificRegistry.new
      registry.register(:foo, String, adapter: :sqlite3)
      registry.register(:foo, Array, adapter: :postgresql)

      assert_equal "", registry.lookup(:foo, adapter: :sqlite3)
      assert_equal [], registry.lookup(:foo, adapter: :postgresql)
    end

    test "an error is raised if both a generic and adapter specific type match" do
      registry = Type::AdapterSpecificRegistry.new
      registry.register(:foo, String)
      registry.register(:foo, Array, adapter: :postgresql)

      assert_raises TypeConflictError do
        registry.lookup(:foo, adapter: :postgresql)
      end
      assert_equal "", registry.lookup(:foo, adapter: :sqlite3)
    end

    test "a generic type can explicitly override an adapter specific type" do
      registry = Type::AdapterSpecificRegistry.new
      registry.register(:foo, String, override: true)
      registry.register(:foo, Array, adapter: :postgresql)

      assert_equal "", registry.lookup(:foo, adapter: :postgresql)
      assert_equal "", registry.lookup(:foo, adapter: :sqlite3)
    end

    test "a generic type can explicitly allow an adapter type to be used instead" do
      registry = Type::AdapterSpecificRegistry.new
      registry.register(:foo, String, override: false)
      registry.register(:foo, Array, adapter: :postgresql)

      assert_equal [], registry.lookup(:foo, adapter: :postgresql)
      assert_equal "", registry.lookup(:foo, adapter: :sqlite3)
    end

    test "a reasonable error is given when no type is found" do
      registry = Type::AdapterSpecificRegistry.new

      e = assert_raises(ArgumentError) do
        registry.lookup(:foo)
      end

      assert_equal "Unknown type :foo", e.message
    end

    test "construct args are passed to the type" do
      type = Struct.new(:args)
      registry = Type::AdapterSpecificRegistry.new
      registry.register(:foo, type)

      assert_equal type.new, registry.lookup(:foo)
      assert_equal type.new(:ordered_arg), registry.lookup(:foo, :ordered_arg)
      assert_equal type.new(keyword: :arg), registry.lookup(:foo, keyword: :arg)
      assert_equal type.new(keyword: :arg), registry.lookup(:foo, keyword: :arg, adapter: :postgresql)
    end

    test "registering a modifier" do
      decoration = Struct.new(:value)
      registry = Type::AdapterSpecificRegistry.new
      registry.register(:foo, String)
      registry.register(:bar, Hash)
      registry.add_modifier({ array: true }, decoration)

      assert_equal decoration.new(""), registry.lookup(:foo, array: true)
      assert_equal decoration.new({}), registry.lookup(:bar, array: true)
      assert_equal "", registry.lookup(:foo)
    end

    test "registering multiple modifiers" do
      decoration = Struct.new(:value)
      other_decoration = Struct.new(:value)
      registry = Type::AdapterSpecificRegistry.new
      registry.register(:foo, String)
      registry.add_modifier({ array: true }, decoration)
      registry.add_modifier({ range: true }, other_decoration)

      assert_equal "", registry.lookup(:foo)
      assert_equal decoration.new(""), registry.lookup(:foo, array: true)
      assert_equal other_decoration.new(""), registry.lookup(:foo, range: true)
      assert_equal(
        decoration.new(other_decoration.new("")),
        registry.lookup(:foo, array: true, range: true)
      )
    end

    test "registering adapter specific modifiers" do
      decoration = Struct.new(:value)
      type = Struct.new(:args)
      registry = Type::AdapterSpecificRegistry.new
      registry.register(:foo, type)
      registry.add_modifier({ array: true }, decoration, adapter: :postgresql)

      assert_equal(
        decoration.new(type.new(keyword: :arg)),
        registry.lookup(:foo, array: true, adapter: :postgresql, keyword: :arg)
      )
      assert_equal(
        type.new(array: true),
        registry.lookup(:foo, array: true, adapter: :sqlite3)
      )
    end
  end
end
require "cases/helper"
require "models/book"
require "models/post"
require "models/author"
require "models/event"

module ActiveRecord
  class AdapterTest < ActiveRecord::TestCase
    def setup
      @connection = ActiveRecord::Base.connection
    end

    ##
    # PostgreSQL does not support null bytes in strings
    unless current_adapter?(:PostgreSQLAdapter) ||
        (current_adapter?(:SQLite3Adapter) && !ActiveRecord::Base.connection.prepared_statements)
      def test_update_prepared_statement
        b = Book.create(name: "my \x00 book")
        b.reload
        assert_equal "my \x00 book", b.name
        b.update_attributes(name: "my other \x00 book")
        b.reload
        assert_equal "my other \x00 book", b.name
      end
    end

    def test_create_record_with_pk_as_zero
      Book.create(id: 0)
      assert_equal 0, Book.find(0).id
      assert_nothing_raised { Book.destroy(0) }
    end

    def test_tables
      tables = nil
      ActiveSupport::Deprecation.silence { tables = @connection.tables }
      assert tables.include?("accounts")
      assert tables.include?("authors")
      assert tables.include?("tasks")
      assert tables.include?("topics")
    end

    def test_table_exists?
      ActiveSupport::Deprecation.silence do
        assert @connection.table_exists?("accounts")
        assert !@connection.table_exists?("nonexistingtable")
        assert !@connection.table_exists?(nil)
      end
    end

    def test_table_exists_checking_both_tables_and_views_is_deprecated
      assert_deprecated { @connection.table_exists?("accounts") }
    end

    def test_data_sources
      data_sources = @connection.data_sources
      assert data_sources.include?("accounts")
      assert data_sources.include?("authors")
      assert data_sources.include?("tasks")
      assert data_sources.include?("topics")
    end

    def test_data_source_exists?
      assert @connection.data_source_exists?("accounts")
      assert @connection.data_source_exists?(:accounts)
      assert_not @connection.data_source_exists?("nonexistingtable")
      assert_not @connection.data_source_exists?(nil)
    end

    def test_indexes
      idx_name = "accounts_idx"

      if @connection.respond_to?(:indexes)
        indexes = @connection.indexes("accounts")
        assert indexes.empty?

        @connection.add_index :accounts, :firm_id, name: idx_name
        indexes = @connection.indexes("accounts")
        assert_equal "accounts", indexes.first.table
        assert_equal idx_name, indexes.first.name
        assert !indexes.first.unique
        assert_equal ["firm_id"], indexes.first.columns
      else
        warn "#{@connection.class} does not respond to #indexes"
      end

    ensure
      @connection.remove_index(:accounts, name: idx_name) rescue nil
    end

    def test_remove_index_when_name_and_wrong_column_name_specified
      index_name = "accounts_idx"

      @connection.add_index :accounts, :firm_id, name: index_name
      assert_raises ArgumentError do
        @connection.remove_index :accounts, name: index_name, column: :wrong_column_name
      end
    ensure
      @connection.remove_index(:accounts, name: index_name)
    end

    def test_current_database
      if @connection.respond_to?(:current_database)
        assert_equal ARTest.connection_config["arunit"]["database"], @connection.current_database
      end
    end

    if current_adapter?(:Mysql2Adapter)
      def test_charset
        assert_not_nil @connection.charset
        assert_not_equal "character_set_database", @connection.charset
        assert_equal @connection.show_variable("character_set_database"), @connection.charset
      end

      def test_collation
        assert_not_nil @connection.collation
        assert_not_equal "collation_database", @connection.collation
        assert_equal @connection.show_variable("collation_database"), @connection.collation
      end

      def test_show_nonexistent_variable_returns_nil
        assert_nil @connection.show_variable("foo_bar_baz")
      end

      def test_not_specifying_database_name_for_cross_database_selects
        begin
          assert_nothing_raised do
            ActiveRecord::Base.establish_connection(ActiveRecord::Base.configurations["arunit"].except(:database))

            config = ARTest.connection_config
            ActiveRecord::Base.connection.execute(
              "SELECT #{config['arunit']['database']}.pirates.*, #{config['arunit2']['database']}.courses.* " \
              "FROM #{config['arunit']['database']}.pirates, #{config['arunit2']['database']}.courses"
            )
          end
        ensure
          ActiveRecord::Base.establish_connection :arunit
        end
      end
    end

    def test_table_alias
      def @connection.test_table_alias_length() 10; end
      class << @connection
        alias_method :old_table_alias_length, :table_alias_length
        alias_method :table_alias_length,     :test_table_alias_length
      end

      assert_equal "posts",      @connection.table_alias_for("posts")
      assert_equal "posts_comm", @connection.table_alias_for("posts_comments")
      assert_equal "dbo_posts",  @connection.table_alias_for("dbo.posts")

      class << @connection
        remove_method :table_alias_length
        alias_method :table_alias_length, :old_table_alias_length
      end
    end

    # test resetting sequences in odd tables in PostgreSQL
    if ActiveRecord::Base.connection.respond_to?(:reset_pk_sequence!)
      require "models/movie"
      require "models/subscriber"

      def test_reset_empty_table_with_custom_pk
        Movie.delete_all
        Movie.connection.reset_pk_sequence! "movies"
        assert_equal 1, Movie.create(name: "fight club").id
      end

      def test_reset_table_with_non_integer_pk
        Subscriber.delete_all
        Subscriber.connection.reset_pk_sequence! "subscribers"
        sub = Subscriber.new(name: "robert drake")
        sub.id = "bob drake"
        assert_nothing_raised { sub.save! }
      end
    end

    def test_uniqueness_violations_are_translated_to_specific_exception
      @connection.execute "INSERT INTO subscribers(nick) VALUES('me')"
      error = assert_raises(ActiveRecord::RecordNotUnique) do
        @connection.execute "INSERT INTO subscribers(nick) VALUES('me')"
      end

      assert_not_nil error.cause
    end

    unless current_adapter?(:SQLite3Adapter)
      def test_foreign_key_violations_are_translated_to_specific_exception
        error = assert_raises(ActiveRecord::InvalidForeignKey) do
          # Oracle adapter uses prefetched primary key values from sequence and passes them to connection adapter insert method
          if @connection.prefetch_primary_key?
            id_value = @connection.next_sequence_value(@connection.default_sequence_name("fk_test_has_fk", "id"))
            @connection.execute "INSERT INTO fk_test_has_fk (id, fk_id) VALUES (#{id_value},0)"
          else
            @connection.execute "INSERT INTO fk_test_has_fk (fk_id) VALUES (0)"
          end
        end

        assert_not_nil error.cause
      end

      def test_foreign_key_violations_are_translated_to_specific_exception_with_validate_false
        klass_has_fk = Class.new(ActiveRecord::Base) do
          self.table_name = "fk_test_has_fk"
        end

        error = assert_raises(ActiveRecord::InvalidForeignKey) do
          has_fk = klass_has_fk.new
          has_fk.fk_id = 1231231231
          has_fk.save(validate: false)
        end

        assert_not_nil error.cause
      end

      def test_value_limit_violations_are_translated_to_specific_exception
        error = assert_raises(ActiveRecord::ValueTooLong) do
          Event.create(title: "abcdefgh")
        end

        assert_not_nil error.cause
      end
    end

    def test_disable_referential_integrity
      assert_nothing_raised do
        @connection.disable_referential_integrity do
          # Oracle adapter uses prefetched primary key values from sequence and passes them to connection adapter insert method
          if @connection.prefetch_primary_key?
            id_value = @connection.next_sequence_value(@connection.default_sequence_name("fk_test_has_fk", "id"))
            @connection.execute "INSERT INTO fk_test_has_fk (id, fk_id) VALUES (#{id_value},0)"
          else
            @connection.execute "INSERT INTO fk_test_has_fk (fk_id) VALUES (0)"
          end
          # should delete created record as otherwise disable_referential_integrity will try to enable constraints after executed block
          # and will fail (at least on Oracle)
          @connection.execute "DELETE FROM fk_test_has_fk"
        end
      end
    end

    def test_select_all_always_return_activerecord_result
      result = @connection.select_all "SELECT * FROM posts"
      assert result.is_a?(ActiveRecord::Result)
    end

    def test_select_methods_passing_a_association_relation
      author = Author.create!(name: "john")
      Post.create!(author: author, title: "foo", body: "bar")
      query = author.posts.where(title: "foo").select(:title)
      assert_equal({"title" => "foo"}, @connection.select_one(query.arel, nil, query.bound_attributes))
      assert_equal({"title" => "foo"}, @connection.select_one(query))
      assert @connection.select_all(query).is_a?(ActiveRecord::Result)
      assert_equal "foo", @connection.select_value(query)
      assert_equal ["foo"], @connection.select_values(query)
    end

    def test_select_methods_passing_a_relation
      Post.create!(title: "foo", body: "bar")
      query = Post.where(title: "foo").select(:title)
      assert_equal({"title" => "foo"}, @connection.select_one(query.arel, nil, query.bound_attributes))
      assert_equal({"title" => "foo"}, @connection.select_one(query))
      assert @connection.select_all(query).is_a?(ActiveRecord::Result)
      assert_equal "foo", @connection.select_value(query)
      assert_equal ["foo"], @connection.select_values(query)
    end

    test "type_to_sql returns a String for unmapped types" do
      assert_equal "special_db_type", @connection.type_to_sql(:special_db_type)
    end

    unless current_adapter?(:PostgreSQLAdapter)
      def test_log_invalid_encoding
        error = assert_raise ActiveRecord::StatementInvalid do
          @connection.send :log, "SELECT 'ы' FROM DUAL" do
            raise "ы".force_encoding(Encoding::ASCII_8BIT)
          end
        end

        assert_not_nil error.cause
      end
    end

    if current_adapter?(:Mysql2Adapter, :SQLite3Adapter)
      def test_tables_returning_both_tables_and_views_is_deprecated
        assert_deprecated { @connection.tables }
      end
    end

    def test_passing_arguments_to_tables_is_deprecated
      assert_deprecated { @connection.tables(:books) }
    end
  end

  class AdapterTestWithoutTransaction < ActiveRecord::TestCase
    self.use_transactional_tests = false

    class Klass < ActiveRecord::Base
    end

    def setup
      Klass.establish_connection :arunit
      @connection = Klass.connection
    end

    teardown do
      Klass.remove_connection
    end

    unless in_memory_db?
      test "transaction state is reset after a reconnect" do
        @connection.begin_transaction
        assert @connection.transaction_open?
        @connection.reconnect!
        assert !@connection.transaction_open?
      end

      test "transaction state is reset after a disconnect" do
        @connection.begin_transaction
        assert @connection.transaction_open?
        @connection.disconnect!
        assert !@connection.transaction_open?
      end
    end
  end
end
module Admin
  def self.table_name_prefix
    "admin_"
  end
end
module ActiveRecord
  # See ActiveRecord::Aggregations::ClassMethods for documentation
  module Aggregations
    extend ActiveSupport::Concern

    def initialize_dup(*) # :nodoc:
      @aggregation_cache = {}
      super
    end

    def reload(*) # :nodoc:
      clear_aggregation_cache
      super
    end

    private

      def clear_aggregation_cache # :nodoc:
        @aggregation_cache.clear if persisted?
      end

      def init_internals # :nodoc:
        @aggregation_cache = {}
        super
      end

    # Active Record implements aggregation through a macro-like class method called #composed_of
    # for representing attributes as value objects. It expresses relationships like "Account [is]
    # composed of Money [among other things]" or "Person [is] composed of [an] address". Each call
    # to the macro adds a description of how the value objects are created from the attributes of
    # the entity object (when the entity is initialized either as a new object or from finding an
    # existing object) and how it can be turned back into attributes (when the entity is saved to
    # the database).
    #
    #   class Customer < ActiveRecord::Base
    #     composed_of :balance, class_name: "Money", mapping: %w(amount currency)
    #     composed_of :address, mapping: [ %w(address_street street), %w(address_city city) ]
    #   end
    #
    # The customer class now has the following methods to manipulate the value objects:
    # * <tt>Customer#balance, Customer#balance=(money)</tt>
    # * <tt>Customer#address, Customer#address=(address)</tt>
    #
    # These methods will operate with value objects like the ones described below:
    #
    #  class Money
    #    include Comparable
    #    attr_reader :amount, :currency
    #    EXCHANGE_RATES = { "USD_TO_DKK" => 6 }
    #
    #    def initialize(amount, currency = "USD")
    #      @amount, @currency = amount, currency
    #    end
    #
    #    def exchange_to(other_currency)
    #      exchanged_amount = (amount * EXCHANGE_RATES["#{currency}_TO_#{other_currency}"]).floor
    #      Money.new(exchanged_amount, other_currency)
    #    end
    #
    #    def ==(other_money)
    #      amount == other_money.amount && currency == other_money.currency
    #    end
    #
    #    def <=>(other_money)
    #      if currency == other_money.currency
    #        amount <=> other_money.amount
    #      else
    #        amount <=> other_money.exchange_to(currency).amount
    #      end
    #    end
    #  end
    #
    #  class Address
    #    attr_reader :street, :city
    #    def initialize(street, city)
    #      @street, @city = street, city
    #    end
    #
    #    def close_to?(other_address)
    #      city == other_address.city
    #    end
    #
    #    def ==(other_address)
    #      city == other_address.city && street == other_address.street
    #    end
    #  end
    #
    # Now it's possible to access attributes from the database through the value objects instead. If
    # you choose to name the composition the same as the attribute's name, it will be the only way to
    # access that attribute. That's the case with our +balance+ attribute. You interact with the value
    # objects just like you would with any other attribute:
    #
    #   customer.balance = Money.new(20)     # sets the Money value object and the attribute
    #   customer.balance                     # => Money value object
    #   customer.balance.exchange_to("DKK")  # => Money.new(120, "DKK")
    #   customer.balance > Money.new(10)     # => true
    #   customer.balance == Money.new(20)    # => true
    #   customer.balance < Money.new(5)      # => false
    #
    # Value objects can also be composed of multiple attributes, such as the case of Address. The order
    # of the mappings will determine the order of the parameters.
    #
    #   customer.address_street = "Hyancintvej"
    #   customer.address_city   = "Copenhagen"
    #   customer.address        # => Address.new("Hyancintvej", "Copenhagen")
    #
    #   customer.address = Address.new("May Street", "Chicago")
    #   customer.address_street # => "May Street"
    #   customer.address_city   # => "Chicago"
    #
    # == Writing value objects
    #
    # Value objects are immutable and interchangeable objects that represent a given value, such as
    # a Money object representing $5. Two Money objects both representing $5 should be equal (through
    # methods such as <tt>==</tt> and <tt><=></tt> from Comparable if ranking makes sense). This is
    # unlike entity objects where equality is determined by identity. An entity class such as Customer can
    # easily have two different objects that both have an address on Hyancintvej. Entity identity is
    # determined by object or relational unique identifiers (such as primary keys). Normal
    # ActiveRecord::Base classes are entity objects.
    #
    # It's also important to treat the value objects as immutable. Don't allow the Money object to have
    # its amount changed after creation. Create a new Money object with the new value instead. The
    # <tt>Money#exchange_to</tt> method is an example of this. It returns a new value object instead of changing
    # its own values. Active Record won't persist value objects that have been changed through means
    # other than the writer method.
    #
    # The immutable requirement is enforced by Active Record by freezing any object assigned as a value
    # object. Attempting to change it afterwards will result in a +RuntimeError+.
    #
    # Read more about value objects on http://c2.com/cgi/wiki?ValueObject and on the dangers of not
    # keeping value objects immutable on http://c2.com/cgi/wiki?ValueObjectsShouldBeImmutable
    #
    # == Custom constructors and converters
    #
    # By default value objects are initialized by calling the <tt>new</tt> constructor of the value
    # class passing each of the mapped attributes, in the order specified by the <tt>:mapping</tt>
    # option, as arguments. If the value class doesn't support this convention then #composed_of allows
    # a custom constructor to be specified.
    #
    # When a new value is assigned to the value object, the default assumption is that the new value
    # is an instance of the value class. Specifying a custom converter allows the new value to be automatically
    # converted to an instance of value class if necessary.
    #
    # For example, the +NetworkResource+ model has +network_address+ and +cidr_range+ attributes that should be
    # aggregated using the +NetAddr::CIDR+ value class (http://www.rubydoc.info/gems/netaddr/1.5.0/NetAddr/CIDR).
    # The constructor for the value class is called +create+ and it expects a CIDR address string as a parameter.
    # New values can be assigned to the value object using either another +NetAddr::CIDR+ object, a string
    # or an array. The <tt>:constructor</tt> and <tt>:converter</tt> options can be used to meet
    # these requirements:
    #
    #   class NetworkResource < ActiveRecord::Base
    #     composed_of :cidr,
    #                 class_name: 'NetAddr::CIDR',
    #                 mapping: [ %w(network_address network), %w(cidr_range bits) ],
    #                 allow_nil: true,
    #                 constructor: Proc.new { |network_address, cidr_range| NetAddr::CIDR.create("#{network_address}/#{cidr_range}") },
    #                 converter: Proc.new { |value| NetAddr::CIDR.create(value.is_a?(Array) ? value.join('/') : value) }
    #   end
    #
    #   # This calls the :constructor
    #   network_resource = NetworkResource.new(network_address: '192.168.0.1', cidr_range: 24)
    #
    #   # These assignments will both use the :converter
    #   network_resource.cidr = [ '192.168.2.1', 8 ]
    #   network_resource.cidr = '192.168.0.1/24'
    #
    #   # This assignment won't use the :converter as the value is already an instance of the value class
    #   network_resource.cidr = NetAddr::CIDR.create('192.168.2.1/8')
    #
    #   # Saving and then reloading will use the :constructor on reload
    #   network_resource.save
    #   network_resource.reload
    #
    # == Finding records by a value object
    #
    # Once a #composed_of relationship is specified for a model, records can be loaded from the database
    # by specifying an instance of the value object in the conditions hash. The following example
    # finds all customers with +balance_amount+ equal to 20 and +balance_currency+ equal to "USD":
    #
    #   Customer.where(balance: Money.new(20, "USD"))
    #
      module ClassMethods
        # Adds reader and writer methods for manipulating a value object:
        # <tt>composed_of :address</tt> adds <tt>address</tt> and <tt>address=(new_address)</tt> methods.
        #
        # Options are:
        # * <tt>:class_name</tt> - Specifies the class name of the association. Use it only if that name
        #   can't be inferred from the part id. So <tt>composed_of :address</tt> will by default be linked
        #   to the Address class, but if the real class name is +CompanyAddress+, you'll have to specify it
        #   with this option.
        # * <tt>:mapping</tt> - Specifies the mapping of entity attributes to attributes of the value
        #   object. Each mapping is represented as an array where the first item is the name of the
        #   entity attribute and the second item is the name of the attribute in the value object. The
        #   order in which mappings are defined determines the order in which attributes are sent to the
        #   value class constructor.
        # * <tt>:allow_nil</tt> - Specifies that the value object will not be instantiated when all mapped
        #   attributes are +nil+. Setting the value object to +nil+ has the effect of writing +nil+ to all
        #   mapped attributes.
        #   This defaults to +false+.
        # * <tt>:constructor</tt> - A symbol specifying the name of the constructor method or a Proc that
        #   is called to initialize the value object. The constructor is passed all of the mapped attributes,
        #   in the order that they are defined in the <tt>:mapping option</tt>, as arguments and uses them
        #   to instantiate a <tt>:class_name</tt> object.
        #   The default is <tt>:new</tt>.
        # * <tt>:converter</tt> - A symbol specifying the name of a class method of <tt>:class_name</tt>
        #   or a Proc that is called when a new value is assigned to the value object. The converter is
        #   passed the single value that is used in the assignment and is only called if the new value is
        #   not an instance of <tt>:class_name</tt>. If <tt>:allow_nil</tt> is set to true, the converter
        #   can return nil to skip the assignment.
        #
        # Option examples:
        #   composed_of :temperature, mapping: %w(reading celsius)
        #   composed_of :balance, class_name: "Money", mapping: %w(balance amount),
        #                         converter: Proc.new { |balance| balance.to_money }
        #   composed_of :address, mapping: [ %w(address_street street), %w(address_city city) ]
        #   composed_of :gps_location
        #   composed_of :gps_location, allow_nil: true
        #   composed_of :ip_address,
        #               class_name: 'IPAddr',
        #               mapping: %w(ip to_i),
        #               constructor: Proc.new { |ip| IPAddr.new(ip, Socket::AF_INET) },
        #               converter: Proc.new { |ip| ip.is_a?(Integer) ? IPAddr.new(ip, Socket::AF_INET) : IPAddr.new(ip.to_s) }
        #
        def composed_of(part_id, options = {})
          options.assert_valid_keys(:class_name, :mapping, :allow_nil, :constructor, :converter)

          name        = part_id.id2name
          class_name  = options[:class_name]  || name.camelize
          mapping     = options[:mapping]     || [ name, name ]
          mapping     = [ mapping ] unless mapping.first.is_a?(Array)
          allow_nil   = options[:allow_nil]   || false
          constructor = options[:constructor] || :new
          converter   = options[:converter]

          reader_method(name, class_name, mapping, allow_nil, constructor)
          writer_method(name, class_name, mapping, allow_nil, converter)

          reflection = ActiveRecord::Reflection.create(:composed_of, part_id, nil, options, self)
          Reflection.add_aggregate_reflection self, part_id, reflection
        end

        private
          def reader_method(name, class_name, mapping, allow_nil, constructor)
            define_method(name) do
              if @aggregation_cache[name].nil? && (!allow_nil || mapping.any? {|key, _| !_read_attribute(key).nil? })
                attrs = mapping.collect {|key, _| _read_attribute(key)}
                object = constructor.respond_to?(:call) ?
                  constructor.call(*attrs) :
                  class_name.constantize.send(constructor, *attrs)
                @aggregation_cache[name] = object
              end
              @aggregation_cache[name]
            end
          end

          def writer_method(name, class_name, mapping, allow_nil, converter)
            define_method("#{name}=") do |part|
              klass = class_name.constantize

              unless part.is_a?(klass) || converter.nil? || part.nil?
                part = converter.respond_to?(:call) ? converter.call(part) : klass.send(converter, part)
              end

              hash_from_multiparameter_assignment = part.is_a?(Hash) &&
                part.each_key.all? { |k| k.is_a?(Integer) }
              if hash_from_multiparameter_assignment
                raise ArgumentError unless part.size == part.each_key.max
                part = klass.new(*part.sort.map(&:last))
              end

              if part.nil? && allow_nil
                mapping.each { |key, _| self[key] = nil }
                @aggregation_cache[name] = nil
              else
                mapping.each { |key, value| self[key] = part.send(value) }
                @aggregation_cache[name] = part.freeze
              end
            end
          end
      end
  end
end
require "cases/helper"
require "models/customer"

class AggregationsTest < ActiveRecord::TestCase
  fixtures :customers

  def test_find_single_value_object
    assert_equal 50, customers(:david).balance.amount
    assert_kind_of Money, customers(:david).balance
    assert_equal 300, customers(:david).balance.exchange_to("DKK").amount
  end

  def test_find_multiple_value_object
    assert_equal customers(:david).address_street, customers(:david).address.street
    assert(
      customers(:david).address.close_to?(Address.new("Different Street", customers(:david).address_city, customers(:david).address_country))
    )
  end

  def test_change_single_value_object
    customers(:david).balance = Money.new(100)
    customers(:david).save
    assert_equal 100, customers(:david).reload.balance.amount
  end

  def test_immutable_value_objects
    customers(:david).balance = Money.new(100)
    assert_raise(RuntimeError) { customers(:david).balance.instance_eval { @amount = 20 } }
  end

  def test_inferred_mapping
    assert_equal "35.544623640962634", customers(:david).gps_location.latitude
    assert_equal "-105.9309951055148", customers(:david).gps_location.longitude

    customers(:david).gps_location = GpsLocation.new("39x-110")

    assert_equal "39", customers(:david).gps_location.latitude
    assert_equal "-110", customers(:david).gps_location.longitude

    customers(:david).save

    customers(:david).reload

    assert_equal "39", customers(:david).gps_location.latitude
    assert_equal "-110", customers(:david).gps_location.longitude
  end

  def test_reloaded_instance_refreshes_aggregations
    assert_equal "35.544623640962634", customers(:david).gps_location.latitude
    assert_equal "-105.9309951055148", customers(:david).gps_location.longitude

    Customer.update_all("gps_location = '24x113'")
    customers(:david).reload
    assert_equal "24x113", customers(:david)["gps_location"]

    assert_equal GpsLocation.new("24x113"), customers(:david).gps_location
  end

  def test_gps_equality
    assert_equal GpsLocation.new("39x110"), GpsLocation.new("39x110")
  end

  def test_gps_inequality
    assert_not_equal GpsLocation.new("39x110"), GpsLocation.new("39x111")
  end

  def test_allow_nil_gps_is_nil
    assert_nil customers(:zaphod).gps_location
  end

  def test_allow_nil_gps_set_to_nil
    customers(:david).gps_location = nil
    customers(:david).save
    customers(:david).reload
    assert_nil customers(:david).gps_location
  end

  def test_allow_nil_set_address_attributes_to_nil
    customers(:zaphod).address = nil
    assert_nil customers(:zaphod).attributes[:address_street]
    assert_nil customers(:zaphod).attributes[:address_city]
    assert_nil customers(:zaphod).attributes[:address_country]
  end

  def test_allow_nil_address_set_to_nil
    customers(:zaphod).address = nil
    customers(:zaphod).save
    customers(:zaphod).reload
    assert_nil customers(:zaphod).address
  end

  def test_nil_raises_error_when_allow_nil_is_false
    assert_raise(NoMethodError) { customers(:david).balance = nil }
  end

  def test_allow_nil_address_loaded_when_only_some_attributes_are_nil
    customers(:zaphod).address_street = nil
    customers(:zaphod).save
    customers(:zaphod).reload
    assert_kind_of Address, customers(:zaphod).address
    assert_nil customers(:zaphod).address.street
  end

  def test_nil_assignment_results_in_nil
    customers(:david).gps_location = GpsLocation.new("39x111")
    assert_not_nil customers(:david).gps_location
    customers(:david).gps_location = nil
    assert_nil customers(:david).gps_location
  end

  def test_nil_return_from_converter_is_respected_when_allow_nil_is_true
    customers(:david).non_blank_gps_location = ""
    customers(:david).save
    customers(:david).reload
    assert_nil customers(:david).non_blank_gps_location
  ensure
    Customer.gps_conversion_was_run = nil
  end

  def test_nil_return_from_converter_results_in_failure_when_allow_nil_is_false
    assert_raises(NoMethodError) do
      customers(:barney).gps_location = ""
    end
  end

  def test_do_not_run_the_converter_when_nil_was_set
    customers(:david).non_blank_gps_location = nil
    assert_nil Customer.gps_conversion_was_run
  end

  def test_custom_constructor
    assert_equal "Barney GUMBLE", customers(:barney).fullname.to_s
    assert_kind_of Fullname, customers(:barney).fullname
  end

  def test_custom_converter
    customers(:barney).fullname = "Barnoit Gumbleau"
    assert_equal "Barnoit GUMBLEAU", customers(:barney).fullname.to_s
    assert_kind_of Fullname, customers(:barney).fullname
  end

  def test_assigning_hash_to_custom_converter
    customers(:barney).fullname = { first: "Barney", last: "Stinson" }
    assert_equal "Barney STINSON", customers(:barney).name
  end

  def test_assigning_hash_without_custom_converter
    customers(:barney).fullname_no_converter = { first: "Barney", last: "Stinson" }
    assert_equal({ first: "Barney", last: "Stinson" }.to_s, customers(:barney).name)
  end
end

class OverridingAggregationsTest < ActiveRecord::TestCase
  class DifferentName; end

  class Person < ActiveRecord::Base
    composed_of :composed_of, mapping: %w(person_first_name first_name)
  end

  class DifferentPerson < Person
    composed_of :composed_of, class_name: "DifferentName", mapping: %w(different_person_first_name first_name)
  end

  def test_composed_of_aggregation_redefinition_reflections_should_differ_and_not_inherited
    assert_not_equal Person.reflect_on_aggregation(:composed_of),
                     DifferentPerson.reflect_on_aggregation(:composed_of)
  end
end
class Object
  # Makes backticks behave (somewhat more) similarly on all platforms.
  # On win32 `nonexistent_command` raises Errno::ENOENT; on Unix, the
  # spawned shell prints a message to stderr and sets $?. We emulate
  # Unix on the former but not the latter.
  def `(command) #:nodoc:
    super
  rescue Errno::ENOENT => e
    STDERR.puts "#$0: #{e}"
  end
end
class Aircraft < ActiveRecord::Base
  self.pluralize_table_names = false
  has_many :engines, foreign_key: "car_id"
  has_many :wheels, as: :wheelable
end
class Module
  # NOTE: This method is deprecated. Please use <tt>Module#prepend</tt> that
  # comes with Ruby 2.0 or newer instead.
  #
  # Encapsulates the common pattern of:
  #
  #   alias_method :foo_without_feature, :foo
  #   alias_method :foo, :foo_with_feature
  #
  # With this, you simply do:
  #
  #   alias_method_chain :foo, :feature
  #
  # And both aliases are set up for you.
  #
  # Query and bang methods (foo?, foo!) keep the same punctuation:
  #
  #   alias_method_chain :foo?, :feature
  #
  # is equivalent to
  #
  #   alias_method :foo_without_feature?, :foo?
  #   alias_method :foo?, :foo_with_feature?
  #
  # so you can safely chain foo, foo?, foo! and/or foo= with the same feature.
  def alias_method_chain(target, feature)
    ActiveSupport::Deprecation.warn("alias_method_chain is deprecated. Please, use Module#prepend instead. From module, you can access the original method using super.")

    # Strip out punctuation on predicates, bang or writer methods since
    # e.g. target?_without_feature is not a valid method name.
    aliased_target, punctuation = target.to_s.sub(/([?!=])$/, ""), $1
    yield(aliased_target, punctuation) if block_given?

    with_method = "#{aliased_target}_with_#{feature}#{punctuation}"
    without_method = "#{aliased_target}_without_#{feature}#{punctuation}"

    alias_method without_method, target
    alias_method target, with_method

    case
    when public_method_defined?(without_method)
      public target
    when protected_method_defined?(without_method)
      protected target
    when private_method_defined?(without_method)
      private target
    end
  end

  # Allows you to make aliases for attributes, which includes
  # getter, setter, and a predicate.
  #
  #   class Content < ActiveRecord::Base
  #     # has a title attribute
  #   end
  #
  #   class Email < Content
  #     alias_attribute :subject, :title
  #   end
  #
  #   e = Email.find(1)
  #   e.title    # => "Superstars"
  #   e.subject  # => "Superstars"
  #   e.subject? # => true
  #   e.subject = "Megastars"
  #   e.title    # => "Megastars"
  def alias_attribute(new_name, old_name)
    # The following reader methods use an explicit `self` receiver in order to
    # support aliases that start with an uppercase letter. Otherwise, they would
    # be resolved as constants instead.
    module_eval <<-STR, __FILE__, __LINE__ + 1
      def #{new_name}; self.#{old_name}; end          # def subject; self.title; end
      def #{new_name}?; self.#{old_name}?; end        # def subject?; self.title?; end
      def #{new_name}=(v); self.#{old_name} = v; end  # def subject=(v); self.title = v; end
    STR
  end
end
require "active_support/core_ext/string/conversions"

module ActiveRecord
  module Associations
    # Keeps track of table aliases for ActiveRecord::Associations::JoinDependency
    class AliasTracker # :nodoc:
      attr_reader :aliases

      def self.create(connection, initial_table, type_caster)
        aliases = Hash.new(0)
        aliases[initial_table] = 1
        new connection, aliases, type_caster
      end

      def self.create_with_joins(connection, initial_table, joins, type_caster)
        if joins.empty?
          create(connection, initial_table, type_caster)
        else
          aliases = Hash.new { |h, k|
            h[k] = initial_count_for(connection, k, joins)
          }
          aliases[initial_table] = 1
          new connection, aliases, type_caster
        end
      end

      def self.initial_count_for(connection, name, table_joins)
        # quoted_name should be downcased as some database adapters (Oracle) return quoted name in uppercase
        quoted_name = connection.quote_table_name(name).downcase

        counts = table_joins.map do |join|
          if join.is_a?(Arel::Nodes::StringJoin)
            # Table names + table aliases
            join.left.downcase.scan(
              /join(?:\s+\w+)?\s+(\S+\s+)?#{quoted_name}\son/
            ).size
          elsif join.respond_to? :left
            join.left.table_name == name ? 1 : 0
          else
            # this branch is reached by two tests:
            #
            # activerecord/test/cases/associations/cascaded_eager_loading_test.rb:37
            #   with :posts
            #
            # activerecord/test/cases/associations/eager_test.rb:1133
            #   with :comments
            #
            0
          end
        end

        counts.sum
      end

      # table_joins is an array of arel joins which might conflict with the aliases we assign here
      def initialize(connection, aliases, type_caster)
        @aliases    = aliases
        @connection = connection
        @type_caster = type_caster
      end

      def aliased_table_for(table_name, aliased_name)
        if aliases[table_name].zero?
          # If it's zero, we can have our table_name
          aliases[table_name] = 1
          Arel::Table.new(table_name, type_caster: @type_caster)
        else
          # Otherwise, we need to use an alias
          aliased_name = @connection.table_alias_for(aliased_name)

          # Update the count
          aliases[aliased_name] += 1

          table_alias = if aliases[aliased_name] > 1
            "#{truncate(aliased_name)}_#{aliases[aliased_name]}"
          else
            aliased_name
          end
          Arel::Table.new(table_name, type_caster: @type_caster).alias(table_alias)
        end
      end

      private

        def truncate(name)
          name.slice(0, @connection.table_alias_length - 2)
        end
    end
  end
end
require "active_support"
require "active_support/time"
require "active_support/core_ext"
require "abstract_unit"
require "action_controller/metal/strong_parameters"

class AlwaysPermittedParametersTest < ActiveSupport::TestCase
  def setup
    ActionController::Parameters.action_on_unpermitted_parameters = :raise
    ActionController::Parameters.always_permitted_parameters = %w( controller action format )
  end

  def teardown
    ActionController::Parameters.action_on_unpermitted_parameters = false
    ActionController::Parameters.always_permitted_parameters = %w( controller action )
  end

  test "returns super on missing constant other than NEVER_UNPERMITTED_PARAMS" do
    ActionController::Parameters.superclass.stub :const_missing, "super" do
      assert_equal "super", ActionController::Parameters::NON_EXISTING_CONSTANT
    end
  end

  test "permits parameters that are whitelisted" do
    params = ActionController::Parameters.new(      book: { pages: 65 },
      format: "json")
    permitted = params.permit book: [:pages]
    assert permitted.permitted?
  end
end
class Module
  # A module may or may not have a name.
  #
  #   module M; end
  #   M.name # => "M"
  #
  #   m = Module.new
  #   m.name # => nil
  #
  # +anonymous?+ method returns true if module does not have a name, false otherwise:
  #
  #   Module.new.anonymous? # => true
  #
  #   module M; end
  #   M.anonymous?          # => false
  #
  # A module gets a name when it is first assigned to a constant. Either
  # via the +module+ or +class+ keyword or by an explicit assignment:
  #
  #   m = Module.new # creates an anonymous module
  #   m.anonymous?   # => true
  #   M = m          # m gets a name here as a side-effect
  #   m.name         # => "M"
  #   m.anonymous?   # => false
  def anonymous?
    name.nil?
  end
end
require "abstract_unit"
require "active_support/core_ext/module/anonymous"

class AnonymousTest < ActiveSupport::TestCase
  test "an anonymous class or module are anonymous" do
    assert Module.new.anonymous?
    assert Class.new.anonymous?
  end

  test "a named class or module are not anonymous" do
    assert !Kernel.anonymous?
    assert !Object.anonymous?
  end
end
class Fixtures::AnotherClass
end
require "generators/generators_test_helper"
require "rails/generators/rails/app/app_generator"

class ApiAppGeneratorTest < Rails::Generators::TestCase
  include GeneratorsTestHelper
  tests Rails::Generators::AppGenerator

  arguments [destination_root, "--api"]

  def setup
    Rails.application = TestApp::Application
    super

    Kernel::silence_warnings do
      Thor::Base.shell.send(:attr_accessor, :always_force)
      @shell = Thor::Base.shell.new
      @shell.send(:always_force=, true)
    end
  end

  def teardown
    super
    Rails.application = TestApp::Application.instance
  end

  def test_skeleton_is_created
    run_generator

    default_files.each { |path| assert_file path }
    skipped_files.each { |path| assert_no_file path }
  end

  def test_api_modified_files
    run_generator

    assert_file "Gemfile" do |content|
      assert_no_match(/gem 'coffee-rails'/, content)
      assert_no_match(/gem 'jquery-rails'/, content)
      assert_no_match(/gem 'sass-rails'/, content)
      assert_no_match(/gem 'web-console'/, content)
      assert_match(/# gem 'jbuilder'/, content)
    end

    assert_file "config/application.rb" do |content|
      assert_match(/config.api_only = true/, content)
    end

    assert_file "config/initializers/cors.rb"

    assert_file "config/initializers/wrap_parameters.rb"

    assert_file "app/controllers/application_controller.rb", /ActionController::API/
  end

  def test_generator_if_skip_action_cable_is_given
    run_generator [destination_root, "--skip-action-cable"]
    assert_file "config/application.rb", /#\s+require\s+["']action_cable\/engine["']/
    assert_no_file "config/cable.yml"
    assert_no_file "app/channels"
    assert_file "Gemfile" do |content|
      assert_no_match(/redis/, content)
    end
  end

  def test_generator_skips_per_form_csrf_token_and_origin_check_configs_for_api_apps
    run_generator

    assert_file "config/initializers/new_framework_defaults.rb" do |initializer_content|
      assert_no_match(/per_form_csrf_tokens/, initializer_content)
      assert_no_match(/forgery_protection_origin_check/, initializer_content)
    end
  end

  private

    def default_files
      files = %W(
        .gitignore
        Gemfile
        Rakefile
        config.ru
        app/controllers
        app/mailers
        app/models
        app/views/layouts/mailer.html.erb
        app/views/layouts/mailer.text.erb
        config/environments
        config/initializers
        config/locales
        db
        lib
        lib/tasks
        log
        test/fixtures
        test/controllers
        test/integration
        test/models
        tmp
        vendor
      )
      files.concat %w(bin/bundle bin/rails bin/rake)
      files
    end

    def skipped_files
      %w(app/assets
         app/helpers
         app/views/layouts/application.html.erb
         config/initializers/assets.rb
         config/initializers/cookies_serializer.rb
         lib/assets
         vendor/assets
         test/helpers
         tmp/cache/assets
         public/404.html
         public/422.html
         public/500.html
         public/apple-touch-icon-precomposed.png
         public/apple-touch-icon.png
         public/favicon.ico)
    end
end
<% if namespaced? -%>
require_dependency "<%= namespaced_path %>/application_controller"

<% end -%>
<% module_namespacing do -%>
class <%= controller_class_name %>Controller < ApplicationController
  before_action :set_<%= singular_table_name %>, only: [:show, :update, :destroy]

  # GET <%= route_url %>
  def index
    @<%= plural_table_name %> = <%= orm_class.all(class_name) %>

    render json: <%= "@#{plural_table_name}" %>
  end

  # GET <%= route_url %>/1
  def show
    render json: <%= "@#{singular_table_name}" %>
  end

  # POST <%= route_url %>
  def create
    @<%= singular_table_name %> = <%= orm_class.build(class_name, "#{singular_table_name}_params") %>

    if @<%= orm_instance.save %>
      render json: <%= "@#{singular_table_name}" %>, status: :created, location: <%= "@#{singular_table_name}" %>
    else
      render json: <%= "@#{orm_instance.errors}" %>, status: :unprocessable_entity
    end
  end

  # PATCH/PUT <%= route_url %>/1
  def update
    if @<%= orm_instance.update("#{singular_table_name}_params") %>
      render json: <%= "@#{singular_table_name}" %>
    else
      render json: <%= "@#{orm_instance.errors}" %>, status: :unprocessable_entity
    end
  end

  # DELETE <%= route_url %>/1
  def destroy
    @<%= orm_instance.destroy %>
  end

  private
    # Use callbacks to share common setup or constraints between actions.
    def set_<%= singular_table_name %>
      @<%= singular_table_name %> = <%= orm_class.find(class_name, "params[:id]") %>
    end

    # Only allow a trusted parameter "white list" through.
    def <%= "#{singular_table_name}_params" %>
      <%- if attributes_names.empty? -%>
      params.fetch(:<%= singular_table_name %>, {})
      <%- else -%>
      params.require(:<%= singular_table_name %>).permit(<%= attributes_names.map { |name| ":#{name}" }.join(', ') %>)
      <%- end -%>
    end
end
<% end -%>
require 'test_helper'

<% module_namespacing do -%>
class <%= controller_class_name %>ControllerTest < ActionDispatch::IntegrationTest
  <%- if mountable_engine? -%>
  include Engine.routes.url_helpers

  <%- end -%>
  setup do
    @<%= singular_table_name %> = <%= fixture_name %>(:one)
  end

  test "should get index" do
    get <%= index_helper %>_url, as: :json
    assert_response :success
  end

  test "should create <%= singular_table_name %>" do
    assert_difference('<%= class_name %>.count') do
      post <%= index_helper %>_url, params: { <%= "#{singular_table_name}: { #{attributes_hash} }" %> }, as: :json
    end

    assert_response 201
  end

  test "should show <%= singular_table_name %>" do
    get <%= show_helper %>, as: :json
    assert_response :success
  end

  test "should update <%= singular_table_name %>" do
    patch <%= show_helper %>, params: { <%= "#{singular_table_name}: { #{attributes_hash} }" %> }, as: :json
    assert_response 200
  end

  test "should destroy <%= singular_table_name %>" do
    assert_difference('<%= class_name %>.count', -1) do
      delete <%= show_helper %>, as: :json
    end

    assert_response 204
  end
end
<% end -%>
require "action_view"
require "action_controller"
require "action_controller/log_subscriber"

module ActionController
  # API Controller is a lightweight version of <tt>ActionController::Base</tt>,
  # created for applications that don't require all functionalities that a complete
  # \Rails controller provides, allowing you to create controllers with just the
  # features that you need for API only applications.
  #
  # An API Controller is different from a normal controller in the sense that
  # by default it doesn't include a number of features that are usually required
  # by browser access only: layouts and templates rendering, cookies, sessions,
  # flash, assets, and so on. This makes the entire controller stack thinner,
  # suitable for API applications. It doesn't mean you won't have such
  # features if you need them: they're all available for you to include in
  # your application, they're just not part of the default API controller stack.
  #
  # Normally, +ApplicationController+ is the only controller that inherits from
  # <tt>ActionController::API</tt>. All other controllers in turn inherit from
  # +ApplicationController+.
  #
  # A sample controller could look like this:
  #
  #   class PostsController < ApplicationController
  #     def index
  #       posts = Post.all
  #       render json: posts
  #     end
  #   end
  #
  # Request, response, and parameters objects all work the exact same way as
  # <tt>ActionController::Base</tt>.
  #
  # == Renders
  #
  # The default API Controller stack includes all renderers, which means you
  # can use <tt>render :json</tt> and brothers freely in your controllers. Keep
  # in mind that templates are not going to be rendered, so you need to ensure
  # your controller is calling either <tt>render</tt> or <tt>redirect_to</tt> in
  # all actions, otherwise it will return 204 No Content.
  #
  #   def show
  #     post = Post.find(params[:id])
  #     render json: post
  #   end
  #
  # == Redirects
  #
  # Redirects are used to move from one action to another. You can use the
  # <tt>redirect_to</tt> method in your controllers in the same way as in
  # <tt>ActionController::Base</tt>. For example:
  #
  #   def create
  #     redirect_to root_url and return if not_authorized?
  #     # do stuff here
  #   end
  #
  # == Adding New Behavior
  #
  # In some scenarios you may want to add back some functionality provided by
  # <tt>ActionController::Base</tt> that is not present by default in
  # <tt>ActionController::API</tt>, for instance <tt>MimeResponds</tt>. This
  # module gives you the <tt>respond_to</tt> method. Adding it is quite simple,
  # you just need to include the module in a specific controller or in
  # +ApplicationController+ in case you want it available in your entire
  # application:
  #
  #   class ApplicationController < ActionController::API
  #     include ActionController::MimeResponds
  #   end
  #
  #   class PostsController < ApplicationController
  #     def index
  #       posts = Post.all
  #
  #       respond_to do |format|
  #         format.json { render json: posts }
  #         format.xml  { render xml: posts }
  #       end
  #     end
  #   end
  #
  # Quite straightforward. Make sure to check the modules included in
  # <tt>ActionController::Base</tt> if you want to use any other
  # functionality that is not provided by <tt>ActionController::API</tt>
  # out of the box.
  class API < Metal
    abstract!

    # Shortcut helper that returns all the ActionController::API modules except
    # the ones passed as arguments:
    #
    #   class MyAPIBaseController < ActionController::Metal
    #     ActionController::API.without_modules(:ForceSSL, :UrlFor).each do |left|
    #       include left
    #     end
    #   end
    #
    # This gives better control over what you want to exclude and makes it easier
    # to create an API controller class, instead of listing the modules required
    # manually.
    def self.without_modules(*modules)
      modules = modules.map do |m|
        m.is_a?(Symbol) ? ActionController.const_get(m) : m
      end

      MODULES - modules
    end

    MODULES = [
      AbstractController::Rendering,

      UrlFor,
      Redirecting,
      ApiRendering,
      Renderers::All,
      ConditionalGet,
      BasicImplicitRender,
      StrongParameters,

      ForceSSL,
      DataStreaming,

      # Before callbacks should also be executed as early as possible, so
      # also include them at the bottom.
      AbstractController::Callbacks,

      # Append rescue at the bottom to wrap as much as possible.
      Rescue,

      # Add instrumentations hooks at the bottom, to ensure they instrument
      # all the methods properly.
      Instrumentation,

      # Params wrapper should come before instrumentation so they are
      # properly showed in logs
      ParamsWrapper
    ]

    MODULES.each do |mod|
      include mod
    end

    ActiveSupport.run_load_hooks(:action_controller, self)
  end
end
module ActionController
  module ApiRendering
    extend ActiveSupport::Concern

    included do
      include Rendering
    end

    def render_to_body(options = {})
      _process_options(options)
      super
    end
  end
end
require "fileutils"
require "digest/md5"
require "active_support/core_ext/string/strip"
require "rails/version" unless defined?(Rails::VERSION)
require "open-uri"
require "uri"
require "rails/generators"
require "active_support/core_ext/array/extract_options"

module Rails
  module Generators
    class AppBase < Base # :nodoc:
      DATABASES = %w( mysql postgresql sqlite3 oracle frontbase ibm_db sqlserver )
      JDBC_DATABASES = %w( jdbcmysql jdbcsqlite3 jdbcpostgresql jdbc )
      DATABASES.concat(JDBC_DATABASES)

      attr_accessor :rails_template
      add_shebang_option!

      argument :app_path, type: :string

      def self.strict_args_position
        false
      end

      def self.add_shared_options_for(name)
        class_option :template,           type: :string, aliases: "-m",
                                          desc: "Path to some #{name} template (can be a filesystem path or URL)"

        class_option :database,           type: :string, aliases: "-d", default: "sqlite3",
                                          desc: "Preconfigure for selected database (options: #{DATABASES.join('/')})"

        class_option :javascript,         type: :string, aliases: "-j", default: "jquery",
                                          desc: "Preconfigure for selected JavaScript library"

        class_option :skip_gemfile,       type: :boolean, default: false,
                                          desc: "Don't create a Gemfile"

        class_option :skip_bundle,        type: :boolean, aliases: "-B", default: false,
                                          desc: "Don't run bundle install"

        class_option :skip_git,           type: :boolean, aliases: "-G", default: false,
                                          desc: "Skip .gitignore file"

        class_option :skip_keeps,         type: :boolean, default: false,
                                          desc: "Skip source control .keep files"

        class_option :skip_action_mailer, type: :boolean, aliases: "-M",
                                          default: false,
                                          desc: "Skip Action Mailer files"

        class_option :skip_active_record, type: :boolean, aliases: "-O", default: false,
                                          desc: "Skip Active Record files"

        class_option :skip_puma,          type: :boolean, aliases: "-P", default: false,
                                          desc: "Skip Puma related files"

        class_option :skip_action_cable,  type: :boolean, aliases: "-C", default: false,
                                          desc: "Skip Action Cable files"

        class_option :skip_sprockets,     type: :boolean, aliases: "-S", default: false,
                                          desc: "Skip Sprockets files"

        class_option :skip_spring,        type: :boolean, default: false,
                                          desc: "Don't install Spring application preloader"

        class_option :skip_listen,        type: :boolean, default: false,
                                          desc: "Don't generate configuration that depends on the listen gem"

        class_option :skip_javascript,    type: :boolean, aliases: "-J", default: false,
                                          desc: "Skip JavaScript files"

        class_option :skip_turbolinks,    type: :boolean, default: false,
                                          desc: "Skip turbolinks gem"

        class_option :skip_test,          type: :boolean, aliases: "-T", default: false,
                                          desc: "Skip test files"

        class_option :dev,                type: :boolean, default: false,
                                          desc: "Setup the #{name} with Gemfile pointing to your Rails checkout"

        class_option :edge,               type: :boolean, default: false,
                                          desc: "Setup the #{name} with Gemfile pointing to Rails repository"

        class_option :rc,                 type: :string, default: nil,
                                          desc: "Path to file containing extra configuration options for rails command"

        class_option :no_rc,              type: :boolean, default: false,
                                          desc: "Skip loading of extra configuration options from .railsrc file"

        class_option :help,               type: :boolean, aliases: "-h", group: :rails,
                                          desc: "Show this help message and quit"
      end

      def initialize(*args)
        @gem_filter    = lambda { |gem| true }
        @extra_entries = []
        super
        convert_database_option_for_jruby
      end

    protected

      def gemfile_entry(name, *args)
        options = args.extract_options!
        version = args.first
        github = options[:github]
        path   = options[:path]

        if github
          @extra_entries << GemfileEntry.github(name, github)
        elsif path
          @extra_entries << GemfileEntry.path(name, path)
        else
          @extra_entries << GemfileEntry.version(name, version)
        end
        self
      end

      def gemfile_entries
        [rails_gemfile_entry,
         database_gemfile_entry,
         webserver_gemfile_entry,
         assets_gemfile_entry,
         javascript_gemfile_entry,
         jbuilder_gemfile_entry,
         psych_gemfile_entry,
         cable_gemfile_entry,
         @extra_entries].flatten.find_all(&@gem_filter)
      end

      def add_gem_entry_filter
        @gem_filter = lambda { |next_filter, entry|
          yield(entry) && next_filter.call(entry)
        }.curry[@gem_filter]
      end

      def builder
        @builder ||= begin
          builder_class = get_builder_class
          builder_class.include(ActionMethods)
          builder_class.new(self)
        end
      end

      def build(meth, *args)
        builder.send(meth, *args) if builder.respond_to?(meth)
      end

      def create_root
        valid_const?

        empty_directory "."
        FileUtils.cd(destination_root) unless options[:pretend]
      end

      def apply_rails_template
        apply rails_template if rails_template
      rescue Thor::Error, LoadError, Errno::ENOENT => e
        raise Error, "The template [#{rails_template}] could not be loaded. Error: #{e}"
      end

      def set_default_accessors!
        self.destination_root = File.expand_path(app_path, destination_root)
        self.rails_template = case options[:template]
                              when /^https?:\/\//
                                options[:template]
                              when String
                                File.expand_path(options[:template], Dir.pwd)
          else
                                options[:template]
        end
      end

      def database_gemfile_entry
        return [] if options[:skip_active_record]
        gem_name, gem_version = gem_for_database
        GemfileEntry.version gem_name, gem_version,
                            "Use #{options[:database]} as the database for Active Record"
      end

      def webserver_gemfile_entry
        return [] if options[:skip_puma]
        comment = "Use Puma as the app server"
        GemfileEntry.new("puma", "~> 3.0", comment)
      end

      def include_all_railties?
        options.values_at(:skip_active_record, :skip_action_mailer, :skip_test, :skip_sprockets, :skip_action_cable).none?
      end

      def comment_if(value)
        options[value] ? "# " : ""
      end

      def keeps?
        !options[:skip_keeps]
      end

      def sqlite3?
        !options[:skip_active_record] && options[:database] == "sqlite3"
      end

      class GemfileEntry < Struct.new(:name, :version, :comment, :options, :commented_out)
        def initialize(name, version, comment, options = {}, commented_out = false)
          super
        end

        def self.github(name, github, branch = nil, comment = nil)
          if branch
            new(name, nil, comment, github: github, branch: branch)
          else
            new(name, nil, comment, github: github)
          end
        end

        def self.version(name, version, comment = nil)
          new(name, version, comment)
        end

        def self.path(name, path, comment = nil)
          new(name, nil, comment, path: path)
        end

        def version
          version = super

          if version.is_a?(Array)
            version.join("', '")
          else
            version
          end
        end
      end

      def rails_gemfile_entry
        dev_edge_common = [
        ]
        if options.dev?
          [
            GemfileEntry.path("rails", Rails::Generators::RAILS_DEV_PATH)
          ] + dev_edge_common
        elsif options.edge?
          [
            GemfileEntry.github("rails", "rails/rails", "5-0-stable")
          ] + dev_edge_common
        else
          [GemfileEntry.version("rails",
                            rails_version_specifier,
                            "Bundle edge Rails instead: gem 'rails', github: 'rails/rails'")]
        end
      end

      def rails_version_specifier(gem_version = Rails.gem_version)
        if gem_version.prerelease?
          next_series = gem_version
          next_series = next_series.bump while next_series.segments.size > 2

          [">= #{gem_version}", "< #{next_series}"]
        elsif gem_version.segments.size == 3
          "~> #{gem_version}"
        else
          patch = gem_version.segments[0, 3].join(".")
          ["~> #{patch}", ">= #{gem_version}"]
        end
      end

      def gem_for_database
        # %w( mysql postgresql sqlite3 oracle frontbase ibm_db sqlserver jdbcmysql jdbcsqlite3 jdbcpostgresql )
        case options[:database]
        when "mysql"          then ["mysql2", [">= 0.3.18", "< 0.5"]]
        when "postgresql"     then ["pg", ["~> 0.18"]]
        when "oracle"         then ["ruby-oci8", nil]
        when "frontbase"      then ["ruby-frontbase", nil]
        when "sqlserver"      then ["activerecord-sqlserver-adapter", nil]
        when "jdbcmysql"      then ["activerecord-jdbcmysql-adapter", nil]
        when "jdbcsqlite3"    then ["activerecord-jdbcsqlite3-adapter", nil]
        when "jdbcpostgresql" then ["activerecord-jdbcpostgresql-adapter", nil]
        when "jdbc"           then ["activerecord-jdbc-adapter", nil]
        else [options[:database], nil]
        end
      end

      def convert_database_option_for_jruby
        if defined?(JRUBY_VERSION)
          case options[:database]
          when "postgresql" then options[:database].replace "jdbcpostgresql"
          when "mysql"      then options[:database].replace "jdbcmysql"
          when "oracle"     then options[:database].replace "jdbc"
          when "sqlite3"    then options[:database].replace "jdbcsqlite3"
          end
        end
      end

      def assets_gemfile_entry
        return [] if options[:skip_sprockets]

        gems = []
        gems << GemfileEntry.github("sass-rails", "rails/sass-rails", nil,
                                     "Use SCSS for stylesheets")

        if !options[:skip_javascript]
          gems << GemfileEntry.version("uglifier",
                                     ">= 1.3.0",
                                     "Use Uglifier as compressor for JavaScript assets")
        end

        gems
      end

      def jbuilder_gemfile_entry
        comment = "Build JSON APIs with ease. Read more: https://github.com/rails/jbuilder"
        GemfileEntry.new "jbuilder", "~> 2.5", comment, {}, options[:api]
      end

      def coffee_gemfile_entry
        GemfileEntry.version "coffee-rails", "~> 4.2", "Use CoffeeScript for .coffee assets and views"
      end

      def javascript_gemfile_entry
        if options[:skip_javascript] || options[:skip_sprockets]
          []
        else
          gems = [coffee_gemfile_entry, javascript_runtime_gemfile_entry]
          gems << GemfileEntry.version("#{options[:javascript]}-rails", nil,
                                       "Use #{options[:javascript]} as the JavaScript library")

          unless options[:skip_turbolinks]
            gems << GemfileEntry.version("turbolinks", "~> 5",
             "Turbolinks makes navigating your web application faster. Read more: https://github.com/turbolinks/turbolinks")
          end

          gems
        end
      end

      def javascript_runtime_gemfile_entry
        comment = "See https://github.com/rails/execjs#readme for more supported runtimes"
        if defined?(JRUBY_VERSION)
          GemfileEntry.version "therubyrhino", nil, comment
        else
          GemfileEntry.new "therubyracer", nil, comment, { platforms: :ruby }, true
        end
      end

      def psych_gemfile_entry
        return [] unless defined?(Rubinius)

        comment = "Use Psych as the YAML engine, instead of Syck, so serialized " \
                  "data can be read safely from different rubies (see http://git.io/uuLVag)"
        GemfileEntry.new("psych", "~> 2.0", comment, platforms: :rbx)
      end

      def cable_gemfile_entry
        return [] if options[:skip_action_cable]
        comment = "Use Redis adapter to run Action Cable in production"
        gems = []
        gems << GemfileEntry.new("redis", "~> 3.0", comment, {}, true)
        gems
      end

      def bundle_command(command)
        say_status :run, "bundle #{command}"

        # We are going to shell out rather than invoking Bundler::CLI.new(command)
        # because `rails new` loads the Thor gem and on the other hand bundler uses
        # its own vendored Thor, which could be a different version. Running both
        # things in the same process is a recipe for a night with paracetamol.
        #
        # We unset temporary bundler variables to load proper bundler and Gemfile.
        #
        # Thanks to James Tucker for the Gem tricks involved in this call.
        _bundle_command = Gem.bin_path("bundler", "bundle")

        require "bundler"
        Bundler.with_clean_env do
          full_command = %Q["#{Gem.ruby}" "#{_bundle_command}" #{command}]
          if options[:quiet]
            system(full_command, out: File::NULL)
          else
            system(full_command)
          end
        end
      end

      def bundle_install?
        !(options[:skip_gemfile] || options[:skip_bundle] || options[:pretend])
      end

      def spring_install?
        !options[:skip_spring] && !options.dev? && Process.respond_to?(:fork) && !RUBY_PLATFORM.include?("cygwin")
      end

      def depend_on_listen?
        !options[:skip_listen] && os_supports_listen_out_of_the_box?
      end

      def os_supports_listen_out_of_the_box?
        RbConfig::CONFIG["host_os"] =~ /darwin|linux/
      end

      def run_bundle
        bundle_command("install") if bundle_install?
      end

      def generate_spring_binstubs
        if bundle_install? && spring_install?
          bundle_command("exec spring binstub --all")
        end
      end

      def empty_directory_with_keep_file(destination, config = {})
        empty_directory(destination, config)
        keep_file(destination)
      end

      def keep_file(destination)
        create_file("#{destination}/.keep") if keeps?
      end
    end
  end
end
require "rails/generators/app_base"

module Rails
  module ActionMethods # :nodoc:
    attr_reader :options

    def initialize(generator)
      @generator = generator
      @options   = generator.options
    end

    private
      %w(template copy_file directory empty_directory inside
         empty_directory_with_keep_file create_file chmod shebang).each do |method|
        class_eval <<-RUBY, __FILE__, __LINE__ + 1
          def #{method}(*args, &block)
            @generator.send(:#{method}, *args, &block)
          end
        RUBY
      end

      # TODO: Remove once this is fully in place
      def method_missing(meth, *args, &block)
        @generator.send(meth, *args, &block)
      end
  end

  # The application builder allows you to override elements of the application
  # generator without being forced to reverse the operations of the default
  # generator.
  #
  # This allows you to override entire operations, like the creation of the
  # Gemfile, README, or JavaScript files, without needing to know exactly
  # what those operations do so you can create another template action.
  class AppBuilder
    def rakefile
      template "Rakefile"
    end

    def readme
      copy_file "README.md", "README.md"
    end

    def gemfile
      template "Gemfile"
    end

    def configru
      template "config.ru"
    end

    def gitignore
      template "gitignore", ".gitignore"
    end

    def app
      directory "app"

      keep_file  "app/assets/images"
      empty_directory_with_keep_file "app/assets/javascripts/channels" unless options[:skip_action_cable]

      keep_file  "app/controllers/concerns"
      keep_file  "app/models/concerns"
    end

    def bin
      directory "bin" do |content|
        "#{shebang}\n" + content
      end
      chmod "bin", 0755 & ~File.umask, verbose: false
    end

    def config
      empty_directory "config"

      inside "config" do
        template "routes.rb"
        template "application.rb"
        template "environment.rb"
        template "secrets.yml"
        template "cable.yml" unless options[:skip_action_cable]
        template "puma.rb"   unless options[:skip_puma]
        template "spring.rb" if spring_install?

        directory "environments"
        directory "initializers"
        directory "locales"
      end
    end

    def config_when_updating
      cookie_serializer_config_exist = File.exist?("config/initializers/cookies_serializer.rb")
      action_cable_config_exist = File.exist?("config/cable.yml")
      rack_cors_config_exist = File.exist?("config/initializers/cors.rb")

      config

      gsub_file "config/environments/development.rb", /^(\s+)config\.file_watcher/, '\1# config.file_watcher'

      unless cookie_serializer_config_exist
        gsub_file "config/initializers/cookies_serializer.rb", /json(?!,)/, "marshal"
      end

      unless action_cable_config_exist
        template "config/cable.yml"
      end

      unless rack_cors_config_exist
        remove_file "config/initializers/cors.rb"
      end
    end

    def database_yml
      template "config/databases/#{options[:database]}.yml", "config/database.yml"
    end

    def db
      directory "db"
    end

    def lib
      empty_directory "lib"
      empty_directory_with_keep_file "lib/tasks"
      empty_directory_with_keep_file "lib/assets"
    end

    def log
      empty_directory_with_keep_file "log"
    end

    def public_directory
      directory "public", "public", recursive: false
    end

    def test
      empty_directory_with_keep_file "test/fixtures"
      empty_directory_with_keep_file "test/fixtures/files"
      empty_directory_with_keep_file "test/controllers"
      empty_directory_with_keep_file "test/mailers"
      empty_directory_with_keep_file "test/models"
      empty_directory_with_keep_file "test/helpers"
      empty_directory_with_keep_file "test/integration"

      template "test/test_helper.rb"
    end

    def tmp
      empty_directory_with_keep_file "tmp"
      empty_directory "tmp/cache"
      empty_directory "tmp/cache/assets"
    end

    def vendor
      vendor_javascripts
      vendor_stylesheets
    end

    def vendor_javascripts
      unless options[:skip_javascript]
        empty_directory_with_keep_file "vendor/assets/javascripts"
      end
    end

    def vendor_stylesheets
      empty_directory_with_keep_file "vendor/assets/stylesheets"
    end
  end

  module Generators
    # We need to store the RAILS_DEV_PATH in a constant, otherwise the path
    # can change in Ruby 1.8.7 when we FileUtils.cd.
    RAILS_DEV_PATH = File.expand_path("../../../../../..", File.dirname(__FILE__))
    RESERVED_NAMES = %w[application destroy plugin runner test]

    class AppGenerator < AppBase # :nodoc:
      add_shared_options_for "application"

      # Add bin/rails options
      class_option :version, type: :boolean, aliases: "-v", group: :rails,
                             desc: "Show Rails version number and quit"

      class_option :api, type: :boolean,
                         desc: "Preconfigure smaller stack for API only apps"

      def initialize(*args)
        super

        unless app_path
          raise Error, "Application name should be provided in arguments. For details run: rails --help"
        end

        if !options[:skip_active_record] && !DATABASES.include?(options[:database])
          raise Error, "Invalid value for --database option. Supported for preconfiguration are: #{DATABASES.join(", ")}."
        end

        # Force sprockets to be skipped when generating API only apps.
        # Can't modify options hash as it's frozen by default.
        self.options = options.merge(skip_sprockets: true, skip_javascript: true).freeze if options[:api]
      end

      public_task :set_default_accessors!
      public_task :create_root

      def create_root_files
        build(:readme)
        build(:rakefile)
        build(:configru)
        build(:gitignore) unless options[:skip_git]
        build(:gemfile)   unless options[:skip_gemfile]
      end

      def create_app_files
        build(:app)
      end

      def create_bin_files
        build(:bin)
      end

      def create_config_files
        build(:config)
      end

      def update_config_files
        build(:config_when_updating)
      end
      remove_task :update_config_files

      def display_upgrade_guide_info
        say "\nAfter this, check Rails upgrade guide at http://guides.rubyonrails.org/upgrading_ruby_on_rails.html for more details about upgrading your app."
      end
      remove_task :display_upgrade_guide_info

      def create_boot_file
        template "config/boot.rb"
      end

      def create_active_record_files
        return if options[:skip_active_record]
        build(:database_yml)
      end

      def create_db_files
        build(:db)
      end

      def create_lib_files
        build(:lib)
      end

      def create_log_files
        build(:log)
      end

      def create_public_files
        build(:public_directory)
      end

      def create_test_files
        build(:test) unless options[:skip_test]
      end

      def create_tmp_files
        build(:tmp)
      end

      def create_vendor_files
        build(:vendor)
      end

      def delete_app_assets_if_api_option
        if options[:api]
          remove_dir "app/assets"
          remove_dir "lib/assets"
          remove_dir "tmp/cache/assets"
          remove_dir "vendor/assets"
        end
      end

      def delete_app_helpers_if_api_option
        if options[:api]
          remove_dir "app/helpers"
          remove_dir "test/helpers"
        end
      end

      def delete_application_layout_file_if_api_option
        if options[:api]
          remove_file "app/views/layouts/application.html.erb"
        end
      end

      def delete_public_files_if_api_option
        if options[:api]
          remove_file "public/404.html"
          remove_file "public/422.html"
          remove_file "public/500.html"
          remove_file "public/apple-touch-icon-precomposed.png"
          remove_file "public/apple-touch-icon.png"
          remove_file "public/favicon.ico"
        end
      end

      def delete_js_folder_skipping_javascript
        if options[:skip_javascript]
          remove_dir "app/assets/javascripts"
        end
      end

      def delete_assets_initializer_skipping_sprockets
        if options[:skip_sprockets]
          remove_file "config/initializers/assets.rb"
        end
      end

      def delete_application_record_skipping_active_record
        if options[:skip_active_record]
          remove_file "app/models/application_record.rb"
        end
      end

      def delete_action_mailer_files_skipping_action_mailer
        if options[:skip_action_mailer]
          remove_file "app/mailers/application_mailer.rb"
          remove_file "app/views/layouts/mailer.html.erb"
          remove_file "app/views/layouts/mailer.text.erb"
        end
      end

      def delete_action_cable_files_skipping_action_cable
        if options[:skip_action_cable]
          remove_file "config/cable.yml"
          remove_file "app/assets/javascripts/cable.js"
          remove_dir "app/channels"
        end
      end

      def delete_non_api_initializers_if_api_option
        if options[:api]
          remove_file "config/initializers/cookies_serializer.rb"
        end
      end

      def delete_api_initializers
        unless options[:api]
          remove_file "config/initializers/cors.rb"
        end
      end

      def finish_template
        build(:leftovers)
      end

      public_task :apply_rails_template, :run_bundle
      public_task :generate_spring_binstubs

      def run_after_bundle_callbacks
        @after_bundle_callbacks.each(&:call)
      end

    protected

      def self.banner
        "rails new #{arguments.map(&:usage).join(' ')} [options]"
      end

      # Define file as an alias to create_file for backwards compatibility.
      def file(*args, &block)
        create_file(*args, &block)
      end

      def app_name
        @app_name ||= (defined_app_const_base? ? defined_app_name : File.basename(destination_root)).tr('\\', "").tr(". ", "_")
      end

      def defined_app_name
        defined_app_const_base.underscore
      end

      def defined_app_const_base
        Rails.respond_to?(:application) && defined?(Rails::Application) &&
          Rails.application.is_a?(Rails::Application) && Rails.application.class.name.sub(/::Application$/, "")
      end

      alias :defined_app_const_base? :defined_app_const_base

      def app_const_base
        @app_const_base ||= defined_app_const_base || app_name.gsub(/\W/, "_").squeeze("_").camelize
      end
      alias :camelized :app_const_base

      def app_const
        @app_const ||= "#{app_const_base}::Application"
      end

      def valid_const?
        if app_const =~ /^\d/
          raise Error, "Invalid application name #{app_name}. Please give a name which does not start with numbers."
        elsif RESERVED_NAMES.include?(app_name)
          raise Error, "Invalid application name #{app_name}. Please give a " \
                       "name which does not match one of the reserved rails " \
                       "words: #{RESERVED_NAMES.join(", ")}"
        elsif Object.const_defined?(app_const_base)
          raise Error, "Invalid application name #{app_name}, constant #{app_const_base} is already in use. Please choose another application name."
        end
      end

      def app_secret
        SecureRandom.hex(64)
      end

      def mysql_socket
        @mysql_socket ||= [
          "/tmp/mysql.sock",                        # default
          "/var/run/mysqld/mysqld.sock",            # debian/gentoo
          "/var/tmp/mysql.sock",                    # freebsd
          "/var/lib/mysql/mysql.sock",              # fedora
          "/opt/local/lib/mysql/mysql.sock",        # fedora
          "/opt/local/var/run/mysqld/mysqld.sock",  # mac + darwinports + mysql
          "/opt/local/var/run/mysql4/mysqld.sock",  # mac + darwinports + mysql4
          "/opt/local/var/run/mysql5/mysqld.sock",  # mac + darwinports + mysql5
          "/opt/lampp/var/mysql/mysql.sock"         # xampp for linux
        ].find { |f| File.exist?(f) } unless RbConfig::CONFIG["host_os"] =~ /mswin|mingw/
      end

      def get_builder_class
        defined?(::AppBuilder) ? ::AppBuilder : Rails::AppBuilder
      end
    end

    # This class handles preparation of the arguments before the AppGenerator is
    # called. The class provides version or help information if they were
    # requested, and also constructs the railsrc file (used for extra configuration
    # options).
    #
    # This class should be called before the AppGenerator is required and started
    # since it configures and mutates ARGV correctly.
    class ARGVScrubber # :nodoc:
      def initialize(argv = ARGV)
        @argv = argv
      end

      def prepare!
        handle_version_request!(@argv.first)
        handle_invalid_command!(@argv.first, @argv) do
          handle_rails_rc!(@argv.drop(1))
        end
      end

      def self.default_rc_file
        File.expand_path("~/.railsrc")
      end

      private

        def handle_version_request!(argument)
          if ["--version", "-v"].include?(argument)
            require "rails/version"
            puts "Rails #{Rails::VERSION::STRING}"
            exit(0)
          end
        end

        def handle_invalid_command!(argument, argv)
          if argument == "new"
            yield
          else
            ["--help"] + argv.drop(1)
          end
        end

        def handle_rails_rc!(argv)
          if argv.find { |arg| arg == "--no-rc" }
            argv.reject { |arg| arg == "--no-rc" }
          else
            railsrc(argv) { |rc_argv, rc| insert_railsrc_into_argv!(rc_argv, rc) }
          end
        end

        def railsrc(argv)
          if (customrc = argv.index{ |x| x.include?("--rc=") })
            fname = File.expand_path(argv[customrc].gsub(/--rc=/, ""))
            yield(argv.take(customrc) + argv.drop(customrc + 1), fname)
          else
            yield argv, self.class.default_rc_file
          end
        end

        def read_rc_file(railsrc)
          extra_args = File.readlines(railsrc).flat_map(&:split)
          puts "Using #{extra_args.join(" ")} from #{railsrc}"
          extra_args
        end

        def insert_railsrc_into_argv!(argv, railsrc)
          return argv unless File.exist?(railsrc)
          extra_args = read_rc_file railsrc
          argv.take(1) + extra_args + argv.drop(1)
        end
    end
  end
end
require "generators/generators_test_helper"
require "rails/generators/rails/app/app_generator"
require "generators/shared_generator_tests"

DEFAULT_APP_FILES = %w(
  .gitignore
  README.md
  Gemfile
  Rakefile
  config.ru
  app/assets/javascripts
  app/assets/stylesheets
  app/assets/images
  app/controllers
  app/controllers/concerns
  app/helpers
  app/mailers
  app/models
  app/models/concerns
  app/jobs
  app/views/layouts
  bin/bundle
  bin/rails
  bin/rake
  bin/setup
  config/environments
  config/initializers
  config/locales
  config/cable.yml
  config/puma.rb
  config/spring.rb
  db
  lib
  lib/tasks
  lib/assets
  log
  test/test_helper.rb
  test/fixtures
  test/fixtures/files
  test/controllers
  test/models
  test/helpers
  test/mailers
  test/integration
  vendor
  vendor/assets
  vendor/assets/stylesheets
  vendor/assets/javascripts
  tmp
  tmp/cache
  tmp/cache/assets
)

class AppGeneratorTest < Rails::Generators::TestCase
  include GeneratorsTestHelper
  arguments [destination_root]

  # brings setup, teardown, and some tests
  include SharedGeneratorTests

  def default_files
    ::DEFAULT_APP_FILES
  end

  def test_assets
    run_generator

    assert_file("app/views/layouts/application.html.erb", /stylesheet_link_tag\s+'application', media: 'all', 'data-turbolinks-track': 'reload'/)
    assert_file("app/views/layouts/application.html.erb", /javascript_include_tag\s+'application', 'data-turbolinks-track': 'reload'/)
    assert_file("app/assets/stylesheets/application.css")
    assert_file("app/assets/javascripts/application.js")
  end

  def test_application_job_file_present
    run_generator
    assert_file("app/jobs/application_job.rb")
  end

  def test_invalid_application_name_raises_an_error
    content = capture(:stderr){ run_generator [File.join(destination_root, "43-things")] }
    assert_equal "Invalid application name 43-things. Please give a name which does not start with numbers.\n", content
  end

  def test_invalid_application_name_is_fixed
    run_generator [File.join(destination_root, "things-43")]
    assert_file "things-43/config/environment.rb", /Rails\.application\.initialize!/
    assert_file "things-43/config/application.rb", /^module Things43$/
  end

  def test_application_new_exits_with_non_zero_code_on_invalid_application_name
    quietly { system "rails new test --no-rc" }
    assert_equal false, $?.success?
  end

  def test_application_new_exits_with_message_and_non_zero_code_when_generating_inside_existing_rails_directory
    app_root = File.join(destination_root, "myfirstapp")
    run_generator [app_root]
    output = nil
    Dir.chdir(app_root) do
      output = `rails new mysecondapp`
    end
    assert_equal "Can't initialize a new Rails application within the directory of another, please change to a non-Rails directory first.\nType 'rails' for help.\n", output
    assert_equal false, $?.success?
  end

  def test_application_new_show_help_message_inside_existing_rails_directory
    app_root = File.join(destination_root, "myfirstapp")
    run_generator [app_root]
    output = Dir.chdir(app_root) do
      `rails new --help`
    end
    assert_match(/rails new APP_PATH \[options\]/, output)
    assert_equal true, $?.success?
  end

  def test_application_name_is_detected_if_it_exists_and_app_folder_renamed
    app_root       = File.join(destination_root, "myapp")
    app_moved_root = File.join(destination_root, "myapp_moved")

    run_generator [app_root]

    stub_rails_application(app_moved_root) do
      Rails.application.stub(:is_a?, -> *args { Rails::Application }) do
        FileUtils.mv(app_root, app_moved_root)

        # make sure we are in correct dir
        FileUtils.cd(app_moved_root)

        generator = Rails::Generators::AppGenerator.new ["rails"], [],
                                                                   destination_root: app_moved_root, shell: @shell
        generator.send(:app_const)
        quietly { generator.send(:update_config_files) }
        assert_file "myapp_moved/config/environment.rb", /Rails\.application\.initialize!/
      end
    end
  end

  def test_rails_update_generates_correct_session_key
    app_root = File.join(destination_root, "myapp")
    run_generator [app_root]

    stub_rails_application(app_root) do
      generator = Rails::Generators::AppGenerator.new ["rails"], [], destination_root: app_root, shell: @shell
      generator.send(:app_const)
      quietly { generator.send(:update_config_files) }
    end
  end

  def test_new_application_use_json_serialzier
    run_generator

    assert_file("config/initializers/cookies_serializer.rb", /Rails\.application\.config\.action_dispatch\.cookies_serializer = :json/)
  end

  def test_new_application_not_include_api_initializers
    run_generator

    assert_no_file "config/initializers/cors.rb"
  end

  def test_rails_update_keep_the_cookie_serializer_if_it_is_already_configured
    app_root = File.join(destination_root, "myapp")
    run_generator [app_root]

    stub_rails_application(app_root) do
      generator = Rails::Generators::AppGenerator.new ["rails"], [], destination_root: app_root, shell: @shell
      generator.send(:app_const)
      quietly { generator.send(:update_config_files) }
      assert_file("#{app_root}/config/initializers/cookies_serializer.rb", /Rails\.application\.config\.action_dispatch\.cookies_serializer = :json/)
    end
  end

  def test_rails_update_set_the_cookie_serializer_to_marshal_if_it_is_not_already_configured
    app_root = File.join(destination_root, "myapp")
    run_generator [app_root]

    FileUtils.rm("#{app_root}/config/initializers/cookies_serializer.rb")

    stub_rails_application(app_root) do
      generator = Rails::Generators::AppGenerator.new ["rails"], [], destination_root: app_root, shell: @shell
      generator.send(:app_const)
      quietly { generator.send(:update_config_files) }
      assert_file("#{app_root}/config/initializers/cookies_serializer.rb",
                  /Valid options are :json, :marshal, and :hybrid\.\nRails\.application\.config\.action_dispatch\.cookies_serializer = :marshal/)
    end
  end

  def test_rails_update_dont_set_file_watcher
    app_root = File.join(destination_root, "myapp")
    run_generator [app_root]

    stub_rails_application(app_root) do
      generator = Rails::Generators::AppGenerator.new ["rails"], [], destination_root: app_root, shell: @shell
      generator.send(:app_const)
      quietly { generator.send(:update_config_files) }
      assert_file "#{app_root}/config/environments/development.rb" do |content|
        assert_match(/# config.file_watcher/, content)
      end
    end
  end

  def test_rails_update_does_not_create_new_framework_defaults_by_default
    app_root = File.join(destination_root, "myapp")
    run_generator [app_root]

    FileUtils.rm("#{app_root}/config/initializers/new_framework_defaults.rb")

    stub_rails_application(app_root) do
      generator = Rails::Generators::AppGenerator.new ["rails"], { update: true }, destination_root: app_root, shell: @shell
      generator.send(:app_const)
      quietly { generator.send(:update_config_files) }

      assert_file "#{app_root}/config/initializers/new_framework_defaults.rb" do |content|
        assert_match(/ActiveSupport\.halt_callback_chains_on_return_false = true/, content)
        assert_match(/Rails\.application\.config.active_record\.belongs_to_required_by_default = false/, content)
        assert_no_match(/Rails\.application\.config\.ssl_options/, content)
      end
    end
  end

  def test_rails_update_does_not_create_rack_cors
    app_root = File.join(destination_root, "myapp")
    run_generator [app_root]

    stub_rails_application(app_root) do
      generator = Rails::Generators::AppGenerator.new ["rails"], [], destination_root: app_root, shell: @shell
      generator.send(:app_const)
      quietly { generator.send(:update_config_files) }
      assert_no_file "#{app_root}/config/initializers/cors.rb"
    end
  end

  def test_rails_update_does_not_remove_rack_cors_if_already_present
    app_root = File.join(destination_root, "myapp")
    run_generator [app_root]

    FileUtils.touch("#{app_root}/config/initializers/cors.rb")

    stub_rails_application(app_root) do
      generator = Rails::Generators::AppGenerator.new ["rails"], [], destination_root: app_root, shell: @shell
      generator.send(:app_const)
      quietly { generator.send(:update_config_files) }
      assert_file "#{app_root}/config/initializers/cors.rb"
    end
  end

  def test_application_names_are_not_singularized
    run_generator [File.join(destination_root, "hats")]
    assert_file "hats/config/environment.rb", /Rails\.application\.initialize!/
  end

  def test_gemfile_has_no_whitespace_errors
    run_generator
    absolute = File.expand_path("Gemfile", destination_root)
    File.open(absolute, "r") do |f|
      f.each_line do |line|
        assert_no_match %r{/^[ \t]+$/}, line
      end
    end
  end

  def test_config_database_is_added_by_default
    run_generator
    assert_file "config/database.yml", /sqlite3/
    if defined?(JRUBY_VERSION)
      assert_gem "activerecord-jdbcsqlite3-adapter"
    else
      assert_gem "sqlite3"
    end
  end

  def test_config_another_database
    run_generator([destination_root, "-d", "mysql"])
    assert_file "config/database.yml", /mysql/
    if defined?(JRUBY_VERSION)
      assert_gem "activerecord-jdbcmysql-adapter"
    else
      assert_gem "mysql2", "'>= 0.3.18', '< 0.5'"
    end
  end

  def test_config_database_app_name_with_period
    run_generator [File.join(destination_root, "common.usage.com"), "-d", "postgresql"]
    assert_file "common.usage.com/config/database.yml", /common_usage_com/
  end

  def test_config_postgresql_database
    run_generator([destination_root, "-d", "postgresql"])
    assert_file "config/database.yml", /postgresql/
    if defined?(JRUBY_VERSION)
      assert_gem "activerecord-jdbcpostgresql-adapter"
    else
      assert_gem "pg", "'~> 0.18'"
    end
  end

  def test_config_jdbcmysql_database
    run_generator([destination_root, "-d", "jdbcmysql"])
    assert_file "config/database.yml", /mysql/
    assert_gem "activerecord-jdbcmysql-adapter"
  end

  def test_config_jdbcsqlite3_database
    run_generator([destination_root, "-d", "jdbcsqlite3"])
    assert_file "config/database.yml", /sqlite3/
    assert_gem "activerecord-jdbcsqlite3-adapter"
  end

  def test_config_jdbcpostgresql_database
    run_generator([destination_root, "-d", "jdbcpostgresql"])
    assert_file "config/database.yml", /postgresql/
    assert_gem "activerecord-jdbcpostgresql-adapter"
  end

  def test_config_jdbc_database
    run_generator([destination_root, "-d", "jdbc"])
    assert_file "config/database.yml", /jdbc/
    assert_file "config/database.yml", /mssql/
    assert_gem "activerecord-jdbc-adapter"
  end

  if defined?(JRUBY_VERSION)
    def test_config_jdbc_database_when_no_option_given
      run_generator
      assert_file "config/database.yml", /sqlite3/
      assert_gem "activerecord-jdbcsqlite3-adapter"
    end
  end

  def test_generator_without_skips
    run_generator
    assert_file "config/application.rb", /\s+require\s+["']rails\/all["']/
    assert_file "config/environments/development.rb" do |content|
      assert_match(/config\.action_mailer\.raise_delivery_errors = false/, content)
    end
    assert_file "config/environments/test.rb" do |content|
      assert_match(/config\.action_mailer\.delivery_method = :test/, content)
    end
    assert_file "config/environments/production.rb" do |content|
      assert_match(/# config\.action_mailer\.raise_delivery_errors = false/, content)
    end
  end

  def test_generator_defaults_to_puma_version
    run_generator [destination_root]
    assert_gem "puma", "'~> 3.0'"
  end

  def test_generator_if_skip_puma_is_given
    run_generator [destination_root, "--skip-puma"]
    assert_no_file "config/puma.rb"
    assert_file "Gemfile" do |content|
      assert_no_match(/puma/, content)
    end
  end

  def test_generator_if_skip_active_record_is_given
    run_generator [destination_root, "--skip-active-record"]
    assert_no_file "config/database.yml"
    assert_no_file "app/models/application_record.rb"
    assert_file "config/application.rb", /#\s+require\s+["']active_record\/railtie["']/
    assert_file "test/test_helper.rb" do |helper_content|
      assert_no_match(/fixtures :all/, helper_content)
    end

    assert_file "config/initializers/new_framework_defaults.rb" do |initializer_content|
      assert_no_match(/belongs_to_required_by_default/, initializer_content)
    end
  end

  def test_generator_if_skip_action_mailer_is_given
    run_generator [destination_root, "--skip-action-mailer"]
    assert_file "config/application.rb", /#\s+require\s+["']action_mailer\/railtie["']/
    assert_file "config/environments/development.rb" do |content|
      assert_no_match(/config\.action_mailer/, content)
    end
    assert_file "config/environments/test.rb" do |content|
      assert_no_match(/config\.action_mailer/, content)
    end
    assert_file "config/environments/production.rb" do |content|
      assert_no_match(/config\.action_mailer/, content)
    end
  end

  def test_generator_has_assets_gems
    run_generator

    assert_gem "sass-rails"
    assert_gem "uglifier"
  end

  def test_generator_if_skip_sprockets_is_given
    run_generator [destination_root, "--skip-sprockets"]
    assert_no_file "config/initializers/assets.rb"
    assert_file "config/application.rb" do |content|
      assert_match(/#\s+require\s+["']sprockets\/railtie["']/, content)
    end
    assert_file "Gemfile" do |content|
      assert_no_match(/jquery-rails/, content)
      assert_no_match(/sass-rails/, content)
      assert_no_match(/uglifier/, content)
      assert_no_match(/coffee-rails/, content)
    end
    assert_file "config/environments/development.rb" do |content|
      assert_no_match(/config\.assets\.debug = true/, content)
    end
    assert_file "config/environments/production.rb" do |content|
      assert_no_match(/config\.assets\.digest = true/, content)
      assert_no_match(/config\.assets\.js_compressor = :uglifier/, content)
      assert_no_match(/config\.assets\.css_compressor = :sass/, content)
    end
  end

  def test_generator_if_skip_action_cable_is_given
    run_generator [destination_root, "--skip-action-cable"]
    assert_file "config/application.rb", /#\s+require\s+["']action_cable\/engine["']/
    assert_no_file "config/cable.yml"
    assert_no_file "app/assets/javascripts/cable.js"
    assert_no_file "app/channels"
    assert_file "Gemfile" do |content|
      assert_no_match(/redis/, content)
    end
  end

  def test_action_cable_redis_gems
    run_generator
    assert_file "Gemfile", /^# gem 'redis'/
  end

  def test_inclusion_of_javascript_runtime
    run_generator
    if defined?(JRUBY_VERSION)
      assert_gem "therubyrhino"
    else
      assert_file "Gemfile", /# gem 'therubyracer', platforms: :ruby/
    end
  end

  def test_jquery_is_the_default_javascript_library
    run_generator
    assert_file "app/assets/javascripts/application.js" do |contents|
      assert_match %r{^//= require jquery}, contents
      assert_match %r{^//= require jquery_ujs}, contents
    end
    assert_gem "jquery-rails"
  end

  def test_other_javascript_libraries
    run_generator [destination_root, "-j", "prototype"]
    assert_file "app/assets/javascripts/application.js" do |contents|
      assert_match %r{^//= require prototype}, contents
      assert_match %r{^//= require prototype_ujs}, contents
    end
    assert_gem "prototype-rails"
  end

  def test_javascript_is_skipped_if_required
    run_generator [destination_root, "--skip-javascript"]

    assert_no_file "app/assets/javascripts"
    assert_no_file "vendor/assets/javascripts"

    assert_file "app/views/layouts/application.html.erb" do |contents|
      assert_match(/stylesheet_link_tag\s+'application', media: 'all' %>/, contents)
      assert_no_match(/javascript_include_tag\s+'application' \%>/, contents)
    end

    assert_file "Gemfile" do |content|
      assert_no_match(/coffee-rails/, content)
      assert_no_match(/jquery-rails/, content)
      assert_no_match(/uglifier/, content)
    end

    assert_file "config/environments/production.rb" do |content|
      assert_no_match(/config\.assets\.js_compressor = :uglifier/, content)
    end
  end

  def test_inclusion_of_jbuilder
    run_generator
    assert_gem "jbuilder"
  end

  def test_inclusion_of_a_debugger
    run_generator
    if defined?(JRUBY_VERSION) || RUBY_ENGINE == "rbx"
      assert_file "Gemfile" do |content|
        assert_no_match(/byebug/, content)
      end
    else
      assert_gem "byebug"
    end
  end

  def test_inclusion_of_listen_related_configuration_by_default
    run_generator
    if RbConfig::CONFIG["host_os"] =~ /darwin|linux/
      assert_listen_related_configuration
    else
      assert_no_listen_related_configuration
    end
  end

  def test_non_inclusion_of_listen_related_configuration_if_skip_listen
    run_generator [destination_root, "--skip-listen"]
    assert_no_listen_related_configuration
  end

  def test_evented_file_update_checker_config
    run_generator
    assert_file "config/environments/development.rb" do |content|
      if RbConfig::CONFIG["host_os"] =~ /darwin|linux/
        assert_match(/^\s*config.file_watcher = ActiveSupport::EventedFileUpdateChecker/, content)
      else
        assert_match(/^\s*# config.file_watcher = ActiveSupport::EventedFileUpdateChecker/, content)
      end
    end
  end

  def test_template_from_dir_pwd
    FileUtils.cd(Rails.root)
    assert_match(/It works from file!/, run_generator([destination_root, "-m", "lib/template.rb"]))
  end

  def test_usage_read_from_file
    assert_called(File, :read, returns: "USAGE FROM FILE") do
      assert_equal "USAGE FROM FILE", Rails::Generators::AppGenerator.desc
    end
  end

  def test_default_usage
    assert_called(Rails::Generators::AppGenerator, :usage_path, returns: nil) do
      assert_match(/Create rails files for app generator/, Rails::Generators::AppGenerator.desc)
    end
  end

  def test_default_namespace
    assert_match "rails:app", Rails::Generators::AppGenerator.namespace
  end

  def test_file_is_added_for_backwards_compatibility
    action :file, "lib/test_file.rb", "heres test data"
    assert_file "lib/test_file.rb", "heres test data"
  end

  def test_tests_are_removed_from_frameworks_if_skip_test_is_given
    run_generator [destination_root, "--skip-test"]
    assert_file "config/application.rb", /#\s+require\s+["']rails\/test_unit\/railtie["']/
  end

  def test_no_active_record_or_tests_if_skips_given
    run_generator [destination_root, "--skip-test", "--skip-active-record"]
    assert_file "config/application.rb", /#\s+require\s+["']rails\/test_unit\/railtie["']/
    assert_file "config/application.rb", /#\s+require\s+["']active_record\/railtie["']/
    assert_file "config/application.rb", /\s+require\s+["']active_job\/railtie["']/
  end

  def test_pretend_option
    output = run_generator [File.join(destination_root, "myapp"), "--pretend"]
    assert_no_match(/run  bundle install/, output)
  end

  def test_application_name_with_spaces
    path = File.join(destination_root, "foo bar")

    # This also applies to MySQL apps but not with SQLite
    run_generator [path, "-d", "postgresql"]

    assert_file "foo bar/config/database.yml", /database: foo_bar_development/
  end

  def test_web_console
    run_generator
    assert_gem "web-console"
  end

  def test_web_console_with_dev_option
    run_generator [destination_root, "--dev"]

    assert_file "Gemfile" do |content|
      assert_match(/gem 'web-console',\s+github: 'rails\/web-console'/, content)
      assert_no_match(/\Agem 'web-console', '>= 3.3.0'\z/, content)
    end
  end

  def test_web_console_with_edge_option
    run_generator [destination_root, "--edge"]

    assert_file "Gemfile" do |content|
      assert_match(/gem 'web-console',\s+github: 'rails\/web-console'/, content)
      assert_no_match(/\Agem 'web-console', '>= 3.3.0'\z/, content)
    end
  end

  def test_generation_runs_bundle_install
    assert_generates_with_bundler
  end

  def test_dev_option
    assert_generates_with_bundler dev: true
    rails_path = File.expand_path("../../..", Rails.root)
    assert_file "Gemfile", /^gem\s+["']rails["'],\s+path:\s+["']#{Regexp.escape(rails_path)}["']$/
  end

  def test_edge_option
    assert_generates_with_bundler edge: true
    assert_file "Gemfile", %r{^gem\s+["']rails["'],\s+github:\s+["']#{Regexp.escape("rails/rails")}["'],\s+branch:\s+["']#{Regexp.escape("5-0-stable")}["']$}
  end

  def test_spring
    run_generator
    assert_gem "spring"
  end

  def test_spring_binstubs
    jruby_skip "spring doesn't run on JRuby"
    command_check = -> command do
      @binstub_called ||= 0

      case command
      when "install"
        # Called when running bundle, we just want to stub it so nothing to do here.
      when "exec spring binstub --all"
        @binstub_called += 1
        assert_equal 1, @binstub_called, "exec spring binstub --all expected to be called once, but was called #{@install_called} times."
      end
    end

    generator.stub :bundle_command, command_check do
      quietly { generator.invoke_all }
    end
  end

  def test_spring_no_fork
    jruby_skip "spring doesn't run on JRuby"
    assert_called_with(Process, :respond_to?, [[:fork], [:fork]], returns: false) do
      run_generator

      assert_file "Gemfile" do |content|
        assert_no_match(/spring/, content)
      end
    end
  end

  def test_skip_spring
    run_generator [destination_root, "--skip-spring"]

    assert_no_file "config/spring.rb"
    assert_file "Gemfile" do |content|
      assert_no_match(/spring/, content)
    end
  end

  def test_spring_with_dev_option
    run_generator [destination_root, "--dev"]

    assert_file "Gemfile" do |content|
      assert_no_match(/spring/, content)
    end
  end

  def test_generator_if_skip_turbolinks_is_given
    run_generator [destination_root, "--skip-turbolinks"]

    assert_file "Gemfile" do |content|
      assert_no_match(/turbolinks/, content)
    end
    assert_file "app/views/layouts/application.html.erb" do |content|
      assert_no_match(/data-turbolinks-track/, content)
    end
    assert_file "app/assets/javascripts/application.js" do |content|
      assert_no_match(/turbolinks/, content)
    end
  end

  def test_gitignore_when_sqlite3
    run_generator

    assert_file ".gitignore" do |content|
      assert_match(/sqlite3/, content)
    end
  end

  def test_gitignore_when_no_active_record
    run_generator [destination_root, "--skip-active-record"]

    assert_file ".gitignore" do |content|
      assert_no_match(/sqlite/i, content)
    end
  end

  def test_gitignore_when_non_sqlite3_db
    run_generator([destination_root, "-d", "mysql"])

    assert_file ".gitignore" do |content|
      assert_no_match(/sqlite/i, content)
    end
  end

  def test_create_keeps
    run_generator
    folders_with_keep = %w(
      app/assets/images
      app/controllers/concerns
      app/models/concerns
      lib/tasks
      lib/assets
      log
      test/fixtures
      test/fixtures/files
      test/controllers
      test/mailers
      test/models
      test/helpers
      test/integration
      tmp
      vendor/assets/stylesheets
    )
    folders_with_keep.each do |folder|
      assert_file("#{folder}/.keep")
    end
  end

  def test_psych_gem
    run_generator
    gem_regex = /gem 'psych',\s+'~> 2.0',\s+platforms: :rbx/

    assert_file "Gemfile" do |content|
      if defined?(Rubinius)
        assert_match(gem_regex, content)
      else
        assert_no_match(gem_regex, content)
      end
    end
  end

  def test_after_bundle_callback
    path = "http://example.org/rails_template"
    template = %{ after_bundle { run 'echo ran after_bundle' } }
    template.instance_eval "def read; self; end" # Make the string respond to read

    check_open = -> *args do
      assert_equal [ path, "Accept" => "application/x-thor-template" ], args
      template
    end

    sequence = ["install", "exec spring binstub --all", "echo ran after_bundle"]
    @sequence_step ||= 0
    ensure_bundler_first = -> command do
      assert_equal sequence[@sequence_step], command, "commands should be called in sequence #{sequence}"
      @sequence_step += 1
    end

    generator([destination_root], template: path).stub(:open, check_open, template) do
      generator.stub(:bundle_command, ensure_bundler_first) do
        generator.stub(:run, ensure_bundler_first) do
          quietly { generator.invoke_all }
        end
      end
    end

    assert_equal 3, @sequence_step
  end

  protected

    def stub_rails_application(root)
      Rails.application.config.root = root
      Rails.application.class.stub(:name, "Myapp") do
        yield
      end
    end

    def action(*args, &block)
      capture(:stdout) { generator.send(*args, &block) }
    end

    def assert_gem(gem, constraint = nil)
      if constraint
        assert_file "Gemfile", /^\s*gem\s+["']#{gem}["'], #{constraint}$*/
      else
        assert_file "Gemfile", /^\s*gem\s+["']#{gem}["']$*/
      end
    end

    def assert_listen_related_configuration
      assert_gem "listen"
      assert_gem "spring-watcher-listen"

      assert_file "config/environments/development.rb" do |content|
        assert_match(/^\s*config.file_watcher = ActiveSupport::EventedFileUpdateChecker/, content)
      end
    end

    def assert_no_listen_related_configuration
      assert_file "Gemfile" do |content|
        assert_no_match(/listen/, content)
      end

      assert_file "config/environments/development.rb" do |content|
        assert_match(/^\s*# config.file_watcher = ActiveSupport::EventedFileUpdateChecker/, content)
      end
    end

    def assert_generates_with_bundler(options = {})
      generator([destination_root], options)

      command_check = -> command do
        @install_called ||= 0

        case command
        when "install"
          @install_called += 1
          assert_equal 1, @install_called, "install expected to be called once, but was called #{@install_called} times"
        when "exec spring binstub --all"
          # Called when running tests with spring, let through unscathed.
        end
      end

      generator.stub :bundle_command, command_check do
        quietly { generator.invoke_all }
      end
    end
end
class Rails::ApplicationController < ActionController::Base # :nodoc:
  self.view_paths = File.expand_path("../templates", __FILE__)
  layout "application"

  protected

    def require_local!
      unless local_request?
        render html: "<p>For security purposes, this information is only available to local requests.</p>".html_safe, status: :forbidden
      end
    end

    def local_request?
      Rails.application.config.consider_all_requests_local || request.local?
    end
end
# Be sure to restart your server when you modify this file.

# ApplicationController.renderer.defaults.merge!(
#   http_host: 'example.org',
#   https: false
# )
module ApplicationHelper
end
class ApplicationJob < ActiveJob::Base
end
<% module_namespacing do -%>
class ApplicationMailer < ActionMailer::Base
  default from: 'from@example.com'
  layout 'mailer'
end
<% end %>
ApplicationController = 10
<% module_namespacing do -%>
class ApplicationRecord < ActiveRecord::Base
  self.abstract_class = true
end
<% end -%>
require "pathname"
require "rails/version"

module Rails
  module AppLoader # :nodoc:
    extend self

    RUBY = Gem.ruby
    EXECUTABLES = ["bin/rails", "script/rails"]
    BUNDLER_WARNING = <<EOS
Looks like your app's ./bin/rails is a stub that was generated by Bundler.

In Rails #{Rails::VERSION::MAJOR}, your app's bin/ directory contains executables that are versioned
like any other source code, rather than stubs that are generated on demand.

Here's how to upgrade:

  bundle config --delete bin    # Turn off Bundler's stub generator
  rails app:update:bin          # Use the new Rails 5 executables
  git add bin                   # Add bin/ to source control

You may need to remove bin/ from your .gitignore as well.

When you install a gem whose executable you want to use in your app,
generate it and add it to source control:

  bundle binstubs some-gem-name
  git add bin/new-executable

EOS

    def exec_app
      original_cwd = Dir.pwd

      loop do
        if exe = find_executable
          contents = File.read(exe)

          if contents =~ /(APP|ENGINE)_PATH/
            exec RUBY, exe, *ARGV
            break # non reachable, hack to be able to stub exec in the test suite
          elsif exe.end_with?("bin/rails") && contents.include?("This file was generated by Bundler")
            $stderr.puts(BUNDLER_WARNING)
            Object.const_set(:APP_PATH, File.expand_path("config/application", Dir.pwd))
            require File.expand_path("../boot", APP_PATH)
            require "rails/commands"
            break
          end
        end

        # If we exhaust the search there is no executable, this could be a
        # call to generate a new application, so restore the original cwd.
        Dir.chdir(original_cwd) and return if Pathname.new(Dir.pwd).root?

        # Otherwise keep moving upwards in search of an executable.
        Dir.chdir("..")
      end
    end

    def find_executable
      EXECUTABLES.find { |exe| File.file?(exe) }
    end
  end
end
require "tmpdir"
require "abstract_unit"
require "rails/app_loader"

class AppLoaderTest < ActiveSupport::TestCase
  def loader
    @loader ||= Class.new do
      extend Rails::AppLoader

      def self.exec_arguments
        @exec_arguments
      end

      def self.exec(*args)
        @exec_arguments = args
      end
    end
  end

  def write(filename, contents=nil)
    FileUtils.mkdir_p(File.dirname(filename))
    File.write(filename, contents)
  end

  def expects_exec(exe)
    assert_equal [Rails::AppLoader::RUBY, exe], loader.exec_arguments
  end

  setup do
    @tmp = Dir.mktmpdir("railties-rails-loader-test-suite")
    @cwd = Dir.pwd
    Dir.chdir(@tmp)
  end

  ["bin", "script"].each do |script_dir|
    exe = "#{script_dir}/rails"

    test "is not in a Rails application if #{exe} is not found in the current or parent directories" do
      def loader.find_executables; end

      assert !loader.exec_app
    end

    test "is not in a Rails application if #{exe} exists but is a folder" do
      FileUtils.mkdir_p(exe)

      assert !loader.exec_app
    end

    ["APP_PATH", "ENGINE_PATH"].each do |keyword|
      test "is in a Rails application if #{exe} exists and contains #{keyword}" do
        write exe, keyword

        loader.exec_app

        expects_exec exe
      end

      test "is not in a Rails application if #{exe} exists but doesn't contain #{keyword}" do
        write exe

        assert !loader.exec_app
      end

      test "is in a Rails application if parent directory has #{exe} containing #{keyword} and chdirs to the root directory" do
        write "foo/bar/#{exe}"
        write "foo/#{exe}", keyword

        Dir.chdir("foo/bar")

        loader.exec_app

        expects_exec exe

        # Compare the realpath in case either of them has symlinks.
        #
        # This happens in particular in Mac OS X, where @tmp starts
        # with "/var", and Dir.pwd with "/private/var", due to a
        # default system symlink var -> private/var.
        assert_equal File.realpath("#@tmp/foo"), File.realpath(Dir.pwd)
      end
    end
  end

  teardown do
    Dir.chdir(@cwd)
    FileUtils.rm_rf(@tmp)
  end
end
require "active_support/all"
require "action_controller"

module Rails
  module ConsoleMethods
    # reference the global "app" instance, created on demand. To recreate the
    # instance, pass a non-false value as the parameter.
    def app(create=false)
      @app_integration_instance = nil if create
      @app_integration_instance ||= new_session do |sess|
        sess.host! "www.example.com"
      end
    end

    # create a new session. If a block is given, the new session will be yielded
    # to the block before being returned.
    def new_session
      app = Rails.application
      session = ActionDispatch::Integration::Session.new(app)
      yield session if block_given?

      # This makes app.url_for and app.foo_path available in the console
      session.extend(app.routes.url_helpers)
      session.extend(app.routes.mounted_helpers)

      session
    end

    # reloads the environment
    def reload!(print=true)
      puts "Reloading..." if print
      Rails.application.reloader.reload!
      true
    end
  end
end
require "helper"
require "active_job/arguments"
require "models/person"
require "active_support/core_ext/hash/indifferent_access"
require "jobs/kwargs_job"

class ArgumentSerializationTest < ActiveSupport::TestCase
  setup do
    @person = Person.find("5")
  end

  [ nil, 1, 1.0, 1_000_000_000_000_000_000_000,
    "a", true, false, BigDecimal.new(5),
    [ 1, "a" ],
    { "a" => 1 }
  ].each do |arg|
    test "serializes #{arg.class} - #{arg} verbatim" do
      assert_arguments_unchanged arg
    end
  end

  [ :a, Object.new, self, Person.find("5").to_gid ].each do |arg|
    test "does not serialize #{arg.class}" do
      assert_raises ActiveJob::SerializationError do
        ActiveJob::Arguments.serialize [ arg ]
      end

      assert_raises ActiveJob::DeserializationError do
        ActiveJob::Arguments.deserialize [ arg ]
      end
    end
  end

  test "should convert records to Global IDs" do
    assert_arguments_roundtrip [@person]
  end

  test "should dive deep into arrays and hashes" do
    assert_arguments_roundtrip [3, [@person]]
    assert_arguments_roundtrip [{ "a" => @person }]
  end

  test "should maintain string and symbol keys" do
    assert_arguments_roundtrip([a: 1, "b" => 2])
  end

  test "should maintain hash with indifferent access" do
    symbol_key = { a: 1 }
    string_key = { "a" => 1 }
    indifferent_access = { a: 1 }.with_indifferent_access

    assert_not_instance_of ActiveSupport::HashWithIndifferentAccess, perform_round_trip([symbol_key]).first
    assert_not_instance_of ActiveSupport::HashWithIndifferentAccess, perform_round_trip([string_key]).first
    assert_instance_of ActiveSupport::HashWithIndifferentAccess, perform_round_trip([indifferent_access]).first
  end

  test "should disallow non-string/symbol hash keys" do
    assert_raises ActiveJob::SerializationError do
      ActiveJob::Arguments.serialize [ { 1 => 2 } ]
    end

    assert_raises ActiveJob::SerializationError do
      ActiveJob::Arguments.serialize [ { a: [{ 2 => 3 }] } ]
    end
  end

  test "should not allow reserved hash keys" do
    ["_aj_globalid", :_aj_globalid, "_aj_symbol_keys", :_aj_symbol_keys,
     "_aj_hash_with_indifferent_access", :_aj_hash_with_indifferent_access].each do |key|
      assert_raises ActiveJob::SerializationError do
        ActiveJob::Arguments.serialize [key => 1]
      end
    end
  end

  test "should not allow non-primitive objects" do
    assert_raises ActiveJob::SerializationError do
      ActiveJob::Arguments.serialize [Object.new]
    end

    assert_raises ActiveJob::SerializationError do
      ActiveJob::Arguments.serialize [1, [Object.new]]
    end
  end

  test "allows for keyword arguments" do
    KwargsJob.perform_later(argument: 2)

    assert_equal "Job with argument: 2", JobBuffer.last_value
  end

  test "raises a friendly SerializationError for records without ids" do
    err = assert_raises ActiveJob::SerializationError do
      ActiveJob::Arguments.serialize [Person.new(nil)]
    end
    assert_match "Unable to serialize Person without an id.", err.message
  end

  private
    def assert_arguments_unchanged(*args)
      assert_arguments_roundtrip args
    end

    def assert_arguments_roundtrip(args)
      assert_equal args, perform_round_trip(args)
    end

    def perform_round_trip(args)
      ActiveJob::Arguments.deserialize(ActiveJob::Arguments.serialize(args))
    end
end
require "active_support/core_ext/hash"

module ActiveJob
  # Raised when an exception is raised during job arguments deserialization.
  #
  # Wraps the original exception raised as +cause+.
  class DeserializationError < StandardError
    def initialize(e = nil) #:nodoc:
      if e
        ActiveSupport::Deprecation.warn("Passing #original_exception is deprecated and has no effect. " \
                                        "Exceptions will automatically capture the original exception.", caller)
      end

      super("Error while trying to deserialize arguments: #{$!.message}")
      set_backtrace $!.backtrace
    end

    # The original exception that was raised during deserialization of job
    # arguments.
    def original_exception
      ActiveSupport::Deprecation.warn("#original_exception is deprecated. Use #cause instead.", caller)
      cause
    end
  end

  # Raised when an unsupported argument type is set as a job argument. We
  # currently support NilClass, Integer, Fixnum, Float, String, TrueClass, FalseClass,
  # Bignum, BigDecimal, and objects that can be represented as GlobalIDs (ex: Active Record).
  # Raised if you set the key for a Hash something else than a string or
  # a symbol. Also raised when trying to serialize an object which can't be
  # identified with a Global ID - such as an unpersisted Active Record model.
  class SerializationError < ArgumentError; end

  module Arguments
    extend self
    # :nodoc:
    # Calls #uniq since Integer, Fixnum, and Bignum are all the same class on Ruby 2.4+
    TYPE_WHITELIST = [ NilClass, String, Integer, Fixnum, Bignum, Float, BigDecimal, TrueClass, FalseClass ].uniq

    # Serializes a set of arguments. Whitelisted types are returned
    # as-is. Arrays/Hashes are serialized element by element.
    # All other types are serialized using GlobalID.
    def serialize(arguments)
      arguments.map { |argument| serialize_argument(argument) }
    end

    # Deserializes a set of arguments. Whitelisted types are returned
    # as-is. Arrays/Hashes are deserialized element by element.
    # All other types are deserialized using GlobalID.
    def deserialize(arguments)
      arguments.map { |argument| deserialize_argument(argument) }
    rescue
      raise DeserializationError
    end

    private
      # :nodoc:
      GLOBALID_KEY = "_aj_globalid".freeze
      # :nodoc:
      SYMBOL_KEYS_KEY = "_aj_symbol_keys".freeze
      # :nodoc:
      WITH_INDIFFERENT_ACCESS_KEY = "_aj_hash_with_indifferent_access".freeze
      private_constant :GLOBALID_KEY, :SYMBOL_KEYS_KEY, :WITH_INDIFFERENT_ACCESS_KEY

      def serialize_argument(argument)
        case argument
        when *TYPE_WHITELIST
          argument
        when GlobalID::Identification
          convert_to_global_id_hash(argument)
        when Array
          argument.map { |arg| serialize_argument(arg) }
        when ActiveSupport::HashWithIndifferentAccess
          result = serialize_hash(argument)
          result[WITH_INDIFFERENT_ACCESS_KEY] = serialize_argument(true)
          result
        when Hash
          symbol_keys = argument.each_key.grep(Symbol).map(&:to_s)
          result = serialize_hash(argument)
          result[SYMBOL_KEYS_KEY] = symbol_keys
          result
        else
          raise SerializationError.new("Unsupported argument type: #{argument.class.name}")
        end
      end

      def deserialize_argument(argument)
        case argument
        when String
          GlobalID::Locator.locate(argument) || argument
        when *TYPE_WHITELIST
          argument
        when Array
          argument.map { |arg| deserialize_argument(arg) }
        when Hash
          if serialized_global_id?(argument)
            deserialize_global_id argument
          else
            deserialize_hash(argument)
          end
        else
          raise ArgumentError, "Can only deserialize primitive arguments: #{argument.inspect}"
        end
      end

      def serialized_global_id?(hash)
        hash.size == 1 and hash.include?(GLOBALID_KEY)
      end

      def deserialize_global_id(hash)
        GlobalID::Locator.locate hash[GLOBALID_KEY]
      end

      def serialize_hash(argument)
        argument.each_with_object({}) do |(key, value), hash|
          hash[serialize_hash_key(key)] = serialize_argument(value)
        end
      end

      def deserialize_hash(serialized_hash)
        result = serialized_hash.transform_values { |v| deserialize_argument(v) }
        if result.delete(WITH_INDIFFERENT_ACCESS_KEY)
          result = result.with_indifferent_access
        elsif symbol_keys = result.delete(SYMBOL_KEYS_KEY)
          result = transform_symbol_keys(result, symbol_keys)
        end
        result
      end

      # :nodoc:
      RESERVED_KEYS = [
        GLOBALID_KEY, GLOBALID_KEY.to_sym,
        SYMBOL_KEYS_KEY, SYMBOL_KEYS_KEY.to_sym,
        WITH_INDIFFERENT_ACCESS_KEY, WITH_INDIFFERENT_ACCESS_KEY.to_sym,
      ]
      private_constant :RESERVED_KEYS

      def serialize_hash_key(key)
        case key
        when *RESERVED_KEYS
          raise SerializationError.new("Can't serialize a Hash with reserved key #{key.inspect}")
        when String, Symbol
          key.to_s
        else
          raise SerializationError.new("Only string and symbol hash keys may be serialized as job arguments, but #{key.inspect} is a #{key.class}")
        end
      end

      def transform_symbol_keys(hash, symbol_keys)
        hash.transform_keys do |key|
          if symbol_keys.include?(key)
            key.to_sym
          else
            key
          end
        end
      end

      def convert_to_global_id_hash(argument)
        { GLOBALID_KEY => argument.to_global_id.to_s }
      rescue URI::GID::MissingModelIdError
        raise SerializationError, "Unable to serialize #{argument.class} " \
          "without an id. (Maybe you forgot to call save?)"
      end
  end
end
require "active_support/test_case"
require "active_support/testing/autorun"
require "rails/generators/rails/app/app_generator"
require "tempfile"

module Rails
  module Generators
    class ARGVScrubberTest < ActiveSupport::TestCase # :nodoc:
      # Future people who read this... These tests are just to surround the
      # current behavior of the ARGVScrubber, they do not mean that the class
      # *must* act this way, I just want to prevent regressions.

      def test_version
        ["-v", "--version"].each do |str|
          scrubber = ARGVScrubber.new [str]
          output    = nil
          exit_code = nil
          scrubber.extend(Module.new {
            define_method(:puts) { |string| output = string }
            define_method(:exit) { |code| exit_code = code }
          })
          scrubber.prepare!
          assert_equal "Rails #{Rails::VERSION::STRING}", output
          assert_equal 0, exit_code
        end
      end

      def test_default_help
        argv = ["zomg", "how", "are", "you"]
        scrubber = ARGVScrubber.new argv
        args = scrubber.prepare!
        assert_equal ["--help"] + argv.drop(1), args
      end

      def test_prepare_returns_args
        scrubber = ARGVScrubber.new ["hi mom"]
        args = scrubber.prepare!
        assert_equal "--help", args.first
      end

      def test_no_mutations
        scrubber = ARGVScrubber.new ["hi mom"].freeze
        args = scrubber.prepare!
        assert_equal "--help", args.first
      end

      def test_new_command_no_rc
        scrubber = Class.new(ARGVScrubber) {
          def self.default_rc_file
            File.join(Dir.tmpdir, "whatever")
          end
        }.new ["new"]
        args = scrubber.prepare!
        assert_equal [], args
      end

      def test_new_homedir_rc
        file = Tempfile.new "myrcfile"
        file.puts "--hello-world"
        file.flush

        message = nil
        scrubber = Class.new(ARGVScrubber) {
          define_singleton_method(:default_rc_file) do
            file.path
          end
          define_method(:puts) { |msg| message = msg }
        }.new ["new"]
        args = scrubber.prepare!
        assert_equal ["--hello-world"], args
        assert_match "hello-world", message
        assert_match file.path, message
      ensure
        file.close
        file.unlink
      end

      def test_rc_whitespace_separated
        file = Tempfile.new "myrcfile"
        file.puts "--hello --world"
        file.flush

        message = nil
        scrubber = Class.new(ARGVScrubber) {
          define_method(:puts) { |msg| message = msg }
        }.new ["new", "--rc=#{file.path}"]
        args = scrubber.prepare!
        assert_equal ["--hello", "--world"], args
      ensure
        file.close
        file.unlink
      end

      def test_new_rc_option
        file = Tempfile.new "myrcfile"
        file.puts "--hello-world"
        file.flush

        message = nil
        scrubber = Class.new(ARGVScrubber) {
          define_method(:puts) { |msg| message = msg }
        }.new ["new", "--rc=#{file.path}"]
        args = scrubber.prepare!
        assert_equal ["--hello-world"], args
        assert_match "hello-world", message
        assert_match file.path, message
      ensure
        file.close
        file.unlink
      end

      def test_new_rc_option_and_custom_options
        file = Tempfile.new "myrcfile"
        file.puts "--hello"
        file.puts "--world"
        file.flush

        scrubber = Class.new(ARGVScrubber) {
          define_method(:puts) { |msg| }
        }.new ["new", "tenderapp", "--love", "--rc=#{file.path}"]

        args = scrubber.prepare!
        assert_equal ["tenderapp", "--hello", "--world", "--love"], args
      ensure
        file.close
        file.unlink
      end

      def test_no_rc
        scrubber = ARGVScrubber.new ["new", "--no-rc"]
        args = scrubber.prepare!
        assert_equal [], args
      end
    end
  end
end
module ActiveRecord
  class PredicateBuilder
    class ArrayHandler # :nodoc:
      def initialize(predicate_builder)
        @predicate_builder = predicate_builder
      end

      def call(attribute, value)
        values = value.map { |x| x.is_a?(Base) ? x.id : x }
        nils, values = values.partition(&:nil?)

        return attribute.in([]) if values.empty? && nils.empty?

        ranges, values = values.partition { |v| v.is_a?(Range) }

        values_predicate =
          case values.length
          when 0 then NullPredicate
          when 1 then predicate_builder.build(attribute, values.first)
          else attribute.in(values)
          end

        unless nils.empty?
          values_predicate = values_predicate.or(predicate_builder.build(attribute, nil))
        end

        array_predicates = ranges.map { |range| predicate_builder.build(attribute, range) }
        array_predicates.unshift(values_predicate)
        array_predicates.inject { |composite, predicate| composite.or(predicate) }
      end

      protected

        attr_reader :predicate_builder

        module NullPredicate # :nodoc:
          def self.or(other)
            other
          end
        end
    end
  end
end
module ActiveSupport
  # Wrapping an array in an +ArrayInquirer+ gives a friendlier way to check
  # its string-like contents:
  #
  #   variants = ActiveSupport::ArrayInquirer.new([:phone, :tablet])
  #
  #   variants.phone?    # => true
  #   variants.tablet?   # => true
  #   variants.desktop?  # => false
  class ArrayInquirer < Array
    # Passes each element of +candidates+ collection to ArrayInquirer collection.
    # The method returns true if any element from the ArrayInquirer collection
    # is equal to the stringified or symbolized form of any element in the +candidates+ collection.
    #
    # If +candidates+ collection is not given, method returns true.
    #
    #   variants = ActiveSupport::ArrayInquirer.new([:phone, :tablet])
    #
    #   variants.any?                      # => true
    #   variants.any?(:phone, :tablet)     # => true
    #   variants.any?('phone', 'desktop')  # => true
    #   variants.any?(:desktop, :watch)    # => false
    def any?(*candidates, &block)
      if candidates.none?
        super
      else
        candidates.any? do |candidate|
          include?(candidate.to_sym) || include?(candidate.to_s)
        end
      end
    end

    private
      def respond_to_missing?(name, include_private = false)
        name[-1] == "?"
      end

      def method_missing(name, *args)
        if name[-1] == "?"
          any?(name[0..-2])
        else
          super
        end
      end
  end
end
require "abstract_unit"
require "active_support/core_ext/array"

class ArrayInquirerTest < ActiveSupport::TestCase
  def setup
    @array_inquirer = ActiveSupport::ArrayInquirer.new([:mobile, :tablet, "api"])
  end

  def test_individual
    assert @array_inquirer.mobile?
    assert @array_inquirer.tablet?
    assert_not @array_inquirer.desktop?
  end

  def test_any
    assert @array_inquirer.any?(:mobile, :desktop)
    assert @array_inquirer.any?(:watch, :tablet)
    assert_not @array_inquirer.any?(:desktop, :watch)
  end

  def test_any_string_symbol_mismatch
    assert @array_inquirer.any?("mobile")
    assert @array_inquirer.any?(:api)
  end

  def test_any_with_block
    assert @array_inquirer.any? { |v| v == :mobile }
    assert_not @array_inquirer.any? { |v| v == :desktop }
  end

  def test_respond_to
    assert_respond_to @array_inquirer, :development?
  end

  def test_inquiry
    result = [:mobile, :tablet, "api"].inquiry

    assert_instance_of ActiveSupport::ArrayInquirer, result
    assert_equal @array_inquirer, result
  end
end
require "active_support/core_ext/array/wrap"
require "active_support/core_ext/array/access"
require "active_support/core_ext/array/conversions"
require "active_support/core_ext/array/extract_options"
require "active_support/core_ext/array/grouping"
require "active_support/core_ext/array/prepend_and_append"
require "active_support/core_ext/array/inquiry"
require "cases/helper"
require "support/schema_dumping_helper"

class PostgresqlArrayTest < ActiveRecord::PostgreSQLTestCase
  include SchemaDumpingHelper
  include InTimeZone

  class PgArray < ActiveRecord::Base
    self.table_name = "pg_arrays"
  end

  def setup
    @connection = ActiveRecord::Base.connection

    enable_extension!("hstore", @connection)

    @connection.transaction do
      @connection.create_table("pg_arrays") do |t|
        t.string "tags", array: true
        t.integer "ratings", array: true
        t.datetime :datetimes, array: true
        t.hstore :hstores, array: true
      end
    end
    PgArray.reset_column_information
    @column = PgArray.columns_hash["tags"]
    @type = PgArray.type_for_attribute("tags")
  end

  teardown do
    @connection.drop_table "pg_arrays", if_exists: true
    disable_extension!("hstore", @connection)
  end

  def test_column
    assert_equal :string, @column.type
    assert_equal "character varying", @column.sql_type
    assert @column.array?
    assert_not @type.binary?

    ratings_column = PgArray.columns_hash["ratings"]
    assert_equal :integer, ratings_column.type
    assert ratings_column.array?
  end

  def test_default
    @connection.add_column "pg_arrays", "score", :integer, array: true, default: [4, 4, 2]
    PgArray.reset_column_information

    assert_equal([4, 4, 2], PgArray.column_defaults["score"])
    assert_equal([4, 4, 2], PgArray.new.score)
  ensure
    PgArray.reset_column_information
  end

  def test_default_strings
    @connection.add_column "pg_arrays", "names", :string, array: true, default: ["foo", "bar"]
    PgArray.reset_column_information

    assert_equal(["foo", "bar"], PgArray.column_defaults["names"])
    assert_equal(["foo", "bar"], PgArray.new.names)
  ensure
    PgArray.reset_column_information
  end

  def test_change_column_with_array
    @connection.add_column :pg_arrays, :snippets, :string, array: true, default: []
    @connection.change_column :pg_arrays, :snippets, :text, array: true, default: []

    PgArray.reset_column_information
    column = PgArray.columns_hash["snippets"]

    assert_equal :text, column.type
    assert_equal [], PgArray.column_defaults["snippets"]
    assert column.array?
  end

  def test_change_column_cant_make_non_array_column_to_array
    @connection.add_column :pg_arrays, :a_string, :string
    assert_raises ActiveRecord::StatementInvalid do
      @connection.transaction do
        @connection.change_column :pg_arrays, :a_string, :string, array: true
      end
    end
  end

  def test_change_column_default_with_array
    @connection.change_column_default :pg_arrays, :tags, []

    PgArray.reset_column_information
    assert_equal [], PgArray.column_defaults["tags"]
  end

  def test_type_cast_array
    assert_equal(["1", "2", "3"], @type.deserialize("{1,2,3}"))
    assert_equal([], @type.deserialize("{}"))
    assert_equal([nil], @type.deserialize("{NULL}"))
  end

  def test_type_cast_integers
    x = PgArray.new(ratings: ["1", "2"])

    assert_equal([1, 2], x.ratings)

    x.save!
    x.reload

    assert_equal([1, 2], x.ratings)
  end

  def test_schema_dump_with_shorthand
    output = dump_table_schema "pg_arrays"
    assert_match %r[t\.string\s+"tags",\s+array: true], output
    assert_match %r[t\.integer\s+"ratings",\s+array: true], output
  end

  def test_select_with_strings
    @connection.execute "insert into pg_arrays (tags) VALUES ('{1,2,3}')"
    x = PgArray.first
    assert_equal(["1","2","3"], x.tags)
  end

  def test_rewrite_with_strings
    @connection.execute "insert into pg_arrays (tags) VALUES ('{1,2,3}')"
    x = PgArray.first
    x.tags = ["1","2","3","4"]
    x.save!
    assert_equal ["1","2","3","4"], x.reload.tags
  end

  def test_select_with_integers
    @connection.execute "insert into pg_arrays (ratings) VALUES ('{1,2,3}')"
    x = PgArray.first
    assert_equal([1, 2, 3], x.ratings)
  end

  def test_rewrite_with_integers
    @connection.execute "insert into pg_arrays (ratings) VALUES ('{1,2,3}')"
    x = PgArray.first
    x.ratings = [2, "3", 4]
    x.save!
    assert_equal [2, 3, 4], x.reload.ratings
  end

  def test_multi_dimensional_with_strings
    assert_cycle(:tags, [[["1"], ["2"]], [["2"], ["3"]]])
  end

  def test_with_empty_strings
    assert_cycle(:tags, [ "1", "2", "", "4", "", "5" ])
  end

  def test_with_multi_dimensional_empty_strings
    assert_cycle(:tags, [[["1", "2"], ["", "4"], ["", "5"]]])
  end

  def test_with_arbitrary_whitespace
    assert_cycle(:tags, [[["1", "2"], ["    ", "4"], ["    ", "5"]]])
  end

  def test_multi_dimensional_with_integers
    assert_cycle(:ratings, [[[1], [7]], [[8], [10]]])
  end

  def test_strings_with_quotes
    assert_cycle(:tags, ["this has",'some "s that need to be escaped"'])
  end

  def test_strings_with_commas
    assert_cycle(:tags, ["this,has","many,values"])
  end

  def test_strings_with_array_delimiters
    assert_cycle(:tags, ["{","}"])
  end

  def test_strings_with_null_strings
    assert_cycle(:tags, ["NULL","NULL"])
  end

  def test_contains_nils
    assert_cycle(:tags, ["1",nil,nil])
  end

  def test_insert_fixture
    tag_values = ["val1", "val2", "val3_with_'_multiple_quote_'_chars"]
    @connection.insert_fixture({"tags" => tag_values}, "pg_arrays" )
    assert_equal(PgArray.last.tags, tag_values)
  end

  def test_attribute_for_inspect_for_array_field
    record = PgArray.new { |a| a.ratings = (1..10).to_a }
    assert_equal("[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]", record.attribute_for_inspect(:ratings))
  end

  def test_attribute_for_inspect_for_array_field_for_large_array
    record = PgArray.new { |a| a.ratings = (1..11).to_a }
    assert_equal("[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]", record.attribute_for_inspect(:ratings))
  end

  def test_escaping
    unknown = 'foo\\",bar,baz,\\'
    tags = ["hello_#{unknown}"]
    ar = PgArray.create!(tags: tags)
    ar.reload
    assert_equal tags, ar.tags
  end

  def test_string_quoting_rules_match_pg_behavior
    tags = ["", "one{", "two}", %(three"), "four\\", "five ", "six\t", "seven\n", "eight,", "nine", "ten\r", "NULL"]
    x = PgArray.create!(tags: tags)
    x.reload

    assert_equal x.tags_before_type_cast, PgArray.type_for_attribute("tags").serialize(tags)
  end

  def test_quoting_non_standard_delimiters
    strings = ["hello,", "world;"]
    oid = ActiveRecord::ConnectionAdapters::PostgreSQL::OID
    comma_delim = oid::Array.new(ActiveRecord::Type::String.new, ",")
    semicolon_delim = oid::Array.new(ActiveRecord::Type::String.new, ";")

    assert_equal %({"hello,",world;}), comma_delim.serialize(strings)
    assert_equal %({hello,;"world;"}), semicolon_delim.serialize(strings)
  end

  def test_mutate_array
    x = PgArray.create!(tags: %w(one two))

    x.tags << "three"
    x.save!
    x.reload

    assert_equal %w(one two three), x.tags
    assert_not x.changed?
  end

  def test_mutate_value_in_array
    x = PgArray.create!(hstores: [{ a: "a" }, { b: "b" }])

    x.hstores.first["a"] = "c"
    x.save!
    x.reload

    assert_equal [{ "a" => "c" }, { "b" => "b" }], x.hstores
    assert_not x.changed?
  end

  def test_datetime_with_timezone_awareness
    tz = "Pacific Time (US & Canada)"

    in_time_zone tz do
      PgArray.reset_column_information
      time_string = Time.current.to_s
      time = Time.zone.parse(time_string)

      record = PgArray.new(datetimes: [time_string])
      assert_equal [time], record.datetimes
      assert_equal ActiveSupport::TimeZone[tz], record.datetimes.first.time_zone

      record.save!
      record.reload

      assert_equal [time], record.datetimes
      assert_equal ActiveSupport::TimeZone[tz], record.datetimes.first.time_zone
    end
  end

  def test_assigning_non_array_value
    record = PgArray.new(tags: "not-an-array")
    assert_equal [], record.tags
    assert_equal "not-an-array", record.tags_before_type_cast
    assert record.save
    assert_equal record.tags, record.reload.tags
  end

  def test_assigning_empty_string
    record = PgArray.new(tags: "")
    assert_equal [], record.tags
    assert_equal "", record.tags_before_type_cast
    assert record.save
    assert_equal record.tags, record.reload.tags
  end

  def test_assigning_valid_pg_array_literal
    record = PgArray.new(tags: "{1,2,3}")
    assert_equal ["1", "2", "3"], record.tags
    assert_equal "{1,2,3}", record.tags_before_type_cast
    assert record.save
    assert_equal record.tags, record.reload.tags
  end

  def test_uniqueness_validation
    klass = Class.new(PgArray) do
      validates_uniqueness_of :tags

      def self.model_name; ActiveModel::Name.new(PgArray) end
    end
    e1 = klass.create("tags" => ["black", "blue"])
    assert e1.persisted?, "Saving e1"

    e2 = klass.create("tags" => ["black", "blue"])
    assert !e2.persisted?, "e2 shouldn't be valid"
    assert e2.errors[:tags].any?, "Should have errors for tags"
    assert_equal ["has already been taken"], e2.errors[:tags], "Should have uniqueness message for tags"
  end

  private
    def assert_cycle(field, array)
      # test creation
      x = PgArray.create!(field => array)
      x.reload
      assert_equal(array, x.public_send(field))

      # test updating
      x = PgArray.create!(field => [])
      x.public_send("#{field}=", array)
      x.save!
      x.reload
      assert_equal(array, x.public_send(field))
    end
end
require "cases/helper"

if ActiveRecord::Base.connection.supports_migrations?

  class ActiveRecordSchemaTest < ActiveRecord::TestCase
    self.use_transactional_tests = false

    setup do
      @original_verbose = ActiveRecord::Migration.verbose
      ActiveRecord::Migration.verbose = false
      @connection = ActiveRecord::Base.connection
      ActiveRecord::SchemaMigration.drop_table
    end

    teardown do
      @connection.drop_table :fruits rescue nil
      @connection.drop_table :nep_fruits rescue nil
      @connection.drop_table :nep_schema_migrations rescue nil
      @connection.drop_table :has_timestamps rescue nil
      ActiveRecord::SchemaMigration.delete_all rescue nil
      ActiveRecord::Migration.verbose = @original_verbose
    end

    def test_has_primary_key
      old_primary_key_prefix_type = ActiveRecord::Base.primary_key_prefix_type
      ActiveRecord::Base.primary_key_prefix_type = :table_name_with_underscore
      assert_equal "version", ActiveRecord::SchemaMigration.primary_key

      ActiveRecord::SchemaMigration.create_table
      assert_difference "ActiveRecord::SchemaMigration.count", 1 do
        ActiveRecord::SchemaMigration.create version: 12
      end
    ensure
      ActiveRecord::SchemaMigration.drop_table
      ActiveRecord::Base.primary_key_prefix_type = old_primary_key_prefix_type
    end

    def test_schema_define
      ActiveRecord::Schema.define(version: 7) do
        create_table :fruits do |t|
          t.column :color, :string
          t.column :fruit_size, :string  # NOTE: "size" is reserved in Oracle
          t.column :texture, :string
          t.column :flavor, :string
        end
      end

      assert_nothing_raised { @connection.select_all "SELECT * FROM fruits" }
      assert_nothing_raised { @connection.select_all "SELECT * FROM schema_migrations" }
      assert_equal 7, ActiveRecord::Migrator::current_version
    end

    def test_schema_define_w_table_name_prefix
      table_name = ActiveRecord::SchemaMigration.table_name
      old_table_name_prefix = ActiveRecord::Base.table_name_prefix
      ActiveRecord::Base.table_name_prefix  = "nep_"
      ActiveRecord::SchemaMigration.table_name = "nep_#{table_name}"
      ActiveRecord::Schema.define(version: 7) do
        create_table :fruits do |t|
          t.column :color, :string
          t.column :fruit_size, :string  # NOTE: "size" is reserved in Oracle
          t.column :texture, :string
          t.column :flavor, :string
        end
      end
      assert_equal 7, ActiveRecord::Migrator::current_version
    ensure
      ActiveRecord::Base.table_name_prefix  = old_table_name_prefix
      ActiveRecord::SchemaMigration.table_name = table_name
    end

    def test_schema_raises_an_error_for_invalid_column_type
      assert_raise NoMethodError do
        ActiveRecord::Schema.define(version: 8) do
          create_table :vegetables do |t|
            t.unknown :color
          end
        end
      end
    end

    def test_schema_subclass
      Class.new(ActiveRecord::Schema).define(version: 9) do
        create_table :fruits
      end
      assert_nothing_raised { @connection.select_all "SELECT * FROM fruits" }
    end

    def test_normalize_version
      assert_equal "118", ActiveRecord::SchemaMigration.normalize_migration_number("0000118")
      assert_equal "002", ActiveRecord::SchemaMigration.normalize_migration_number("2")
      assert_equal "017", ActiveRecord::SchemaMigration.normalize_migration_number("0017")
      assert_equal "20131219224947", ActiveRecord::SchemaMigration.normalize_migration_number("20131219224947")
    end

    def test_timestamps_without_null_set_null_to_false_on_create_table
      ActiveRecord::Schema.define do
        create_table :has_timestamps do |t|
          t.timestamps
        end
      end

      assert !@connection.columns(:has_timestamps).find { |c| c.name == "created_at" }.null
      assert !@connection.columns(:has_timestamps).find { |c| c.name == "updated_at" }.null
    end

    def test_timestamps_without_null_set_null_to_false_on_change_table
      ActiveRecord::Schema.define do
        create_table :has_timestamps

        change_table :has_timestamps do |t|
          t.timestamps default: Time.now
        end
      end

      assert !@connection.columns(:has_timestamps).find { |c| c.name == "created_at" }.null
      assert !@connection.columns(:has_timestamps).find { |c| c.name == "updated_at" }.null
    end

    def test_timestamps_without_null_set_null_to_false_on_add_timestamps
      ActiveRecord::Schema.define do
        create_table :has_timestamps
        add_timestamps :has_timestamps, default: Time.now
      end

      assert !@connection.columns(:has_timestamps).find { |c| c.name == "created_at" }.null
      assert !@connection.columns(:has_timestamps).find { |c| c.name == "updated_at" }.null
    end
  end
end
class Publisher::Article < ActiveRecord::Base
  has_and_belongs_to_many :magazines
  has_and_belongs_to_many :tags
end
class ARUnit2Model < ActiveRecord::Base
  self.abstract_class = true
end
module ActionDispatch
  # This is a class that abstracts away an asserted response. It purposely
  # does not inherit from Response because it doesn't need it. That means it
  # does not have headers or a body.
  class AssertionResponse
    attr_reader :code, :name

    GENERIC_RESPONSE_CODES = { # :nodoc:
      success: "2XX",
      missing: "404",
      redirect: "3XX",
      error: "5XX"
    }

    # Accepts a specific response status code as an Integer (404) or String
    # ('404') or a response status range as a Symbol pseudo-code (:success,
    # indicating any 200-299 status code).
    def initialize(code_or_name)
      if code_or_name.is_a?(Symbol)
        @name = code_or_name
        @code = code_from_name(code_or_name)
      else
        @name = name_from_code(code_or_name)
        @code = code_or_name
      end

      raise ArgumentError, "Invalid response name: #{name}" if @code.nil?
      raise ArgumentError, "Invalid response code: #{code}" if @name.nil?
    end

    def code_and_name
      "#{code}: #{name}"
    end

    private

      def code_from_name(name)
        GENERIC_RESPONSE_CODES[name] || Rack::Utils::SYMBOL_TO_STATUS_CODE[name]
      end

      def name_from_code(code)
        GENERIC_RESPONSE_CODES.invert[code] || Rack::Utils::HTTP_STATUS_CODES[code]
      end
  end
end
require "rails-dom-testing"

module ActionDispatch
  module Assertions
    autoload :ResponseAssertions, "action_dispatch/testing/assertions/response"
    autoload :RoutingAssertions, "action_dispatch/testing/assertions/routing"

    extend ActiveSupport::Concern

    include ResponseAssertions
    include RoutingAssertions
    include Rails::Dom::Testing::Assertions

    def html_document
      @html_document ||= if @response.content_type.to_s =~ /xml\z/
        Nokogiri::XML::Document.parse(@response.body)
      else
        Nokogiri::HTML::Document.parse(@response.body)
      end
    end
  end
end
require "abstract_unit"

class AssertSelectEmailTest < ActionMailer::TestCase
  class AssertSelectMailer < ActionMailer::Base
    def test(html)
      mail body: html, content_type: "text/html",
        subject: "Test e-mail", from: "test@test.host", to: "test <test@test.host>"
    end
  end

  class AssertMultipartSelectMailer < ActionMailer::Base
    def test(options)
      mail subject: "Test e-mail", from: "test@test.host", to: "test <test@test.host>" do |format|
        format.text { render text: options[:text] }
        format.html { render text: options[:html] }
      end
    end
  end

  #
  # Test assert_select_email
  #

  def test_assert_select_email
    assert_raise ActiveSupport::TestCase::Assertion do
      assert_select_email {}
    end

    AssertSelectMailer.test("<div><p>foo</p><p>bar</p></div>").deliver_now
    assert_select_email do
      assert_select "div:root" do
        assert_select "p:first-child", "foo"
        assert_select "p:last-child", "bar"
      end
    end
  end

  def test_assert_select_email_multipart
    AssertMultipartSelectMailer.test(html: "<div><p>foo</p><p>bar</p></div>", text: "foo bar").deliver_now
    assert_select_email do
      assert_select "div:root" do
        assert_select "p:first-child", "foo"
        assert_select "p:last-child", "bar"
      end
    end
  end
end
require "isolation/abstract_unit"
require "rack/test"

module ApplicationTests
  class AssetDebuggingTest < ActiveSupport::TestCase
    include ActiveSupport::Testing::Isolation
    include Rack::Test::Methods

    def setup
      # FIXME: shush Sass warning spam, not relevant to testing Railties
      Kernel.silence_warnings do
        build_app(initializers: true)
      end

      app_file "app/assets/javascripts/application.js", "//= require_tree ."
      app_file "app/assets/javascripts/xmlhr.js", "function f1() { alert(); }"
      app_file "app/views/posts/index.html.erb", "<%= javascript_include_tag 'application' %>"

      app_file "config/routes.rb", <<-RUBY
        Rails.application.routes.draw do
          get '/posts', to: "posts#index"
        end
      RUBY

      app_file "app/controllers/posts_controller.rb", <<-RUBY
        class PostsController < ActionController::Base
        end
      RUBY

      ENV["RAILS_ENV"] = "production"
    end

    def teardown
      teardown_app
    end

    # FIXME: shush Sass warning spam, not relevant to testing Railties
    def get(*)
      Kernel.silence_warnings { super }
    end

    test "assets are concatenated when debug is off and compile is off either if debug_assets param is provided" do
      # config.assets.debug and config.assets.compile are false for production environment
      ENV["RAILS_ENV"] = "production"
      output = Dir.chdir(app_path){ `bin/rails assets:precompile --trace 2>&1` }
      assert $?.success?, output

      # Load app env
      app "production"

      class ::PostsController < ActionController::Base ; end

      # the debug_assets params isn't used if compile is off
      get "/posts?debug_assets=true"
      assert_match(/<script src="\/assets\/application-([0-z]+)\.js"><\/script>/, last_response.body)
      assert_no_match(/<script src="\/assets\/xmlhr-([0-z]+)\.js"><\/script>/, last_response.body)
    end

    test "assets aren't concatenated when compile is true is on and debug_assets params is true" do
      add_to_env_config "production", "config.assets.compile = true"

      # Load app env
      app "production"

      class ::PostsController < ActionController::Base ; end

      get "/posts?debug_assets=true"
      assert_match(/<script src="\/assets\/application(\.self)?-([0-z]+)\.js\?body=1"><\/script>/, last_response.body)
      assert_match(/<script src="\/assets\/xmlhr(\.self)?-([0-z]+)\.js\?body=1"><\/script>/, last_response.body)
    end
  end
end
require "abstract_unit"
require "action_controller"

class AssetHostMailer < ActionMailer::Base
  def email_with_asset
    mail to: "test@localhost",
      subject: "testing email containing asset path while asset_host is set",
      from: "tester@example.com"
  end
end

class AssetHostTest < ActionMailer::TestCase
  def setup
    AssetHostMailer.configure do |c|
      c.asset_host = "http://www.example.com"
    end
  end

  def teardown
    restore_delivery_method
  end

  def test_asset_host_as_string
    mail = AssetHostMailer.email_with_asset
    assert_dom_equal '<img alt="Somelogo" src="http://www.example.com/images/somelogo.png" />', mail.body.to_s.strip
  end

  def test_asset_host_as_one_argument_proc
    AssetHostMailer.config.asset_host = Proc.new { |source|
      if source.starts_with?("/images")
        "http://images.example.com"
      end
    }
    mail = AssetHostMailer.email_with_asset
    assert_dom_equal '<img alt="Somelogo" src="http://images.example.com/images/somelogo.png" />', mail.body.to_s.strip
  end
end
class AssetMailer < ActionMailer::Base
  self.mailer_name = "asset_mailer"

  def welcome
    mail
  end
end
module AbstractController
  module AssetPaths #:nodoc:
    extend ActiveSupport::Concern

    included do
      config_accessor :asset_host, :assets_dir, :javascripts_dir,
        :stylesheets_dir, :default_asset_host_protocol, :relative_url_root
    end
  end
end
require "rails/generators/named_base"

module Js # :nodoc:
  module Generators # :nodoc:
    class AssetsGenerator < Rails::Generators::NamedBase # :nodoc:
      source_root File.expand_path("../templates", __FILE__)

      def copy_javascript
        copy_file "javascript.js", File.join("app/assets/javascripts", class_path, "#{file_name}.js")
      end
    end
  end
end
require "generators/generators_test_helper"
require "rails/generators/rails/assets/assets_generator"

class AssetsGeneratorTest < Rails::Generators::TestCase
  include GeneratorsTestHelper
  arguments %w(posts)

  def test_assets
    run_generator
    assert_file "app/assets/javascripts/posts.js"
    assert_file "app/assets/stylesheets/posts.css"
  end

  def test_skipping_assets
    run_generator ["posts", "--no-stylesheets", "--no-javascripts"]
    assert_no_file "app/assets/javascripts/posts.js"
    assert_no_file "app/assets/stylesheets/posts.css"
  end
end
require "isolation/abstract_unit"
require "rack/test"
require "active_support/json"

module ApplicationTests
  class AssetsTest < ActiveSupport::TestCase
    include ActiveSupport::Testing::Isolation
    include Rack::Test::Methods

    def setup
      build_app(initializers: true)
    end

    def teardown
      teardown_app
    end

    def precompile!(env = nil)
      with_env env.to_h do
        quietly do
          precompile_task = "bin/rails assets:precompile --trace 2>&1"
          output = Dir.chdir(app_path) { %x[ #{precompile_task} ] }
          assert $?.success?, output
          output
        end
      end
    end

    def with_env(env)
      env.each { |k, v| ENV[k.to_s] = v }
      yield
    ensure
      env.each_key { |k| ENV.delete k.to_s }
    end

    def clean_assets!
      quietly do
        assert Dir.chdir(app_path) { system("bin/rails assets:clobber") }
      end
    end

    def assert_file_exists(filename)
      globbed = Dir[filename]
      assert globbed.one?, "Found #{globbed.size} files matching #{filename}. All files in the directory: #{Dir.entries(File.dirname(filename)).inspect}"
    end

    def assert_no_file_exists(filename)
      assert !File.exist?(filename), "#{filename} does exist"
    end

    test "assets routes have higher priority" do
      app_file "app/assets/images/rails.png", "notactuallyapng"
      app_file "app/assets/javascripts/demo.js.erb", "a = <%= image_path('rails.png').inspect %>;"

      app_file "config/routes.rb", <<-RUBY
        Rails.application.routes.draw do
          get '*path', to: lambda { |env| [200, { "Content-Type" => "text/html" }, ["Not an asset"]] }
        end
      RUBY

      add_to_env_config "development", "config.assets.digest = false"

      # FIXME: shush Sass warning spam, not relevant to testing Railties
      Kernel.silence_warnings do
        require "#{app_path}/config/environment"
      end

      get "/assets/demo.js"
      assert_equal 'a = "/assets/rails.png";', last_response.body.strip
    end

    test "assets do not require compressors until it is used" do
      app_file "app/assets/javascripts/demo.js.erb", "<%= :alert %>();"
      add_to_env_config "production", "config.assets.compile = true"
      add_to_env_config "production", "config.assets.precompile = []"

      # Load app env
      app "production"

      assert !defined?(Uglifier)
      get "/assets/demo.js"
      assert_match "alert()", last_response.body
      assert defined?(Uglifier)
    end

    test "precompile creates the file, gives it the original asset's content and run in production as default" do
      app_file "app/assets/config/manifest.js", "//= link_tree ../javascripts"
      app_file "app/assets/javascripts/application.js", "alert();"
      app_file "app/assets/javascripts/foo/application.js", "alert();"

      precompile!

      files = Dir["#{app_path}/public/assets/application-*.js"]
      files << Dir["#{app_path}/public/assets/foo/application-*.js"].first
      files.each do |file|
        assert_not_nil file, "Expected application.js asset to be generated, but none found"
        assert_equal "alert();\n", File.read(file)
      end
    end

    def test_precompile_does_not_hit_the_database
      app_file "app/assets/config/manifest.js", "//= link_tree ../javascripts"
      app_file "app/assets/javascripts/application.js", "alert();"
      app_file "app/assets/javascripts/foo/application.js", "alert();"
      app_file "app/controllers/users_controller.rb", <<-eoruby
        class UsersController < ApplicationController; end
      eoruby
      app_file "app/models/user.rb", <<-eoruby
        class User < ActiveRecord::Base; raise 'should not be reached'; end
      eoruby

      precompile! \
        RAILS_ENV: "production",
        DATABASE_URL: "postgresql://baduser:badpass@127.0.0.1/dbname"

      files = Dir["#{app_path}/public/assets/application-*.js"]
      files << Dir["#{app_path}/public/assets/foo/application-*.js"].first
      files.each do |file|
        assert_not_nil file, "Expected application.js asset to be generated, but none found"
        assert_equal "alert();".strip, File.read(file).strip
      end
    end

    test "precompile application.js and application.css and all other non JS/CSS files" do
      app_file "app/assets/javascripts/application.js", "alert();"
      app_file "app/assets/stylesheets/application.css", "body{}"

      app_file "app/assets/javascripts/someapplication.js", "alert();"
      app_file "app/assets/stylesheets/someapplication.css", "body{}"

      app_file "app/assets/javascripts/something.min.js", "alert();"
      app_file "app/assets/stylesheets/something.min.css", "body{}"

      app_file "app/assets/javascripts/something.else.js.erb", "alert();"
      app_file "app/assets/stylesheets/something.else.css.erb", "body{}"

      images_should_compile = ["a.png", "happyface.png", "happy_face.png", "happy.face.png",
                               "happy-face.png", "happy.happy_face.png", "happy_happy.face.png",
                               "happy.happy.face.png", "-happy.png", "-happy.face.png",
                               "_happy.face.png", "_happy.png"]

      images_should_compile.each do |filename|
        app_file "app/assets/images/#{filename}", "happy"
      end

      precompile!

      images_should_compile = ["a-*.png", "happyface-*.png", "happy_face-*.png", "happy.face-*.png",
                               "happy-face-*.png", "happy.happy_face-*.png", "happy_happy.face-*.png",
                               "happy.happy.face-*.png", "-happy-*.png", "-happy.face-*.png",
                               "_happy.face-*.png", "_happy-*.png"]

      images_should_compile.each do |filename|
        assert_file_exists("#{app_path}/public/assets/#{filename}")
      end

      assert_file_exists("#{app_path}/public/assets/application-*.js")
      assert_file_exists("#{app_path}/public/assets/application-*.css")

      assert_no_file_exists("#{app_path}/public/assets/someapplication-*.js")
      assert_no_file_exists("#{app_path}/public/assets/someapplication-*.css")

      assert_no_file_exists("#{app_path}/public/assets/something.min-*.js")
      assert_no_file_exists("#{app_path}/public/assets/something.min-*.css")

      assert_no_file_exists("#{app_path}/public/assets/something.else-*.js")
      assert_no_file_exists("#{app_path}/public/assets/something.else-*.css")
    end

    test "precompile something.js for directory containing index file" do
      add_to_config "config.assets.precompile = [ 'something.js' ]"
      app_file "app/assets/javascripts/something/index.js.erb", "alert();"

      precompile!

      assert_file_exists("#{app_path}/public/assets/something/index-*.js")
    end

    test "precompile use assets defined in app env config" do
      add_to_env_config "production", 'config.assets.precompile = [ "something.js" ]'
      app_file "app/assets/javascripts/something.js.erb", "alert();"

      precompile! RAILS_ENV: "production"

      assert_file_exists("#{app_path}/public/assets/something-*.js")
    end

    test "sprockets cache is not shared between environments" do
      app_file "app/assets/images/rails.png", "notactuallyapng"
      app_file "app/assets/stylesheets/application.css.erb", "body { background: '<%= asset_path('rails.png') %>'; }"
      add_to_env_config "production", 'config.assets.prefix = "production_assets"'

      precompile!

      assert_file_exists("#{app_path}/public/assets/application-*.css")

      file = Dir["#{app_path}/public/assets/application-*.css"].first
      assert_match(/assets\/rails-([0-z]+)\.png/, File.read(file))

      precompile! RAILS_ENV: "production"

      assert_file_exists("#{app_path}/public/production_assets/application-*.css")

      file = Dir["#{app_path}/public/production_assets/application-*.css"].first
      assert_match(/production_assets\/rails-([0-z]+)\.png/, File.read(file))
    end

    test "precompile use assets defined in app config and reassigned in app env config" do
      add_to_config 'config.assets.precompile = [ "something_manifest.js" ]'
      add_to_env_config "production", 'config.assets.precompile += [ "another_manifest.js" ]'

      app_file "app/assets/config/something_manifest.js", "//= link something.js"
      app_file "app/assets/config/another_manifest.js", "//= link another.js"

      app_file "app/assets/javascripts/something.js.erb", "alert();"
      app_file "app/assets/javascripts/another.js.erb", "alert();"

      precompile! RAILS_ENV: "production"

      assert_file_exists("#{app_path}/public/assets/something_manifest-*.js")
      assert_file_exists("#{app_path}/public/assets/something-*.js")
      assert_file_exists("#{app_path}/public/assets/another_manifest-*.js")
      assert_file_exists("#{app_path}/public/assets/another-*.js")
    end

    test "asset pipeline should use a Sprockets::CachedEnvironment when config.assets.digest is true" do
      add_to_config "config.action_controller.perform_caching = false"
      add_to_env_config "production", "config.assets.compile = true"

      # Load app env
      app "production"

      assert_equal Sprockets::CachedEnvironment, Rails.application.assets.class
    end

    test "precompile creates a manifest file with all the assets listed" do
      app_file "app/assets/images/rails.png", "notactuallyapng"
      app_file "app/assets/stylesheets/application.css.erb", "<%= asset_path('rails.png') %>"
      app_file "app/assets/javascripts/application.js", "alert();"

      precompile!

      manifest = Dir["#{app_path}/public/assets/.sprockets-manifest-*.json"].first
      assets = ActiveSupport::JSON.decode(File.read(manifest))
      assert_match(/application-([0-z]+)\.js/, assets["assets"]["application.js"])
      assert_match(/application-([0-z]+)\.css/, assets["assets"]["application.css"])
    end

    test "the manifest file should be saved by default in the same assets folder" do
      app_file "app/assets/javascripts/application.js", "alert();"
      add_to_config "config.assets.prefix = '/x'"

      precompile!

      manifest = Dir["#{app_path}/public/x/.sprockets-manifest-*.json"].first
      assets = ActiveSupport::JSON.decode(File.read(manifest))
      assert_match(/application-([0-z]+)\.js/, assets["assets"]["application.js"])
    end

    test "assets do not require any assets group gem when manifest file is present" do
      app_file "app/assets/javascripts/application.js", "alert();"
      add_to_env_config "production", "config.public_file_server.enabled = true"

      precompile! RAILS_ENV: "production"

      manifest = Dir["#{app_path}/public/assets/.sprockets-manifest-*.json"].first
      assets = ActiveSupport::JSON.decode(File.read(manifest))
      asset_path = assets["assets"]["application.js"]

      # Load app env
      app "production"

      # Checking if Uglifier is defined we can know if Sprockets was reached or not
      assert !defined?(Uglifier)
      get "/assets/#{asset_path}"
      assert_match "alert()", last_response.body
      assert !defined?(Uglifier)
    end

    test "precompile properly refers files referenced with asset_path" do
      app_file "app/assets/images/rails.png", "notactuallyapng"
      app_file "app/assets/stylesheets/application.css.erb", "p { background-image: url(<%= asset_path('rails.png') %>) }"

      precompile!

      file = Dir["#{app_path}/public/assets/application-*.css"].first
      assert_match(/\/assets\/rails-([0-z]+)\.png/, File.read(file))
    end

    test "precompile shouldn't use the digests present in manifest.json" do
      app_file "app/assets/images/rails.png", "notactuallyapng"

      app_file "app/assets/stylesheets/application.css.erb", "p { background-image: url(<%= asset_path('rails.png') %>) }"

      precompile! RAILS_ENV: "production"

      manifest = Dir["#{app_path}/public/assets/.sprockets-manifest-*.json"].first
      assets = ActiveSupport::JSON.decode(File.read(manifest))
      asset_path = assets["assets"]["application.css"]

      app_file "app/assets/images/rails.png", "p { url: change }"

      precompile!

      assets = ActiveSupport::JSON.decode(File.read(manifest))
      assert_not_equal asset_path, assets["assets"]["application.css"]
    end

    test "precompile appends the MD5 hash to files referenced with asset_path and run in production with digest true" do
      app_file "app/assets/images/rails.png", "notactuallyapng"
      app_file "app/assets/stylesheets/application.css.erb", "p { background-image: url(<%= asset_path('rails.png') %>) }"

      precompile! RAILS_ENV: "production"

      file = Dir["#{app_path}/public/assets/application-*.css"].first
      assert_match(/\/assets\/rails-([0-z]+)\.png/, File.read(file))
    end

    test "precompile should handle utf8 filenames" do
      filename = "レイルズ.png"
      app_file "app/assets/images/#{filename}", "not an image really"
      app_file "app/assets/config/manifest.js", "//= link_tree ../images"
      add_to_config "config.assets.precompile = %w(manifest.js)"

      precompile!

      manifest = Dir["#{app_path}/public/assets/.sprockets-manifest-*.json"].first
      assets = ActiveSupport::JSON.decode(File.read(manifest))
      assert asset_path = assets["assets"].find { |(k, _)| k && k =~ /.png/ }[1]

      # Load app env
      app "development"

      get "/assets/#{URI.parser.escape(asset_path)}"
      assert_match "not an image really", last_response.body
      assert_file_exists("#{app_path}/public/assets/#{asset_path}")
    end

    test "assets are cleaned up properly" do
      app_file "public/assets/application.js", "alert();"
      app_file "public/assets/application.css", "a { color: green; }"
      app_file "public/assets/subdir/broken.png", "not really an image file"

      clean_assets!

      files = Dir["#{app_path}/public/assets/**/*"]
      assert_equal 0, files.length, "Expected no assets, but found #{files.join(', ')}"
    end

    test "assets routes are not drawn when compilation is disabled" do
      app_file "app/assets/javascripts/demo.js.erb", "<%= :alert %>();"
      add_to_config "config.assets.compile = false"

      # Load app env
      app "production"

      get "/assets/demo.js"
      assert_equal 404, last_response.status
    end

    test "does not stream session cookies back" do
      app_file "app/assets/javascripts/demo.js.erb", "<%= :alert %>();"

      app_file "config/routes.rb", <<-RUBY
        Rails.application.routes.draw do
          get '/omg', :to => "omg#index"
        end
      RUBY

      add_to_env_config "development", "config.assets.digest = false"

      # Load app env
      app "development"

      class ::OmgController < ActionController::Base
        def index
          flash[:cool_story] = true
          render text: "ok"
        end
      end

      get "/omg"
      assert_equal "ok", last_response.body

      get "/assets/demo.js"
      assert_match "alert()", last_response.body
      assert_equal nil, last_response.headers["Set-Cookie"]
    end

    test "files in any assets/ directories are not added to Sprockets" do
      %w[app lib vendor].each do |dir|
        app_file "#{dir}/assets/#{dir}_test.erb", "testing"
      end

      app_file "app/assets/javascripts/demo.js", "alert();"

      add_to_env_config "development", "config.assets.digest = false"

      # Load app env
      app "development"

      get "/assets/demo.js"
      assert_match "alert();", last_response.body
      assert_equal 200, last_response.status
    end

    test "assets are concatenated when debug is off and compile is off either if debug_assets param is provided" do
      app_with_assets_in_view

      # config.assets.debug and config.assets.compile are false for production environment
      precompile! RAILS_ENV: "production"

      # Load app env
      app "production"

      class ::PostsController < ActionController::Base ; end

      # the debug_assets params isn't used if compile is off
      get "/posts?debug_assets=true"
      assert_match(/<script src="\/assets\/application-([0-z]+)\.js"><\/script>/, last_response.body)
      assert_no_match(/<script src="\/assets\/xmlhr-([0-z]+)\.js"><\/script>/, last_response.body)
    end

    test "assets can access model information when precompiling" do
      app_file "app/models/post.rb", "class Post; end"
      app_file "app/assets/javascripts/application.js", "//= require_tree ."
      app_file "app/assets/javascripts/xmlhr.js.erb", "<%= Post.name %>"

      precompile!

      assert_match(/Post;/, File.read(Dir["#{app_path}/public/assets/application-*.js"].first))
    end

    test "initialization on the assets group should set assets_dir" do
      require "#{app_path}/config/application"
      Rails.application.initialize!(:assets)
      assert_not_nil Rails.application.config.action_controller.assets_dir
    end

    test "enhancements to assets:precompile should only run once" do
      app_file "lib/tasks/enhance.rake", "Rake::Task['assets:precompile'].enhance { puts 'enhancement' }"
      output = precompile!
      assert_equal 1, output.scan("enhancement").size
    end

    test "digested assets are not mistakenly removed" do
      app_file "app/assets/application.js", "alert();"
      add_to_config "config.assets.compile = true"

      precompile!

      files = Dir["#{app_path}/public/assets/application-*.js"]
      assert_equal 1, files.length, "Expected digested application.js asset to be generated, but none found"
    end

    test "digested assets are removed from configured path" do
      app_file "public/production_assets/application.js", "alert();"
      add_to_env_config "production", "config.assets.prefix = 'production_assets'"

      ENV["RAILS_ENV"] = nil

      clean_assets!

      files = Dir["#{app_path}/public/production_assets/application-*.js"]
      assert_equal 0, files.length, "Expected application.js asset to be removed, but still exists"
    end

    test "asset urls should use the request's protocol by default" do
      app_with_assets_in_view
      add_to_config "config.asset_host = 'example.com'"
      add_to_env_config "development", "config.assets.digest = false"

      # Load app env
      app "development"

      class ::PostsController < ActionController::Base; end

      get "/posts", {}, "HTTPS"=>"off"
      assert_match('src="http://example.com/assets/application.self.js', last_response.body)
      get "/posts", {}, "HTTPS"=>"on"
      assert_match('src="https://example.com/assets/application.self.js', last_response.body)
    end

    test "asset urls should be protocol-relative if no request is in scope" do
      app_file "app/assets/images/rails.png", "notreallyapng"
      app_file "app/assets/javascripts/image_loader.js.erb", "var src='<%= image_path('rails.png') %>';"
      add_to_config "config.assets.precompile = %w{rails.png image_loader.js}"
      add_to_config "config.asset_host = 'example.com'"
      add_to_env_config "development", "config.assets.digest = false"

      precompile!

      assert_match "src='//example.com/assets/rails.png'", File.read(Dir["#{app_path}/public/assets/image_loader-*.js"].first)
    end

    test "asset paths should use RAILS_RELATIVE_URL_ROOT by default" do
      ENV["RAILS_RELATIVE_URL_ROOT"] = "/sub/uri"
      app_file "app/assets/images/rails.png", "notreallyapng"
      app_file "app/assets/javascripts/app.js.erb", "var src='<%= image_path('rails.png') %>';"
      add_to_config "config.assets.precompile = %w{rails.png app.js}"
      add_to_env_config "development", "config.assets.digest = false"

      precompile!

      assert_match "src='/sub/uri/assets/rails.png'", File.read(Dir["#{app_path}/public/assets/app-*.js"].first)
    end

    private

      def app_with_assets_in_view
        app_file "app/assets/javascripts/application.js", "//= require_tree ."
        app_file "app/assets/javascripts/xmlhr.js", "function f1() { alert(); }"
        app_file "app/views/posts/index.html.erb", "<%= javascript_include_tag 'application' %>"

        app_file "config/routes.rb", <<-RUBY
        Rails.application.routes.draw do
          get '/posts', :to => "posts#index"
        end
      RUBY
      end
  end
end
require "active_support/core_ext/array/extract_options"
require "active_support/core_ext/hash/keys"
require "active_support/core_ext/regexp"
require "action_view/helpers/asset_url_helper"
require "action_view/helpers/tag_helper"

module ActionView
  # = Action View Asset Tag Helpers
  module Helpers #:nodoc:
    # This module provides methods for generating HTML that links views to assets such
    # as images, JavaScripts, stylesheets, and feeds. These methods do not verify
    # the assets exist before linking to them:
    #
    #   image_tag("rails.png")
    #   # => <img alt="Rails" src="/assets/rails.png" />
    #   stylesheet_link_tag("application")
    #   # => <link href="/assets/application.css?body=1" media="screen" rel="stylesheet" />
    module AssetTagHelper
      extend ActiveSupport::Concern

      include AssetUrlHelper
      include TagHelper

      # Returns an HTML script tag for each of the +sources+ provided.
      #
      # Sources may be paths to JavaScript files. Relative paths are assumed to be relative
      # to <tt>assets/javascripts</tt>, full paths are assumed to be relative to the document
      # root. Relative paths are idiomatic, use absolute paths only when needed.
      #
      # When passing paths, the ".js" extension is optional.  If you do not want ".js"
      # appended to the path <tt>extname: false</tt> can be set on the options.
      #
      # You can modify the HTML attributes of the script tag by passing a hash as the
      # last argument.
      #
      # When the Asset Pipeline is enabled, you can pass the name of your manifest as
      # source, and include other JavaScript or CoffeeScript files inside the manifest.
      #
      #   javascript_include_tag "xmlhr"
      #   # => <script src="/assets/xmlhr.js?1284139606"></script>
      #
      #   javascript_include_tag "template.jst", extname: false
      #   # => <script src="/assets/template.jst?1284139606"></script>
      #
      #   javascript_include_tag "xmlhr.js"
      #   # => <script src="/assets/xmlhr.js?1284139606"></script>
      #
      #   javascript_include_tag "common.javascript", "/elsewhere/cools"
      #   # => <script src="/assets/common.javascript?1284139606"></script>
      #   #    <script src="/elsewhere/cools.js?1423139606"></script>
      #
      #   javascript_include_tag "http://www.example.com/xmlhr"
      #   # => <script src="http://www.example.com/xmlhr"></script>
      #
      #   javascript_include_tag "http://www.example.com/xmlhr.js"
      #   # => <script src="http://www.example.com/xmlhr.js"></script>
      def javascript_include_tag(*sources)
        options = sources.extract_options!.stringify_keys
        path_options = options.extract!("protocol", "extname", "host").symbolize_keys
        sources.uniq.map { |source|
          tag_options = {
            "src" => path_to_javascript(source, path_options)
          }.merge!(options)
          content_tag("script".freeze, "", tag_options)
        }.join("\n").html_safe
      end

      # Returns a stylesheet link tag for the sources specified as arguments. If
      # you don't specify an extension, <tt>.css</tt> will be appended automatically.
      # You can modify the link attributes by passing a hash as the last argument.
      # For historical reasons, the 'media' attribute will always be present and defaults
      # to "screen", so you must explicitly set it to "all" for the stylesheet(s) to
      # apply to all media types.
      #
      #   stylesheet_link_tag "style"
      #   # => <link href="/assets/style.css" media="screen" rel="stylesheet" />
      #
      #   stylesheet_link_tag "style.css"
      #   # => <link href="/assets/style.css" media="screen" rel="stylesheet" />
      #
      #   stylesheet_link_tag "http://www.example.com/style.css"
      #   # => <link href="http://www.example.com/style.css" media="screen" rel="stylesheet" />
      #
      #   stylesheet_link_tag "style", media: "all"
      #   # => <link href="/assets/style.css" media="all" rel="stylesheet" />
      #
      #   stylesheet_link_tag "style", media: "print"
      #   # => <link href="/assets/style.css" media="print" rel="stylesheet" />
      #
      #   stylesheet_link_tag "random.styles", "/css/stylish"
      #   # => <link href="/assets/random.styles" media="screen" rel="stylesheet" />
      #   #    <link href="/css/stylish.css" media="screen" rel="stylesheet" />
      def stylesheet_link_tag(*sources)
        options = sources.extract_options!.stringify_keys
        path_options = options.extract!("protocol", "host").symbolize_keys

        sources.uniq.map { |source|
          tag_options = {
            "rel" => "stylesheet",
            "media" => "screen",
            "href" => path_to_stylesheet(source, path_options)
          }.merge!(options)
          tag(:link, tag_options)
        }.join("\n").html_safe
      end

      # Returns a link tag that browsers and feed readers can use to auto-detect
      # an RSS or Atom feed. The +type+ can either be <tt>:rss</tt> (default) or
      # <tt>:atom</tt>. Control the link options in url_for format using the
      # +url_options+. You can modify the LINK tag itself in +tag_options+.
      #
      # ==== Options
      #
      # * <tt>:rel</tt>  - Specify the relation of this link, defaults to "alternate"
      # * <tt>:type</tt>  - Override the auto-generated mime type
      # * <tt>:title</tt>  - Specify the title of the link, defaults to the +type+
      #
      # ==== Examples
      #
      #   auto_discovery_link_tag
      #   # => <link rel="alternate" type="application/rss+xml" title="RSS" href="http://www.currenthost.com/controller/action" />
      #   auto_discovery_link_tag(:atom)
      #   # => <link rel="alternate" type="application/atom+xml" title="ATOM" href="http://www.currenthost.com/controller/action" />
      #   auto_discovery_link_tag(:rss, {action: "feed"})
      #   # => <link rel="alternate" type="application/rss+xml" title="RSS" href="http://www.currenthost.com/controller/feed" />
      #   auto_discovery_link_tag(:rss, {action: "feed"}, {title: "My RSS"})
      #   # => <link rel="alternate" type="application/rss+xml" title="My RSS" href="http://www.currenthost.com/controller/feed" />
      #   auto_discovery_link_tag(:rss, {controller: "news", action: "feed"})
      #   # => <link rel="alternate" type="application/rss+xml" title="RSS" href="http://www.currenthost.com/news/feed" />
      #   auto_discovery_link_tag(:rss, "http://www.example.com/feed.rss", {title: "Example RSS"})
      #   # => <link rel="alternate" type="application/rss+xml" title="Example RSS" href="http://www.example.com/feed.rss" />
      def auto_discovery_link_tag(type = :rss, url_options = {}, tag_options = {})
        if !(type == :rss || type == :atom) && tag_options[:type].blank?
          raise ArgumentError.new("You should pass :type tag_option key explicitly, because you have passed #{type} type other than :rss or :atom.")
        end

        tag(
          "link",
          "rel"   => tag_options[:rel] || "alternate",
          "type"  => tag_options[:type] || Template::Types[type].to_s,
          "title" => tag_options[:title] || type.to_s.upcase,
          "href"  => url_options.is_a?(Hash) ? url_for(url_options.merge(only_path: false)) : url_options
        )
      end

      # Returns a link tag for a favicon managed by the asset pipeline.
      #
      # If a page has no link like the one generated by this helper, browsers
      # ask for <tt>/favicon.ico</tt> automatically, and cache the file if the
      # request succeeds. If the favicon changes it is hard to get it updated.
      #
      # To have better control applications may let the asset pipeline manage
      # their favicon storing the file under <tt>app/assets/images</tt>, and
      # using this helper to generate its corresponding link tag.
      #
      # The helper gets the name of the favicon file as first argument, which
      # defaults to "favicon.ico", and also supports +:rel+ and +:type+ options
      # to override their defaults, "shortcut icon" and "image/x-icon"
      # respectively:
      #
      #   favicon_link_tag
      #   # => <link href="/assets/favicon.ico" rel="shortcut icon" type="image/x-icon" />
      #
      #   favicon_link_tag 'myicon.ico'
      #   # => <link href="/assets/myicon.ico" rel="shortcut icon" type="image/x-icon" />
      #
      # Mobile Safari looks for a different link tag, pointing to an image that
      # will be used if you add the page to the home screen of an iOS device.
      # The following call would generate such a tag:
      #
      #   favicon_link_tag 'mb-icon.png', rel: 'apple-touch-icon', type: 'image/png'
      #   # => <link href="/assets/mb-icon.png" rel="apple-touch-icon" type="image/png" />
      def favicon_link_tag(source="favicon.ico", options={})
        tag("link", {
          rel: "shortcut icon",
          type: "image/x-icon",
          href: path_to_image(source)
        }.merge!(options.symbolize_keys))
      end

      # Returns an HTML image tag for the +source+. The +source+ can be a full
      # path or a file.
      #
      # ==== Options
      #
      # You can add HTML attributes using the +options+. The +options+ supports
      # two additional keys for convenience and conformance:
      #
      # * <tt>:alt</tt>  - If no alt text is given, the file name part of the
      #   +source+ is used (capitalized and without the extension)
      # * <tt>:size</tt> - Supplied as "{Width}x{Height}" or "{Number}", so "30x45" becomes
      #   width="30" and height="45", and "50" becomes width="50" and height="50".
      #   <tt>:size</tt> will be ignored if the value is not in the correct format.
      #
      # ==== Examples
      #
      #   image_tag("icon")
      #   # => <img alt="Icon" src="/assets/icon" />
      #   image_tag("icon.png")
      #   # => <img alt="Icon" src="/assets/icon.png" />
      #   image_tag("icon.png", size: "16x10", alt: "Edit Entry")
      #   # => <img src="/assets/icon.png" width="16" height="10" alt="Edit Entry" />
      #   image_tag("/icons/icon.gif", size: "16")
      #   # => <img src="/icons/icon.gif" width="16" height="16" alt="Icon" />
      #   image_tag("/icons/icon.gif", height: '32', width: '32')
      #   # => <img alt="Icon" height="32" src="/icons/icon.gif" width="32" />
      #   image_tag("/icons/icon.gif", class: "menu_icon")
      #   # => <img alt="Icon" class="menu_icon" src="/icons/icon.gif" />
      #   image_tag("/icons/icon.gif", data: { title: 'Rails Application' })
      #   # => <img data-title="Rails Application" src="/icons/icon.gif" />
      def image_tag(source, options={})
        options = options.symbolize_keys
        check_for_image_tag_errors(options)

        src = options[:src] = path_to_image(source)

        unless src.start_with?("cid:") || src.start_with?("data:") || src.blank?
          options[:alt] = options.fetch(:alt) { image_alt(src) }
        end

        options[:width], options[:height] = extract_dimensions(options.delete(:size)) if options[:size]
        tag("img", options)
      end

      # Returns a string suitable for an HTML image tag alt attribute.
      # The +src+ argument is meant to be an image file path.
      # The method removes the basename of the file path and the digest,
      # if any. It also removes hyphens and underscores from file names and
      # replaces them with spaces, returning a space-separated, titleized
      # string.
      #
      # ==== Examples
      #
      #   image_alt('rails.png')
      #   # => Rails
      #
      #   image_alt('hyphenated-file-name.png')
      #   # => Hyphenated file name
      #
      #   image_alt('underscored_file_name.png')
      #   # => Underscored file name
      def image_alt(src)
        File.basename(src, ".*".freeze).sub(/-[[:xdigit:]]{32,64}\z/, "".freeze).tr("-_".freeze, " ".freeze).capitalize
      end

      # Returns an HTML video tag for the +sources+. If +sources+ is a string,
      # a single video tag will be returned. If +sources+ is an array, a video
      # tag with nested source tags for each source will be returned. The
      # +sources+ can be full paths or files that exists in your public videos
      # directory.
      #
      # ==== Options
      # You can add HTML attributes using the +options+. The +options+ supports
      # two additional keys for convenience and conformance:
      #
      # * <tt>:poster</tt> - Set an image (like a screenshot) to be shown
      #   before the video loads. The path is calculated like the +src+ of +image_tag+.
      # * <tt>:size</tt> - Supplied as "{Width}x{Height}" or "{Number}", so "30x45" becomes
      #   width="30" and height="45", and "50" becomes width="50" and height="50".
      #   <tt>:size</tt> will be ignored if the value is not in the correct format.
      #
      # ==== Examples
      #
      #   video_tag("trailer")
      #   # => <video src="/videos/trailer"></video>
      #   video_tag("trailer.ogg")
      #   # => <video src="/videos/trailer.ogg"></video>
      #   video_tag("trailer.ogg", controls: true, preload: 'none')
      #   # => <video preload="none" controls="controls" src="/videos/trailer.ogg" ></video>
      #   video_tag("trailer.m4v", size: "16x10", poster: "screenshot.png")
      #   # => <video src="/videos/trailer.m4v" width="16" height="10" poster="/assets/screenshot.png"></video>
      #   video_tag("/trailers/hd.avi", size: "16x16")
      #   # => <video src="/trailers/hd.avi" width="16" height="16"></video>
      #   video_tag("/trailers/hd.avi", size: "16")
      #   # => <video height="16" src="/trailers/hd.avi" width="16"></video>
      #   video_tag("/trailers/hd.avi", height: '32', width: '32')
      #   # => <video height="32" src="/trailers/hd.avi" width="32"></video>
      #   video_tag("trailer.ogg", "trailer.flv")
      #   # => <video><source src="/videos/trailer.ogg" /><source src="/videos/trailer.flv" /></video>
      #   video_tag(["trailer.ogg", "trailer.flv"])
      #   # => <video><source src="/videos/trailer.ogg" /><source src="/videos/trailer.flv" /></video>
      #   video_tag(["trailer.ogg", "trailer.flv"], size: "160x120")
      #   # => <video height="120" width="160"><source src="/videos/trailer.ogg" /><source src="/videos/trailer.flv" /></video>
      def video_tag(*sources)
        multiple_sources_tag("video", sources) do |options|
          options[:poster] = path_to_image(options[:poster]) if options[:poster]
          options[:width], options[:height] = extract_dimensions(options.delete(:size)) if options[:size]
        end
      end

      # Returns an HTML audio tag for the +source+.
      # The +source+ can be full path or file that exists in
      # your public audios directory.
      #
      #   audio_tag("sound")
      #   # => <audio src="/audios/sound"></audio>
      #   audio_tag("sound.wav")
      #   # => <audio src="/audios/sound.wav"></audio>
      #   audio_tag("sound.wav", autoplay: true, controls: true)
      #   # => <audio autoplay="autoplay" controls="controls" src="/audios/sound.wav"></audio>
      #   audio_tag("sound.wav", "sound.mid")
      #   # => <audio><source src="/audios/sound.wav" /><source src="/audios/sound.mid" /></audio>
      def audio_tag(*sources)
        multiple_sources_tag("audio", sources)
      end

      private
        def multiple_sources_tag(type, sources)
          options = sources.extract_options!.symbolize_keys
          sources.flatten!

          yield options if block_given?

          if sources.size > 1
            content_tag(type, options) do
              safe_join sources.map { |source| tag("source", src: send("path_to_#{type}", source)) }
            end
          else
            options[:src] = send("path_to_#{type}", sources.first)
            content_tag(type, nil, options)
          end
        end

        def extract_dimensions(size)
          size = size.to_s
          if /\A\d+x\d+\z/.match?(size)
            size.split("x")
          elsif /\A\d+\z/.match?(size)
            [size, size]
          end
        end

        def check_for_image_tag_errors(options)
          if options[:size] && (options[:height] || options[:width])
            raise ArgumentError, "Cannot pass a :size option with a :height or :width option"
          end
        end
    end
  end
end
require "abstract_unit"
require "active_support/ordered_options"

class AssetTagHelperTest < ActionView::TestCase
  tests ActionView::Helpers::AssetTagHelper

  attr_reader :request

  def setup
    super

    @controller = BasicController.new

    @request = Class.new do
      attr_accessor :script_name
      def protocol() "http://" end
      def ssl?() false end
      def host_with_port() "localhost" end
      def base_url() "http://www.example.com" end
    end.new

    @controller.request = @request
  end

  def url_for(*args)
    "http://www.example.com"
  end

  AssetPathToTag = {
    %(asset_path(""))             => %(),
    %(asset_path("   "))          => %(),
    %(asset_path("foo"))          => %(/foo),
    %(asset_path("style.css"))    => %(/style.css),
    %(asset_path("xmlhr.js"))     => %(/xmlhr.js),
    %(asset_path("xml.png"))      => %(/xml.png),
    %(asset_path("dir/xml.png"))  => %(/dir/xml.png),
    %(asset_path("/dir/xml.png")) => %(/dir/xml.png),

    %(asset_path("script.min"))       => %(/script.min),
    %(asset_path("script.min.js"))    => %(/script.min.js),
    %(asset_path("style.min"))        => %(/style.min),
    %(asset_path("style.min.css"))    => %(/style.min.css),

    %(asset_path("http://www.outside.com/image.jpg")) => %(http://www.outside.com/image.jpg),
    %(asset_path("HTTP://www.outside.com/image.jpg")) => %(HTTP://www.outside.com/image.jpg),

    %(asset_path("style", type: :stylesheet)) => %(/stylesheets/style.css),
    %(asset_path("xmlhr", type: :javascript)) => %(/javascripts/xmlhr.js),
    %(asset_path("xml.png", type: :image))    => %(/images/xml.png)
  }

  AutoDiscoveryToTag = {
    %(auto_discovery_link_tag) => %(<link href="http://www.example.com" rel="alternate" title="RSS" type="application/rss+xml" />),
    %(auto_discovery_link_tag(:rss)) => %(<link href="http://www.example.com" rel="alternate" title="RSS" type="application/rss+xml" />),
    %(auto_discovery_link_tag(:atom)) => %(<link href="http://www.example.com" rel="alternate" title="ATOM" type="application/atom+xml" />),
    %(auto_discovery_link_tag(:rss, :action => "feed")) => %(<link href="http://www.example.com" rel="alternate" title="RSS" type="application/rss+xml" />),
    %(auto_discovery_link_tag(:rss, "http://localhost/feed")) => %(<link href="http://localhost/feed" rel="alternate" title="RSS" type="application/rss+xml" />),
    %(auto_discovery_link_tag(:rss, "//localhost/feed")) => %(<link href="//localhost/feed" rel="alternate" title="RSS" type="application/rss+xml" />),
    %(auto_discovery_link_tag(:rss, {:action => "feed"}, {:title => "My RSS"})) => %(<link href="http://www.example.com" rel="alternate" title="My RSS" type="application/rss+xml" />),
    %(auto_discovery_link_tag(:rss, {}, {:title => "My RSS"})) => %(<link href="http://www.example.com" rel="alternate" title="My RSS" type="application/rss+xml" />),
    %(auto_discovery_link_tag(nil, {}, {:type => "text/html"})) => %(<link href="http://www.example.com" rel="alternate" title="" type="text/html" />),
    %(auto_discovery_link_tag(nil, {}, {:title => "No stream.. really", :type => "text/html"})) => %(<link href="http://www.example.com" rel="alternate" title="No stream.. really" type="text/html" />),
    %(auto_discovery_link_tag(:rss, {}, {:title => "My RSS", :type => "text/html"})) => %(<link href="http://www.example.com" rel="alternate" title="My RSS" type="text/html" />),
    %(auto_discovery_link_tag(:atom, {}, {:rel => "Not so alternate"})) => %(<link href="http://www.example.com" rel="Not so alternate" title="ATOM" type="application/atom+xml" />),
  }

  JavascriptPathToTag = {
    %(javascript_path("xmlhr")) => %(/javascripts/xmlhr.js),
    %(javascript_path("super/xmlhr")) => %(/javascripts/super/xmlhr.js),
    %(javascript_path("/super/xmlhr.js")) => %(/super/xmlhr.js),
    %(javascript_path("xmlhr.min")) => %(/javascripts/xmlhr.min.js),
    %(javascript_path("xmlhr.min.js")) => %(/javascripts/xmlhr.min.js),

    %(javascript_path("xmlhr.js?123")) => %(/javascripts/xmlhr.js?123),
    %(javascript_path("xmlhr.js?body=1")) => %(/javascripts/xmlhr.js?body=1),
    %(javascript_path("xmlhr.js#hash")) => %(/javascripts/xmlhr.js#hash),
    %(javascript_path("xmlhr.js?123#hash")) => %(/javascripts/xmlhr.js?123#hash)
  }

  PathToJavascriptToTag = {
    %(path_to_javascript("xmlhr")) => %(/javascripts/xmlhr.js),
    %(path_to_javascript("super/xmlhr")) => %(/javascripts/super/xmlhr.js),
    %(path_to_javascript("/super/xmlhr.js")) => %(/super/xmlhr.js)
  }

  JavascriptUrlToTag = {
    %(javascript_url("xmlhr")) => %(http://www.example.com/javascripts/xmlhr.js),
    %(javascript_url("super/xmlhr")) => %(http://www.example.com/javascripts/super/xmlhr.js),
    %(javascript_url("/super/xmlhr.js")) => %(http://www.example.com/super/xmlhr.js)
  }

  UrlToJavascriptToTag = {
    %(url_to_javascript("xmlhr")) => %(http://www.example.com/javascripts/xmlhr.js),
    %(url_to_javascript("super/xmlhr")) => %(http://www.example.com/javascripts/super/xmlhr.js),
    %(url_to_javascript("/super/xmlhr.js")) => %(http://www.example.com/super/xmlhr.js)
  }

  JavascriptIncludeToTag = {
    %(javascript_include_tag("bank")) => %(<script src="/javascripts/bank.js" ></script>),
    %(javascript_include_tag("bank.js")) => %(<script src="/javascripts/bank.js" ></script>),
    %(javascript_include_tag("bank", :lang => "vbscript")) => %(<script lang="vbscript" src="/javascripts/bank.js" ></script>),
    %(javascript_include_tag("bank", :host => "assets.example.com")) => %(<script src="http://assets.example.com/javascripts/bank.js"></script>),

    %(javascript_include_tag("http://example.com/all")) => %(<script src="http://example.com/all"></script>),
    %(javascript_include_tag("http://example.com/all.js")) => %(<script src="http://example.com/all.js"></script>),
    %(javascript_include_tag("//example.com/all.js")) => %(<script src="//example.com/all.js"></script>),
  }

  StylePathToTag = {
    %(stylesheet_path("bank")) => %(/stylesheets/bank.css),
    %(stylesheet_path("bank.css")) => %(/stylesheets/bank.css),
    %(stylesheet_path('subdir/subdir')) => %(/stylesheets/subdir/subdir.css),
    %(stylesheet_path('/subdir/subdir.css')) => %(/subdir/subdir.css),
    %(stylesheet_path("style.min")) => %(/stylesheets/style.min.css),
    %(stylesheet_path("style.min.css")) => %(/stylesheets/style.min.css)
  }

  PathToStyleToTag = {
    %(path_to_stylesheet("style")) => %(/stylesheets/style.css),
    %(path_to_stylesheet("style.css")) => %(/stylesheets/style.css),
    %(path_to_stylesheet('dir/file')) => %(/stylesheets/dir/file.css),
    %(path_to_stylesheet('/dir/file.rcss', :extname => false)) => %(/dir/file.rcss),
    %(path_to_stylesheet('/dir/file', :extname => '.rcss')) => %(/dir/file.rcss)
  }

  StyleUrlToTag = {
    %(stylesheet_url("bank")) => %(http://www.example.com/stylesheets/bank.css),
    %(stylesheet_url("bank.css")) => %(http://www.example.com/stylesheets/bank.css),
    %(stylesheet_url('subdir/subdir')) => %(http://www.example.com/stylesheets/subdir/subdir.css),
    %(stylesheet_url('/subdir/subdir.css')) => %(http://www.example.com/subdir/subdir.css)
  }

  UrlToStyleToTag = {
    %(url_to_stylesheet("style")) => %(http://www.example.com/stylesheets/style.css),
    %(url_to_stylesheet("style.css")) => %(http://www.example.com/stylesheets/style.css),
    %(url_to_stylesheet('dir/file')) => %(http://www.example.com/stylesheets/dir/file.css),
    %(url_to_stylesheet('/dir/file.rcss', :extname => false)) => %(http://www.example.com/dir/file.rcss),
    %(url_to_stylesheet('/dir/file', :extname => '.rcss')) => %(http://www.example.com/dir/file.rcss)
  }

  StyleLinkToTag = {
    %(stylesheet_link_tag("bank")) => %(<link href="/stylesheets/bank.css" media="screen" rel="stylesheet" />),
    %(stylesheet_link_tag("bank.css")) => %(<link href="/stylesheets/bank.css" media="screen" rel="stylesheet" />),
    %(stylesheet_link_tag("/elsewhere/file")) => %(<link href="/elsewhere/file.css" media="screen" rel="stylesheet" />),
    %(stylesheet_link_tag("subdir/subdir")) => %(<link href="/stylesheets/subdir/subdir.css" media="screen" rel="stylesheet" />),
    %(stylesheet_link_tag("bank", :media => "all")) => %(<link href="/stylesheets/bank.css" media="all" rel="stylesheet" />),
    %(stylesheet_link_tag("bank", :host => "assets.example.com")) => %(<link href="http://assets.example.com/stylesheets/bank.css" media="screen" rel="stylesheet" />),

    %(stylesheet_link_tag("http://www.example.com/styles/style")) => %(<link href="http://www.example.com/styles/style" media="screen" rel="stylesheet" />),
    %(stylesheet_link_tag("http://www.example.com/styles/style.css")) => %(<link href="http://www.example.com/styles/style.css" media="screen" rel="stylesheet" />),
    %(stylesheet_link_tag("//www.example.com/styles/style.css")) => %(<link href="//www.example.com/styles/style.css" media="screen" rel="stylesheet" />),
  }

  ImagePathToTag = {
    %(image_path("xml"))          => %(/images/xml),
    %(image_path("xml.png"))      => %(/images/xml.png),
    %(image_path("dir/xml.png"))  => %(/images/dir/xml.png),
    %(image_path("/dir/xml.png")) => %(/dir/xml.png)
  }

  PathToImageToTag = {
    %(path_to_image("xml"))          => %(/images/xml),
    %(path_to_image("xml.png"))      => %(/images/xml.png),
    %(path_to_image("dir/xml.png"))  => %(/images/dir/xml.png),
    %(path_to_image("/dir/xml.png")) => %(/dir/xml.png)
  }

  ImageUrlToTag = {
    %(image_url("xml"))          => %(http://www.example.com/images/xml),
    %(image_url("xml.png"))      => %(http://www.example.com/images/xml.png),
    %(image_url("dir/xml.png"))  => %(http://www.example.com/images/dir/xml.png),
    %(image_url("/dir/xml.png")) => %(http://www.example.com/dir/xml.png)
  }

  UrlToImageToTag = {
    %(url_to_image("xml"))          => %(http://www.example.com/images/xml),
    %(url_to_image("xml.png"))      => %(http://www.example.com/images/xml.png),
    %(url_to_image("dir/xml.png"))  => %(http://www.example.com/images/dir/xml.png),
    %(url_to_image("/dir/xml.png")) => %(http://www.example.com/dir/xml.png)
  }

  ImageLinkToTag = {
    %(image_tag("xml.png")) => %(<img alt="Xml" src="/images/xml.png" />),
    %(image_tag("rss.gif", :alt => "rss syndication")) => %(<img alt="rss syndication" src="/images/rss.gif" />),
    %(image_tag("gold.png", :size => "20")) => %(<img alt="Gold" height="20" src="/images/gold.png" width="20" />),
    %(image_tag("gold.png", :size => 20)) => %(<img alt="Gold" height="20" src="/images/gold.png" width="20" />),
    %(image_tag("gold.png", :size => "45x70")) => %(<img alt="Gold" height="70" src="/images/gold.png" width="45" />),
    %(image_tag("gold.png", "size" => "45x70")) => %(<img alt="Gold" height="70" src="/images/gold.png" width="45" />),
    %(image_tag("error.png", "size" => "45 x 70")) => %(<img alt="Error" src="/images/error.png" />),
    %(image_tag("error.png", "size" => "x")) => %(<img alt="Error" src="/images/error.png" />),
    %(image_tag("google.com.png")) => %(<img alt="Google.com" src="/images/google.com.png" />),
    %(image_tag("slash..png")) => %(<img alt="Slash." src="/images/slash..png" />),
    %(image_tag(".pdf.png")) => %(<img alt=".pdf" src="/images/.pdf.png" />),
    %(image_tag("http://www.rubyonrails.com/images/rails.png")) => %(<img alt="Rails" src="http://www.rubyonrails.com/images/rails.png" />),
    %(image_tag("//www.rubyonrails.com/images/rails.png")) => %(<img alt="Rails" src="//www.rubyonrails.com/images/rails.png" />),
    %(image_tag("mouse.png", :alt => nil)) => %(<img src="/images/mouse.png" />),
    %(image_tag("data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==", :alt => nil)) => %(<img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" />),
    %(image_tag("")) => %(<img src="" />),
    %(image_tag("gold.png", data: { title: 'Rails Application' })) => %(<img data-title="Rails Application" src="/images/gold.png" alt="Gold" />)
  }

  FaviconLinkToTag = {
    %(favicon_link_tag) => %(<link href="/images/favicon.ico" rel="shortcut icon" type="image/x-icon" />),
    %(favicon_link_tag 'favicon.ico') => %(<link href="/images/favicon.ico" rel="shortcut icon" type="image/x-icon" />),
    %(favicon_link_tag 'favicon.ico', :rel => 'foo') => %(<link href="/images/favicon.ico" rel="foo" type="image/x-icon" />),
    %(favicon_link_tag 'favicon.ico', :rel => 'foo', :type => 'bar') => %(<link href="/images/favicon.ico" rel="foo" type="bar" />),
    %(favicon_link_tag 'mb-icon.png', :rel => 'apple-touch-icon', :type => 'image/png') => %(<link href="/images/mb-icon.png" rel="apple-touch-icon" type="image/png" />)
  }

  VideoPathToTag = {
    %(video_path("xml"))          => %(/videos/xml),
    %(video_path("xml.ogg"))      => %(/videos/xml.ogg),
    %(video_path("dir/xml.ogg"))  => %(/videos/dir/xml.ogg),
    %(video_path("/dir/xml.ogg")) => %(/dir/xml.ogg)
  }

  PathToVideoToTag = {
    %(path_to_video("xml"))          => %(/videos/xml),
    %(path_to_video("xml.ogg"))      => %(/videos/xml.ogg),
    %(path_to_video("dir/xml.ogg"))  => %(/videos/dir/xml.ogg),
    %(path_to_video("/dir/xml.ogg")) => %(/dir/xml.ogg)
  }

  VideoUrlToTag = {
    %(video_url("xml"))          => %(http://www.example.com/videos/xml),
    %(video_url("xml.ogg"))      => %(http://www.example.com/videos/xml.ogg),
    %(video_url("dir/xml.ogg"))  => %(http://www.example.com/videos/dir/xml.ogg),
    %(video_url("/dir/xml.ogg")) => %(http://www.example.com/dir/xml.ogg)
  }

  UrlToVideoToTag = {
    %(url_to_video("xml"))          => %(http://www.example.com/videos/xml),
    %(url_to_video("xml.ogg"))      => %(http://www.example.com/videos/xml.ogg),
    %(url_to_video("dir/xml.ogg"))  => %(http://www.example.com/videos/dir/xml.ogg),
    %(url_to_video("/dir/xml.ogg")) => %(http://www.example.com/dir/xml.ogg)
  }

  VideoLinkToTag = {
    %(video_tag("xml.ogg")) => %(<video src="/videos/xml.ogg"></video>),
    %(video_tag("rss.m4v", :autoplay => true, :controls => true)) => %(<video autoplay="autoplay" controls="controls" src="/videos/rss.m4v"></video>),
    %(video_tag("rss.m4v", :preload => 'none')) => %(<video preload="none" src="/videos/rss.m4v"></video>),
    %(video_tag("gold.m4v", :size => "160x120")) => %(<video height="120" src="/videos/gold.m4v" width="160"></video>),
    %(video_tag("gold.m4v", "size" => "320x240")) => %(<video height="240" src="/videos/gold.m4v" width="320"></video>),
    %(video_tag("trailer.ogg", :poster => "screenshot.png")) => %(<video poster="/images/screenshot.png" src="/videos/trailer.ogg"></video>),
    %(video_tag("error.avi", "size" => "100")) => %(<video height="100" src="/videos/error.avi" width="100"></video>),
    %(video_tag("error.avi", "size" => 100)) => %(<video height="100" src="/videos/error.avi" width="100"></video>),
    %(video_tag("error.avi", "size" => "100 x 100")) => %(<video src="/videos/error.avi"></video>),
    %(video_tag("error.avi", "size" => "x")) => %(<video src="/videos/error.avi"></video>),
    %(video_tag("http://media.rubyonrails.org/video/rails_blog_2.mov")) => %(<video src="http://media.rubyonrails.org/video/rails_blog_2.mov"></video>),
    %(video_tag("//media.rubyonrails.org/video/rails_blog_2.mov")) => %(<video src="//media.rubyonrails.org/video/rails_blog_2.mov"></video>),
    %(video_tag("multiple.ogg", "multiple.avi")) => %(<video><source src="/videos/multiple.ogg" /><source src="/videos/multiple.avi" /></video>),
    %(video_tag(["multiple.ogg", "multiple.avi"])) => %(<video><source src="/videos/multiple.ogg" /><source src="/videos/multiple.avi" /></video>),
    %(video_tag(["multiple.ogg", "multiple.avi"], :size => "160x120", :controls => true)) => %(<video controls="controls" height="120" width="160"><source src="/videos/multiple.ogg" /><source src="/videos/multiple.avi" /></video>)
  }

  AudioPathToTag = {
    %(audio_path("xml"))          => %(/audios/xml),
    %(audio_path("xml.wav"))      => %(/audios/xml.wav),
    %(audio_path("dir/xml.wav"))  => %(/audios/dir/xml.wav),
    %(audio_path("/dir/xml.wav")) => %(/dir/xml.wav)
  }

  PathToAudioToTag = {
    %(path_to_audio("xml"))          => %(/audios/xml),
    %(path_to_audio("xml.wav"))      => %(/audios/xml.wav),
    %(path_to_audio("dir/xml.wav"))  => %(/audios/dir/xml.wav),
    %(path_to_audio("/dir/xml.wav")) => %(/dir/xml.wav)
  }

  AudioUrlToTag = {
    %(audio_url("xml"))          => %(http://www.example.com/audios/xml),
    %(audio_url("xml.wav"))      => %(http://www.example.com/audios/xml.wav),
    %(audio_url("dir/xml.wav"))  => %(http://www.example.com/audios/dir/xml.wav),
    %(audio_url("/dir/xml.wav")) => %(http://www.example.com/dir/xml.wav)
  }

  UrlToAudioToTag = {
    %(url_to_audio("xml"))          => %(http://www.example.com/audios/xml),
    %(url_to_audio("xml.wav"))      => %(http://www.example.com/audios/xml.wav),
    %(url_to_audio("dir/xml.wav"))  => %(http://www.example.com/audios/dir/xml.wav),
    %(url_to_audio("/dir/xml.wav")) => %(http://www.example.com/dir/xml.wav)
  }

  AudioLinkToTag = {
    %(audio_tag("xml.wav")) => %(<audio src="/audios/xml.wav"></audio>),
    %(audio_tag("rss.wav", :autoplay => true, :controls => true)) => %(<audio autoplay="autoplay" controls="controls" src="/audios/rss.wav"></audio>),
    %(audio_tag("http://media.rubyonrails.org/audio/rails_blog_2.mov")) => %(<audio src="http://media.rubyonrails.org/audio/rails_blog_2.mov"></audio>),
    %(audio_tag("//media.rubyonrails.org/audio/rails_blog_2.mov")) => %(<audio src="//media.rubyonrails.org/audio/rails_blog_2.mov"></audio>),
    %(audio_tag("audio.mp3", "audio.ogg")) => %(<audio><source src="/audios/audio.mp3" /><source src="/audios/audio.ogg" /></audio>),
    %(audio_tag(["audio.mp3", "audio.ogg"])) => %(<audio><source src="/audios/audio.mp3" /><source src="/audios/audio.ogg" /></audio>),
    %(audio_tag(["audio.mp3", "audio.ogg"], :preload => 'none', :controls => true)) => %(<audio preload="none" controls="controls"><source src="/audios/audio.mp3" /><source src="/audios/audio.ogg" /></audio>)
  }

  FontPathToTag = {
    %(font_path("font.eot")) => %(/fonts/font.eot),
    %(font_path("font.eot#iefix")) => %(/fonts/font.eot#iefix),
    %(font_path("font.woff")) => %(/fonts/font.woff),
    %(font_path("font.ttf")) => %(/fonts/font.ttf),
    %(font_path("font.ttf?123")) => %(/fonts/font.ttf?123)
  }

  def test_autodiscovery_link_tag_with_unknown_type_but_not_pass_type_option_key
    assert_raise(ArgumentError) do
      auto_discovery_link_tag(:xml)
    end
  end

  def test_autodiscovery_link_tag_with_unknown_type
    result = auto_discovery_link_tag(:xml, "/feed.xml", type: "application/xml")
    expected = %(<link href="/feed.xml" rel="alternate" title="XML" type="application/xml" />)
    assert_dom_equal expected, result
  end

  def test_asset_path_tag
    AssetPathToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_asset_path_tag_raises_an_error_for_nil_source
    e = assert_raise(ArgumentError) { asset_path(nil) }
    assert_equal("nil is not a valid asset source", e.message)
  end

  def test_asset_path_tag_to_not_create_duplicate_slashes
    @controller.config.asset_host = "host/"
    assert_dom_equal("http://host/foo", asset_path("foo"))

    @controller.config.relative_url_root = "/some/root/"
    assert_dom_equal("http://host/some/root/foo", asset_path("foo"))
  end

  def test_compute_asset_public_path
    assert_equal "/robots.txt", compute_asset_path("robots.txt")
    assert_equal "/robots.txt", compute_asset_path("/robots.txt")
    assert_equal "/javascripts/foo.js", compute_asset_path("foo.js", type: :javascript)
    assert_equal "/javascripts/foo.js", compute_asset_path("/foo.js", type: :javascript)
    assert_equal "/stylesheets/foo.css", compute_asset_path("foo.css", type: :stylesheet)
  end

  def test_auto_discovery_link_tag
    AutoDiscoveryToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_javascript_path
    JavascriptPathToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_path_to_javascript_alias_for_javascript_path
    PathToJavascriptToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_javascript_url
    JavascriptUrlToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_url_to_javascript_alias_for_javascript_url
    UrlToJavascriptToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_javascript_include_tag
    JavascriptIncludeToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_javascript_include_tag_with_missing_source
    assert_nothing_raised {
      javascript_include_tag("missing_security_guard")
    }

    assert_nothing_raised {
      javascript_include_tag("http://example.com/css/missing_security_guard")
    }
  end

  def test_javascript_include_tag_is_html_safe
    assert javascript_include_tag("prototype").html_safe?
  end

  def test_javascript_include_tag_relative_protocol
    @controller.config.asset_host = "assets.example.com"
    assert_dom_equal %(<script src="//assets.example.com/javascripts/prototype.js"></script>), javascript_include_tag("prototype", protocol: :relative)
  end

  def test_javascript_include_tag_default_protocol
    @controller.config.asset_host = "assets.example.com"
    @controller.config.default_asset_host_protocol = :relative
    assert_dom_equal %(<script src="//assets.example.com/javascripts/prototype.js"></script>), javascript_include_tag("prototype")
  end

  def test_stylesheet_path
    StylePathToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_path_to_stylesheet_alias_for_stylesheet_path
    PathToStyleToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_stylesheet_url
    StyleUrlToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_url_to_stylesheet_alias_for_stylesheet_url
    UrlToStyleToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_stylesheet_link_tag
    StyleLinkToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_stylesheet_link_tag_with_missing_source
    assert_nothing_raised {
      stylesheet_link_tag("missing_security_guard")
    }

    assert_nothing_raised {
      stylesheet_link_tag("http://example.com/css/missing_security_guard")
    }
  end

  def test_stylesheet_link_tag_is_html_safe
    assert stylesheet_link_tag("dir/file").html_safe?
    assert stylesheet_link_tag("dir/other/file", "dir/file2").html_safe?
  end

  def test_stylesheet_link_tag_escapes_options
    assert_dom_equal %(<link href="/file.css" media="&lt;script&gt;" rel="stylesheet" />), stylesheet_link_tag("/file", media: "<script>")
  end

  def test_stylesheet_link_tag_should_not_output_the_same_asset_twice
    assert_dom_equal %(<link href="/stylesheets/wellington.css" media="screen" rel="stylesheet" />\n<link href="/stylesheets/amsterdam.css" media="screen" rel="stylesheet" />), stylesheet_link_tag("wellington", "wellington", "amsterdam")
  end

  def test_stylesheet_link_tag_with_relative_protocol
    @controller.config.asset_host = "assets.example.com"
    assert_dom_equal %(<link href="//assets.example.com/stylesheets/wellington.css" media="screen" rel="stylesheet" />), stylesheet_link_tag("wellington", protocol: :relative)
  end

  def test_stylesheet_link_tag_with_default_protocol
    @controller.config.asset_host = "assets.example.com"
    @controller.config.default_asset_host_protocol = :relative
    assert_dom_equal %(<link href="//assets.example.com/stylesheets/wellington.css" media="screen" rel="stylesheet" />), stylesheet_link_tag("wellington")
  end

  def test_image_path
    ImagePathToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_path_to_image_alias_for_image_path
    PathToImageToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_image_url
    ImageUrlToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_url_to_image_alias_for_image_url
    UrlToImageToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_image_alt
    [nil, "/", "/foo/bar/", "foo/bar/"].each do |prefix|
      assert_equal "Rails", image_alt("#{prefix}rails.png")
      assert_equal "Rails", image_alt("#{prefix}rails-9c0a079bdd7701d7e729bd956823d153.png")
      assert_equal "Rails", image_alt("#{prefix}rails-f56ef62bc41b040664e801a38f068082a75d506d9048307e8096737463503d0b.png")
      assert_equal "Long file name with hyphens", image_alt("#{prefix}long-file-name-with-hyphens.png")
      assert_equal "Long file name with underscores", image_alt("#{prefix}long_file_name_with_underscores.png")
    end
  end

  def test_image_tag
    ImageLinkToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_image_tag_does_not_modify_options
    options = {size: "16x10"}
    image_tag("icon", options)
    assert_equal({size: "16x10"}, options)
  end

  def test_image_tag_raises_an_error_for_competing_size_arguments
    exception = assert_raise(ArgumentError) do
      image_tag("gold.png", height: "100", width: "200", size: "45x70")
    end

    assert_equal("Cannot pass a :size option with a :height or :width option", exception.message)
  end

  def test_favicon_link_tag
    FaviconLinkToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_video_path
    VideoPathToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_path_to_video_alias_for_video_path
    PathToVideoToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_video_url
    VideoUrlToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_url_to_video_alias_for_video_url
    UrlToVideoToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_video_tag
    VideoLinkToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_audio_path
    AudioPathToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_path_to_audio_alias_for_audio_path
    PathToAudioToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_audio_url
    AudioUrlToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_url_to_audio_alias_for_audio_url
    UrlToAudioToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_audio_tag
    AudioLinkToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_font_path
    FontPathToTag.each { |method, tag| assert_dom_equal(tag, eval(method)) }
  end

  def test_video_audio_tag_does_not_modify_options
    options = {autoplay: true}
    video_tag("video", options)
    assert_equal({autoplay: true}, options)
    audio_tag("audio", options)
    assert_equal({autoplay: true}, options)
  end

  def test_image_tag_interpreting_email_cid_correctly
    # An inline image has no need for an alt tag to be automatically generated from the cid:
    assert_equal '<img src="cid:thi%25%25sis@acontentid" />', image_tag("cid:thi%25%25sis@acontentid")
  end

  def test_image_tag_interpreting_email_adding_optional_alt_tag
    assert_equal '<img alt="Image" src="cid:thi%25%25sis@acontentid" />', image_tag("cid:thi%25%25sis@acontentid", alt: "Image")
  end

  def test_should_not_modify_source_string
    source = "/images/rails.png"
    copy = source.dup
    image_tag(source)
    assert_equal copy, source
  end

  class PlaceholderImage
    def blank?; true; end
    def to_s; "no-image-yet.png"; end
  end
  def test_image_tag_with_blank_placeholder
    assert_equal '<img alt="" src="/images/no-image-yet.png" />', image_tag(PlaceholderImage.new, alt: "")
  end
  def test_image_path_with_blank_placeholder
    assert_equal "/images/no-image-yet.png", image_path(PlaceholderImage.new)
  end

  def test_image_path_with_asset_host_proc_returning_nil
    @controller.config.asset_host = Proc.new do |source|
      unless source.end_with?("tiff")
        "cdn.example.com"
      end
    end

    assert_equal "/images/file.tiff", image_path("file.tiff")
    assert_equal "http://cdn.example.com/images/file.png", image_path("file.png")
  end

  def test_image_url_with_asset_host_proc_returning_nil
    @controller.config.asset_host = Proc.new { nil }
    @controller.request = Struct.new(:base_url, :script_name).new("http://www.example.com", nil)

    assert_equal "/images/rails.png", image_path("rails.png")
    assert_equal "http://www.example.com/images/rails.png", image_url("rails.png")
  end

  def test_caching_image_path_with_caching_and_proc_asset_host_using_request
    @controller.config.asset_host = Proc.new do |source, request|
      if request.ssl?
        "#{request.protocol}#{request.host_with_port}"
      else
        "#{request.protocol}assets#{source.length}.example.com"
      end
    end

    @controller.request.stub(:ssl?, false) do
      assert_equal "http://assets15.example.com/images/xml.png", image_path("xml.png")
    end

    @controller.request.stub(:ssl?, true) do
      assert_equal "http://localhost/images/xml.png", image_path("xml.png")
    end
  end
end

class AssetTagHelperNonVhostTest < ActionView::TestCase
  tests ActionView::Helpers::AssetTagHelper

  attr_reader :request

  def setup
    super
    @controller = BasicController.new
    @controller.config.relative_url_root = "/collaboration/hieraki"

    @request = Struct.new(:protocol, :base_url).new("gopher://", "gopher://www.example.com")
    @controller.request = @request
  end

  def url_for(options)
    "http://www.example.com/collaboration/hieraki"
  end

  def test_should_compute_proper_path
    assert_dom_equal(%(<link href="http://www.example.com/collaboration/hieraki" rel="alternate" title="RSS" type="application/rss+xml" />), auto_discovery_link_tag)
    assert_dom_equal(%(/collaboration/hieraki/javascripts/xmlhr.js), javascript_path("xmlhr"))
    assert_dom_equal(%(/collaboration/hieraki/stylesheets/style.css), stylesheet_path("style"))
    assert_dom_equal(%(/collaboration/hieraki/images/xml.png), image_path("xml.png"))
  end

  def test_should_return_nothing_if_asset_host_isnt_configured
    assert_equal nil, compute_asset_host("foo")
  end

  def test_should_current_request_host_is_always_returned_for_request
    assert_equal "gopher://www.example.com", compute_asset_host("foo", protocol: :request)
  end

  def test_should_return_custom_host_if_passed_in_options
    assert_equal "http://custom.example.com", compute_asset_host("foo", host: "http://custom.example.com")
  end

  def test_should_ignore_relative_root_path_on_complete_url
    assert_dom_equal(%(http://www.example.com/images/xml.png), image_path("http://www.example.com/images/xml.png"))
  end

  def test_should_return_simple_string_asset_host
    @controller.config.asset_host = "assets.example.com"
    assert_equal "gopher://assets.example.com", compute_asset_host("foo")
  end

  def test_should_return_relative_asset_host
    @controller.config.asset_host = "assets.example.com"
    assert_equal "//assets.example.com", compute_asset_host("foo", protocol: :relative)
  end

  def test_should_return_custom_protocol_asset_host
    @controller.config.asset_host = "assets.example.com"
    assert_equal "ftp://assets.example.com", compute_asset_host("foo", protocol: "ftp")
  end

  def test_should_compute_proper_path_with_asset_host
    @controller.config.asset_host = "assets.example.com"
    assert_dom_equal(%(<link href="http://www.example.com/collaboration/hieraki" rel="alternate" title="RSS" type="application/rss+xml" />), auto_discovery_link_tag)
    assert_dom_equal(%(gopher://assets.example.com/collaboration/hieraki/javascripts/xmlhr.js), javascript_path("xmlhr"))
    assert_dom_equal(%(gopher://assets.example.com/collaboration/hieraki/stylesheets/style.css), stylesheet_path("style"))
    assert_dom_equal(%(gopher://assets.example.com/collaboration/hieraki/images/xml.png), image_path("xml.png"))
  end

  def test_should_compute_proper_path_with_asset_host_and_default_protocol
    @controller.config.asset_host = "assets.example.com"
    @controller.config.default_asset_host_protocol = :request
    assert_dom_equal(%(gopher://assets.example.com/collaboration/hieraki/javascripts/xmlhr.js), javascript_path("xmlhr"))
    assert_dom_equal(%(gopher://assets.example.com/collaboration/hieraki/stylesheets/style.css), stylesheet_path("style"))
    assert_dom_equal(%(gopher://assets.example.com/collaboration/hieraki/images/xml.png), image_path("xml.png"))
  end

  def test_should_compute_proper_url_with_asset_host
    @controller.config.asset_host = "assets.example.com"
    assert_dom_equal(%(<link href="http://www.example.com/collaboration/hieraki" rel="alternate" title="RSS" type="application/rss+xml" />), auto_discovery_link_tag)
    assert_dom_equal(%(gopher://assets.example.com/collaboration/hieraki/javascripts/xmlhr.js), javascript_url("xmlhr"))
    assert_dom_equal(%(gopher://assets.example.com/collaboration/hieraki/stylesheets/style.css), stylesheet_url("style"))
    assert_dom_equal(%(gopher://assets.example.com/collaboration/hieraki/images/xml.png), image_url("xml.png"))
  end

  def test_should_compute_proper_url_with_asset_host_and_default_protocol
    @controller.config.asset_host = "assets.example.com"
    @controller.config.default_asset_host_protocol = :request
    assert_dom_equal(%(gopher://assets.example.com/collaboration/hieraki/javascripts/xmlhr.js), javascript_url("xmlhr"))
    assert_dom_equal(%(gopher://assets.example.com/collaboration/hieraki/stylesheets/style.css), stylesheet_url("style"))
    assert_dom_equal(%(gopher://assets.example.com/collaboration/hieraki/images/xml.png), image_url("xml.png"))
  end

  def test_should_return_asset_host_with_protocol
    @controller.config.asset_host = "http://assets.example.com"
    assert_equal "http://assets.example.com", compute_asset_host("foo")
  end

  def test_should_ignore_asset_host_on_complete_url
    @controller.config.asset_host = "http://assets.example.com"
    assert_dom_equal(%(<link href="http://bar.example.com/stylesheets/style.css" media="screen" rel="stylesheet" />), stylesheet_link_tag("http://bar.example.com/stylesheets/style.css"))
  end

  def test_should_ignore_asset_host_on_scheme_relative_url
    @controller.config.asset_host = "http://assets.example.com"
    assert_dom_equal(%(<link href="//bar.example.com/stylesheets/style.css" media="screen" rel="stylesheet" />), stylesheet_link_tag("//bar.example.com/stylesheets/style.css"))
  end

  def test_should_wildcard_asset_host
    @controller.config.asset_host = "http://a%d.example.com"
    assert_match(%r(http://a[0123].example.com), compute_asset_host("foo"))
  end

  def test_should_wildcard_asset_host_between_zero_and_four
    @controller.config.asset_host = "http://a%d.example.com"
    assert_match(%r(http://a[0123].example.com/collaboration/hieraki/images/xml.png), image_path("xml.png"))
    assert_match(%r(http://a[0123].example.com/collaboration/hieraki/images/xml.png), image_url("xml.png"))
  end

  def test_asset_host_without_protocol_should_be_protocol_relative
    @controller.config.asset_host = "a.example.com"
    assert_equal "gopher://a.example.com/collaboration/hieraki/images/xml.png", image_path("xml.png")
    assert_equal "gopher://a.example.com/collaboration/hieraki/images/xml.png", image_url("xml.png")
  end

  def test_asset_host_without_protocol_should_be_protocol_relative_even_if_path_present
    @controller.config.asset_host = "a.example.com/files/go/here"
    assert_equal "gopher://a.example.com/files/go/here/collaboration/hieraki/images/xml.png", image_path("xml.png")
    assert_equal "gopher://a.example.com/files/go/here/collaboration/hieraki/images/xml.png", image_url("xml.png")
  end

  def test_assert_css_and_js_of_the_same_name_return_correct_extension
    assert_dom_equal(%(/collaboration/hieraki/javascripts/foo.js), javascript_path("foo"))
    assert_dom_equal(%(/collaboration/hieraki/stylesheets/foo.css), stylesheet_path("foo"))
  end
end

class AssetUrlHelperControllerTest < ActionView::TestCase
  tests ActionView::Helpers::AssetUrlHelper

  def setup
    super

    @controller = BasicController.new
    @controller.extend ActionView::Helpers::AssetUrlHelper

    @request = Class.new do
      attr_accessor :script_name
      def protocol() "http://" end
      def ssl?() false end
      def host_with_port() "www.example.com" end
      def base_url() "http://www.example.com" end
    end.new

    @controller.request = @request
  end

  def test_asset_path
    assert_equal "/foo", @controller.asset_path("foo")
  end

  def test_asset_url
    assert_equal "http://www.example.com/foo", @controller.asset_url("foo")
  end
end

class AssetUrlHelperEmptyModuleTest < ActionView::TestCase
  tests ActionView::Helpers::AssetUrlHelper

  def setup
    super

    @module = Module.new
    @module.extend ActionView::Helpers::AssetUrlHelper
  end

  def test_asset_path
    assert_equal "/foo", @module.asset_path("foo")
  end

  def test_asset_url
    assert_equal "/foo", @module.asset_url("foo")
  end

  def test_asset_url_with_request
    @module.instance_eval do
      def request
        Struct.new(:base_url, :script_name).new("http://www.example.com", nil)
      end
    end

    assert @module.request
    assert_equal "http://www.example.com/foo", @module.asset_url("foo")
  end

  def test_asset_url_with_config_asset_host
    @module.instance_eval do
      def config
        Struct.new(:asset_host).new("http://www.example.com")
      end
    end

    assert @module.config.asset_host
    assert_equal "http://www.example.com/foo", @module.asset_url("foo")
  end

  def test_asset_url_with_custom_asset_host
    @module.instance_eval do
      def config
        Struct.new(:asset_host).new("http://www.example.com")
      end
    end

    assert @module.config.asset_host
    assert_equal "http://custom.example.com/foo", @module.asset_url("foo", host: "http://custom.example.com")
  end
end
require "zlib"
require "active_support/core_ext/regexp"

module ActionView
  # = Action View Asset URL Helpers
  module Helpers
    # This module provides methods for generating asset paths and
    # urls.
    #
    #   image_path("rails.png")
    #   # => "/assets/rails.png"
    #
    #   image_url("rails.png")
    #   # => "http://www.example.com/assets/rails.png"
    #
    # === Using asset hosts
    #
    # By default, Rails links to these assets on the current host in the public
    # folder, but you can direct Rails to link to assets from a dedicated asset
    # server by setting <tt>ActionController::Base.asset_host</tt> in the application
    # configuration, typically in <tt>config/environments/production.rb</tt>.
    # For example, you'd define <tt>assets.example.com</tt> to be your asset
    # host this way, inside the <tt>configure</tt> block of your environment-specific
    # configuration files or <tt>config/application.rb</tt>:
    #
    #   config.action_controller.asset_host = "assets.example.com"
    #
    # Helpers take that into account:
    #
    #   image_tag("rails.png")
    #   # => <img alt="Rails" src="http://assets.example.com/assets/rails.png" />
    #   stylesheet_link_tag("application")
    #   # => <link href="http://assets.example.com/assets/application.css" media="screen" rel="stylesheet" />
    #
    # Browsers open a limited number of simultaneous connections to a single
    # host. The exact number varies by browser and version. This limit may cause
    # some asset downloads to wait for previous assets to finish before they can
    # begin. You can use the <tt>%d</tt> wildcard in the +asset_host+ to
    # distribute the requests over four hosts. For example,
    # <tt>assets%d.example.com<tt> will spread the asset requests over
    # "assets0.example.com", ..., "assets3.example.com".
    #
    #   image_tag("rails.png")
    #   # => <img alt="Rails" src="http://assets0.example.com/assets/rails.png" />
    #   stylesheet_link_tag("application")
    #   # => <link href="http://assets2.example.com/assets/application.css" media="screen" rel="stylesheet" />
    #
    # This may improve the asset loading performance of your application.
    # It is also possible the combination of additional connection overhead
    # (DNS, SSL) and the overall browser connection limits may result in this
    # solution being slower. You should be sure to measure your actual
    # performance across targeted browsers both before and after this change.
    #
    # To implement the corresponding hosts you can either setup four actual
    # hosts or use wildcard DNS to CNAME the wildcard to a single asset host.
    # You can read more about setting up your DNS CNAME records from your ISP.
    #
    # Note: This is purely a browser performance optimization and is not meant
    # for server load balancing. See http://www.die.net/musings/page_load_time/
    # for background and http://www.browserscope.org/?category=network for
    # connection limit data.
    #
    # Alternatively, you can exert more control over the asset host by setting
    # +asset_host+ to a proc like this:
    #
    #   ActionController::Base.asset_host = Proc.new { |source|
    #     "http://assets#{Digest::MD5.hexdigest(source).to_i(16) % 2 + 1}.example.com"
    #   }
    #   image_tag("rails.png")
    #   # => <img alt="Rails" src="http://assets1.example.com/assets/rails.png" />
    #   stylesheet_link_tag("application")
    #   # => <link href="http://assets2.example.com/assets/application.css" media="screen" rel="stylesheet" />
    #
    # The example above generates "http://assets1.example.com" and
    # "http://assets2.example.com". This option is useful for example if
    # you need fewer/more than four hosts, custom host names, etc.
    #
    # As you see the proc takes a +source+ parameter. That's a string with the
    # absolute path of the asset, for example "/assets/rails.png".
    #
    #    ActionController::Base.asset_host = Proc.new { |source|
    #      if source.ends_with?('.css')
    #        "http://stylesheets.example.com"
    #      else
    #        "http://assets.example.com"
    #      end
    #    }
    #   image_tag("rails.png")
    #   # => <img alt="Rails" src="http://assets.example.com/assets/rails.png" />
    #   stylesheet_link_tag("application")
    #   # => <link href="http://stylesheets.example.com/assets/application.css" media="screen" rel="stylesheet" />
    #
    # Alternatively you may ask for a second parameter +request+. That one is
    # particularly useful for serving assets from an SSL-protected page. The
    # example proc below disables asset hosting for HTTPS connections, while
    # still sending assets for plain HTTP requests from asset hosts. If you don't
    # have SSL certificates for each of the asset hosts this technique allows you
    # to avoid warnings in the client about mixed media.
    # Note that the request parameter might not be supplied, e.g. when the assets
    # are precompiled via a Rake task. Make sure to use a Proc instead of a lambda,
    # since a Proc allows missing parameters and sets them to nil.
    #
    #   config.action_controller.asset_host = Proc.new { |source, request|
    #     if request && request.ssl?
    #       "#{request.protocol}#{request.host_with_port}"
    #     else
    #       "#{request.protocol}assets.example.com"
    #     end
    #   }
    #
    # You can also implement a custom asset host object that responds to +call+
    # and takes either one or two parameters just like the proc.
    #
    #   config.action_controller.asset_host = AssetHostingWithMinimumSsl.new(
    #     "http://asset%d.example.com", "https://asset1.example.com"
    #   )
    #
    module AssetUrlHelper
      URI_REGEXP = %r{^[-a-z]+://|^(?:cid|data):|^//}i

      # Computes the path to asset in public directory. If :type
      # options is set, a file extension will be appended and scoped
      # to the corresponding public directory.
      #
      # All other asset *_path helpers delegate through this method.
      #
      #   asset_path "application.js"                     # => /assets/application.js
      #   asset_path "application", type: :javascript     # => /assets/application.js
      #   asset_path "application", type: :stylesheet     # => /assets/application.css
      #   asset_path "http://www.example.com/js/xmlhr.js" # => http://www.example.com/js/xmlhr.js
      def asset_path(source, options = {})
        raise ArgumentError, "nil is not a valid asset source" if source.nil?

        source = source.to_s
        return "" if source.blank?
        return source if URI_REGEXP.match?(source)

        tail, source = source[/([\?#].+)$/], source.sub(/([\?#].+)$/, "".freeze)

        if extname = compute_asset_extname(source, options)
          source = "#{source}#{extname}"
        end

        if source[0] != ?/
          source = compute_asset_path(source, options)
        end

        relative_url_root = defined?(config.relative_url_root) && config.relative_url_root
        if relative_url_root
          source = File.join(relative_url_root, source) unless source.starts_with?("#{relative_url_root}/")
        end

        if host = compute_asset_host(source, options)
          source = File.join(host, source)
        end

        "#{source}#{tail}"
      end
      alias_method :path_to_asset, :asset_path # aliased to avoid conflicts with an asset_path named route

      # Computes the full URL to an asset in the public directory. This
      # will use +asset_path+ internally, so most of their behaviors
      # will be the same. If :host options is set, it overwrites global
      # +config.action_controller.asset_host+ setting.
      #
      # All other options provided are forwarded to +asset_path+ call.
      #
      #   asset_url "application.js"                                 # => http://example.com/assets/application.js
      #   asset_url "application.js", host: "http://cdn.example.com" # => http://cdn.example.com/assets/application.js
      #
      def asset_url(source, options = {})
        path_to_asset(source, options.merge(protocol: :request))
      end
      alias_method :url_to_asset, :asset_url # aliased to avoid conflicts with an asset_url named route

      ASSET_EXTENSIONS = {
        javascript: ".js",
        stylesheet: ".css"
      }

      # Compute extname to append to asset path. Returns nil if
      # nothing should be added.
      def compute_asset_extname(source, options = {})
        return if options[:extname] == false
        extname = options[:extname] || ASSET_EXTENSIONS[options[:type]]
        extname if extname && File.extname(source) != extname
      end

      # Maps asset types to public directory.
      ASSET_PUBLIC_DIRECTORIES = {
        audio:      "/audios",
        font:       "/fonts",
        image:      "/images",
        javascript: "/javascripts",
        stylesheet: "/stylesheets",
        video:      "/videos"
      }

      # Computes asset path to public directory. Plugins and
      # extensions can override this method to point to custom assets
      # or generate digested paths or query strings.
      def compute_asset_path(source, options = {})
        dir = ASSET_PUBLIC_DIRECTORIES[options[:type]] || ""
        File.join(dir, source)
      end

      # Pick an asset host for this source. Returns +nil+ if no host is set,
      # the host if no wildcard is set, the host interpolated with the
      # numbers 0-3 if it contains <tt>%d</tt> (the number is the source hash mod 4),
      # or the value returned from invoking call on an object responding to call
      # (proc or otherwise).
      def compute_asset_host(source = "", options = {})
        request = self.request if respond_to?(:request)
        host = options[:host]
        host ||= config.asset_host if defined? config.asset_host

        if host
          if host.respond_to?(:call)
            arity = host.respond_to?(:arity) ? host.arity : host.method(:call).arity
            args = [source]
            args << request if request && (arity > 1 || arity < 0)
            host = host.call(*args)
          elsif host.include?("%d")
            host = host % (Zlib.crc32(source) % 4)
          end
        end

        host ||= request.base_url if request && options[:protocol] == :request
        return unless host

        if URI_REGEXP.match?(host)
          host
        else
          protocol = options[:protocol] || config.default_asset_host_protocol || (request ? :request : :relative)
          case protocol
          when :relative
            "//#{host}"
          when :request
            "#{request.protocol}#{host}"
          else
            "#{protocol}://#{host}"
          end
        end
      end

      # Computes the path to a JavaScript asset in the public javascripts directory.
      # If the +source+ filename has no extension, .js will be appended (except for explicit URIs)
      # Full paths from the document root will be passed through.
      # Used internally by +javascript_include_tag+ to build the script path.
      #
      #   javascript_path "xmlhr"                              # => /assets/xmlhr.js
      #   javascript_path "dir/xmlhr.js"                       # => /assets/dir/xmlhr.js
      #   javascript_path "/dir/xmlhr"                         # => /dir/xmlhr.js
      #   javascript_path "http://www.example.com/js/xmlhr"    # => http://www.example.com/js/xmlhr
      #   javascript_path "http://www.example.com/js/xmlhr.js" # => http://www.example.com/js/xmlhr.js
      def javascript_path(source, options = {})
        path_to_asset(source, {type: :javascript}.merge!(options))
      end
      alias_method :path_to_javascript, :javascript_path # aliased to avoid conflicts with a javascript_path named route

      # Computes the full URL to a JavaScript asset in the public javascripts directory.
      # This will use +javascript_path+ internally, so most of their behaviors will be the same.
      # Since +javascript_url+ is based on +asset_url+ method you can set :host options. If :host
      # options is set, it overwrites global +config.action_controller.asset_host+ setting.
      #
      #   javascript_url "js/xmlhr.js", host: "http://stage.example.com" # => http://stage.example.com/assets/dir/xmlhr.js
      #
      def javascript_url(source, options = {})
        url_to_asset(source, {type: :javascript}.merge!(options))
      end
      alias_method :url_to_javascript, :javascript_url # aliased to avoid conflicts with a javascript_url named route

      # Computes the path to a stylesheet asset in the public stylesheets directory.
      # If the +source+ filename has no extension, .css will be appended (except for explicit URIs).
      # Full paths from the document root will be passed through.
      # Used internally by +stylesheet_link_tag+ to build the stylesheet path.
      #
      #   stylesheet_path "style"                                  # => /assets/style.css
      #   stylesheet_path "dir/style.css"                          # => /assets/dir/style.css
      #   stylesheet_path "/dir/style.css"                         # => /dir/style.css
      #   stylesheet_path "http://www.example.com/css/style"       # => http://www.example.com/css/style
      #   stylesheet_path "http://www.example.com/css/style.css"   # => http://www.example.com/css/style.css
      def stylesheet_path(source, options = {})
        path_to_asset(source, {type: :stylesheet}.merge!(options))
      end
      alias_method :path_to_stylesheet, :stylesheet_path # aliased to avoid conflicts with a stylesheet_path named route

      # Computes the full URL to a stylesheet asset in the public stylesheets directory.
      # This will use +stylesheet_path+ internally, so most of their behaviors will be the same.
      # Since +stylesheet_url+ is based on +asset_url+ method you can set :host options. If :host
      # options is set, it overwrites global +config.action_controller.asset_host+ setting.
      #
      #   stylesheet_url "css/style.css", host: "http://stage.example.com" # => http://stage.example.com/css/style.css
      #
      def stylesheet_url(source, options = {})
        url_to_asset(source, {type: :stylesheet}.merge!(options))
      end
      alias_method :url_to_stylesheet, :stylesheet_url # aliased to avoid conflicts with a stylesheet_url named route

      # Computes the path to an image asset.
      # Full paths from the document root will be passed through.
      # Used internally by +image_tag+ to build the image path:
      #
      #   image_path("edit")                                         # => "/assets/edit"
      #   image_path("edit.png")                                     # => "/assets/edit.png"
      #   image_path("icons/edit.png")                               # => "/assets/icons/edit.png"
      #   image_path("/icons/edit.png")                              # => "/icons/edit.png"
      #   image_path("http://www.example.com/img/edit.png")          # => "http://www.example.com/img/edit.png"
      #
      # If you have images as application resources this method may conflict with their named routes.
      # The alias +path_to_image+ is provided to avoid that. Rails uses the alias internally, and
      # plugin authors are encouraged to do so.
      def image_path(source, options = {})
        path_to_asset(source, {type: :image}.merge!(options))
      end
      alias_method :path_to_image, :image_path # aliased to avoid conflicts with an image_path named route

      # Computes the full URL to an image asset.
      # This will use +image_path+ internally, so most of their behaviors will be the same.
      # Since +image_url+ is based on +asset_url+ method you can set :host options. If :host
      # options is set, it overwrites global +config.action_controller.asset_host+ setting.
      #
      #   image_url "edit.png", host: "http://stage.example.com" # => http://stage.example.com/edit.png
      #
      def image_url(source, options = {})
        url_to_asset(source, {type: :image}.merge!(options))
      end
      alias_method :url_to_image, :image_url # aliased to avoid conflicts with an image_url named route

      # Computes the path to a video asset in the public videos directory.
      # Full paths from the document root will be passed through.
      # Used internally by +video_tag+ to build the video path.
      #
      #   video_path("hd")                                            # => /videos/hd
      #   video_path("hd.avi")                                        # => /videos/hd.avi
      #   video_path("trailers/hd.avi")                               # => /videos/trailers/hd.avi
      #   video_path("/trailers/hd.avi")                              # => /trailers/hd.avi
      #   video_path("http://www.example.com/vid/hd.avi")             # => http://www.example.com/vid/hd.avi
      def video_path(source, options = {})
        path_to_asset(source, {type: :video}.merge!(options))
      end
      alias_method :path_to_video, :video_path # aliased to avoid conflicts with a video_path named route

      # Computes the full URL to a video asset in the public videos directory.
      # This will use +video_path+ internally, so most of their behaviors will be the same.
      # Since +video_url+ is based on +asset_url+ method you can set :host options. If :host
      # options is set, it overwrites global +config.action_controller.asset_host+ setting.
      #
      #   video_url "hd.avi", host: "http://stage.example.com" # => http://stage.example.com/hd.avi
      #
      def video_url(source, options = {})
        url_to_asset(source, {type: :video}.merge!(options))
      end
      alias_method :url_to_video, :video_url # aliased to avoid conflicts with an video_url named route

      # Computes the path to an audio asset in the public audios directory.
      # Full paths from the document root will be passed through.
      # Used internally by +audio_tag+ to build the audio path.
      #
      #   audio_path("horse")                                            # => /audios/horse
      #   audio_path("horse.wav")                                        # => /audios/horse.wav
      #   audio_path("sounds/horse.wav")                                 # => /audios/sounds/horse.wav
      #   audio_path("/sounds/horse.wav")                                # => /sounds/horse.wav
      #   audio_path("http://www.example.com/sounds/horse.wav")          # => http://www.example.com/sounds/horse.wav
      def audio_path(source, options = {})
        path_to_asset(source, {type: :audio}.merge!(options))
      end
      alias_method :path_to_audio, :audio_path # aliased to avoid conflicts with an audio_path named route

      # Computes the full URL to an audio asset in the public audios directory.
      # This will use +audio_path+ internally, so most of their behaviors will be the same.
      # Since +audio_url+ is based on +asset_url+ method you can set :host options. If :host
      # options is set, it overwrites global +config.action_controller.asset_host+ setting.
      #
      #   audio_url "horse.wav", host: "http://stage.example.com" # => http://stage.example.com/horse.wav
      #
      def audio_url(source, options = {})
        url_to_asset(source, {type: :audio}.merge!(options))
      end
      alias_method :url_to_audio, :audio_url # aliased to avoid conflicts with an audio_url named route

      # Computes the path to a font asset.
      # Full paths from the document root will be passed through.
      #
      #   font_path("font")                                           # => /fonts/font
      #   font_path("font.ttf")                                       # => /fonts/font.ttf
      #   font_path("dir/font.ttf")                                   # => /fonts/dir/font.ttf
      #   font_path("/dir/font.ttf")                                  # => /dir/font.ttf
      #   font_path("http://www.example.com/dir/font.ttf")            # => http://www.example.com/dir/font.ttf
      def font_path(source, options = {})
        path_to_asset(source, {type: :font}.merge!(options))
      end
      alias_method :path_to_font, :font_path # aliased to avoid conflicts with an font_path named route

      # Computes the full URL to a font asset.
      # This will use +font_path+ internally, so most of their behaviors will be the same.
      # Since +font_url+ is based on +asset_url+ method you can set :host options. If :host
      # options is set, it overwrites global +config.action_controller.asset_host+ setting.
      #
      #   font_url "font.ttf", host: "http://stage.example.com" # => http://stage.example.com/font.ttf
      #
      def font_url(source, options = {})
        url_to_asset(source, {type: :font}.merge!(options))
      end
      alias_method :url_to_font, :font_url # aliased to avoid conflicts with an font_url named route
    end
  end
end
module ActiveRecord
  module Validations
    class AssociatedValidator < ActiveModel::EachValidator #:nodoc:
      def validate_each(record, attribute, value)
        if Array(value).reject { |r| valid_object?(r) }.any?
          record.errors.add(attribute, :invalid, options.merge(value: value))
        end
      end

      private

        def valid_object?(record)
          (record.respond_to?(:marked_for_destruction?) && record.marked_for_destruction?) || record.valid?
        end
    end

    module ClassMethods
      # Validates whether the associated object or objects are all valid.
      # Works with any kind of association.
      #
      #   class Book < ActiveRecord::Base
      #     has_many :pages
      #     belongs_to :library
      #
      #     validates_associated :pages, :library
      #   end
      #
      # WARNING: This validation must not be used on both ends of an association.
      # Doing so will lead to a circular dependency and cause infinite recursion.
      #
      # NOTE: This validation will not fail if the association hasn't been
      # assigned. If you want to ensure that the association is both present and
      # guaranteed to be valid, you also need to use
      # {validates_presence_of}[rdoc-ref:Validations::ClassMethods#validates_presence_of].
      #
      # Configuration options:
      #
      # * <tt>:message</tt> - A custom error message (default is: "is invalid").
      # * <tt>:on</tt> - Specifies the contexts where this validation is active.
      #   Runs in all validation contexts by default (nil). You can pass a symbol
      #   or an array of symbols. (e.g. <tt>on: :create</tt> or
      #   <tt>on: :custom_validation_context</tt> or
      #   <tt>on: [:create, :custom_validation_context]</tt>)
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def validates_associated(*attr_names)
        validates_with AssociatedValidator, _merge_attributes(attr_names)
      end
    end
  end
end
module ActiveRecord
  class PredicateBuilder
    class AssociationQueryHandler # :nodoc:
      def self.value_for(table, column, value)
        associated_table = table.associated_table(column)
        klass = if associated_table.polymorphic_association? && ::Array === value && value.first.is_a?(Base)
          PolymorphicArrayValue
        else
          AssociationQueryValue
        end

        klass.new(associated_table, value)
      end

      def initialize(predicate_builder)
        @predicate_builder = predicate_builder
      end

      def call(attribute, value)
        queries = {}

        table = value.associated_table
        if value.base_class
          queries[table.association_foreign_type.to_s] = value.base_class.name
        end

        queries[table.association_foreign_key.to_s] = value.ids
        predicate_builder.build_from_hash(queries)
      end

      protected

        attr_reader :predicate_builder
    end

    class AssociationQueryValue # :nodoc:
      attr_reader :associated_table, :value

      def initialize(associated_table, value)
        @associated_table = associated_table
        @value = value
      end

      def ids
        case value
        when Relation
          value.select(primary_key)
        when Array
          value.map { |v| convert_to_id(v) }
        else
          convert_to_id(value)
        end
      end

      def base_class
        if associated_table.polymorphic_association?
          @base_class ||= polymorphic_base_class_from_value
        end
      end

      private

        def primary_key
          associated_table.association_primary_key(base_class)
        end

        def polymorphic_base_class_from_value
          case value
          when Relation
            value.klass.base_class
          when Array
            val = value.compact.first
            val.class.base_class if val.is_a?(Base)
          when Base
            value.class.base_class
          end
        end

        def convert_to_id(value)
          case value
          when Base
            value._read_attribute(primary_key)
          else
            value
          end
        end
    end
  end
end
module ActiveRecord
  module Associations
    class Preloader
      class Association #:nodoc:
        attr_reader :owners, :reflection, :preload_scope, :model, :klass
        attr_reader :preloaded_records

        def initialize(klass, owners, reflection, preload_scope)
          @klass         = klass
          @owners        = owners
          @reflection    = reflection
          @preload_scope = preload_scope
          @model         = owners.first && owners.first.class
          @scope         = nil
          @preloaded_records = []
        end

        def run(preloader)
          preload(preloader)
        end

        def preload(preloader)
          raise NotImplementedError
        end

        def scope
          @scope ||= build_scope
        end

        def records_for(ids)
          query_scope(ids)
        end

        def query_scope(ids)
          scope.where(association_key_name => ids)
        end

        def table
          klass.arel_table
        end

        # The name of the key on the associated records
        def association_key_name
          raise NotImplementedError
        end

        # This is overridden by HABTM as the condition should be on the foreign_key column in
        # the join table
        def association_key
          klass.arel_attribute(association_key_name, table)
        end

        # The name of the key on the model which declares the association
        def owner_key_name
          raise NotImplementedError
        end

        def options
          reflection.options
        end

        private

          def associated_records_by_owner(preloader)
            records = load_records
            owners.each_with_object({}) do |owner, result|
              result[owner] = records[convert_key(owner[owner_key_name])] || []
            end
          end

          def owner_keys
            unless defined?(@owner_keys)
              @owner_keys = owners.map do |owner|
                owner[owner_key_name]
              end
              @owner_keys.uniq!
              @owner_keys.compact!
            end
            @owner_keys
          end

          def key_conversion_required?
            @key_conversion_required ||= association_key_type != owner_key_type
          end

          def convert_key(key)
            if key_conversion_required?
              key.to_s
            else
              key
            end
          end

          def association_key_type
            @klass.type_for_attribute(association_key_name.to_s).type
          end

          def owner_key_type
            @model.type_for_attribute(owner_key_name.to_s).type
          end

          def load_records
            return {} if owner_keys.empty?
            # Some databases impose a limit on the number of ids in a list (in Oracle it's 1000)
            # Make several smaller queries if necessary or make one query if the adapter supports it
            slices  = owner_keys.each_slice(klass.connection.in_clause_length || owner_keys.size)
            @preloaded_records = slices.flat_map do |slice|
              records_for(slice)
            end
            @preloaded_records.group_by do |record|
              convert_key(record[association_key_name])
            end
          end

          def reflection_scope
            @reflection_scope ||= reflection.scope ? klass.unscoped.instance_exec(nil, &reflection.scope) : klass.unscoped
          end

          def build_scope
            scope = klass.unscoped

            values = reflection_scope.values
            preload_values = preload_scope.values

            scope.where_clause = reflection_scope.where_clause + preload_scope.where_clause
            scope.references_values = Array(values[:references]) + Array(preload_values[:references])

            if preload_values[:select] || values[:select]
              scope._select!(preload_values[:select] || values[:select])
            end
            scope.includes! preload_values[:includes] || values[:includes]
            if preload_scope.joins_values.any?
              scope.joins!(preload_scope.joins_values)
            else
              scope.joins!(reflection_scope.joins_values)
            end

            if order_values = preload_values[:order] || values[:order]
              scope.order!(order_values)
            end

            if preload_values[:reordering] || values[:reordering]
              scope.reordering_value = true
            end

            if preload_values[:readonly] || values[:readonly]
              scope.readonly!
            end

            if options[:as]
              scope.where!(klass.table_name => { reflection.type => model.base_class.sti_name })
            end

            scope.unscope_values = Array(values[:unscope]) + Array(preload_values[:unscope])
            klass.default_scoped.merge(scope)
          end
      end
    end
  end
end
module ActiveRecord
  class AssociationRelation < Relation
    def initialize(klass, table, predicate_builder, association)
      super(klass, table, predicate_builder)
      @association = association
    end

    def proxy_association
      @association
    end

    def ==(other)
      other == records
    end

    def build(*args, &block)
      scoping { @association.build(*args, &block) }
    end
    alias new build

    def create(*args, &block)
      scoping { @association.create(*args, &block) }
    end

    def create!(*args, &block)
      scoping { @association.create!(*args, &block) }
    end

    private

      def exec_queries
        super.each { |r| @association.set_inverse_instance r }
      end
  end
end
module ActiveRecord
  module Associations
    class AssociationScope #:nodoc:
      def self.scope(association, connection)
        INSTANCE.scope(association, connection)
      end

      def self.create(&block)
        block ||= lambda { |val| val }
        new(block)
      end

      def initialize(value_transformation)
        @value_transformation = value_transformation
      end

      INSTANCE = create

      def scope(association, connection)
        klass = association.klass
        reflection = association.reflection
        scope = klass.unscoped
        owner = association.owner
        alias_tracker = AliasTracker.create connection, association.klass.table_name, klass.type_caster
        chain_head, chain_tail = get_chain(reflection, association, alias_tracker)

        scope.extending! Array(reflection.options[:extend])
        add_constraints(scope, owner, klass, reflection, chain_head, chain_tail)
      end

      def join_type
        Arel::Nodes::InnerJoin
      end

      def self.get_bind_values(owner, chain)
        binds = []
        last_reflection = chain.last

        binds << last_reflection.join_id_for(owner)
        if last_reflection.type
          binds << owner.class.base_class.name
        end

        chain.each_cons(2).each do |reflection, next_reflection|
          if reflection.type
            binds << next_reflection.klass.base_class.name
          end
        end
        binds
      end

      protected

        attr_reader :value_transformation

      private
        def join(table, constraint)
          table.create_join(table, table.create_on(constraint), join_type)
        end

        def last_chain_scope(scope, table, reflection, owner, association_klass)
          join_keys = reflection.join_keys(association_klass)
          key = join_keys.key
          foreign_key = join_keys.foreign_key

          value = transform_value(owner[foreign_key])
          scope = scope.where(table.name => { key => value })

          if reflection.type
            polymorphic_type = transform_value(owner.class.base_class.name)
            scope = scope.where(table.name => { reflection.type => polymorphic_type })
          end

          scope
        end

        def transform_value(value)
          value_transformation.call(value)
        end

        def next_chain_scope(scope, table, reflection, association_klass, foreign_table, next_reflection)
          join_keys = reflection.join_keys(association_klass)
          key = join_keys.key
          foreign_key = join_keys.foreign_key

          constraint = table[key].eq(foreign_table[foreign_key])

          if reflection.type
            value = transform_value(next_reflection.klass.base_class.name)
            scope = scope.where(table.name => { reflection.type => value })
          end

          scope = scope.joins(join(foreign_table, constraint))
        end

        class ReflectionProxy < SimpleDelegator # :nodoc:
          attr_accessor :next
          attr_reader :alias_name

          def initialize(reflection, alias_name)
            super(reflection)
            @alias_name = alias_name
          end

          def all_includes; nil; end
        end

        def get_chain(reflection, association, tracker)
          name = reflection.name
          runtime_reflection = Reflection::RuntimeReflection.new(reflection, association)
          previous_reflection = runtime_reflection
          reflection.chain.drop(1).each do |refl|
            alias_name = tracker.aliased_table_for(refl.table_name, refl.alias_candidate(name))
            proxy = ReflectionProxy.new(refl, alias_name)
            previous_reflection.next = proxy
            previous_reflection = proxy
          end
          [runtime_reflection, previous_reflection]
        end

        def add_constraints(scope, owner, association_klass, refl, chain_head, chain_tail)
          owner_reflection = chain_tail
          table = owner_reflection.alias_name
          scope = last_chain_scope(scope, table, owner_reflection, owner, association_klass)

          reflection = chain_head
          while reflection
            table = reflection.alias_name

            unless reflection == chain_tail
              next_reflection = reflection.next
              foreign_table = next_reflection.alias_name
              scope = next_chain_scope(scope, table, reflection, association_klass, foreign_table, next_reflection)
            end

            # Exclude the scope of the association itself, because that
            # was already merged in the #scope method.
            reflection.constraints.each do |scope_chain_item|
              item  = eval_scope(reflection.klass, scope_chain_item, owner)

              if scope_chain_item == refl.scope
                scope.merge! item.except(:where, :includes)
              end

              reflection.all_includes do
                scope.includes! item.includes_values
              end

              scope.unscope!(*item.unscope_values)
              scope.where_clause += item.where_clause
              scope.order_values |= item.order_values
            end

            reflection = reflection.next
          end

          scope
        end

        def eval_scope(klass, scope, owner)
          klass.unscoped.instance_exec(owner, &scope)
        end
    end
  end
end
require "cases/helper"
require "models/post"
require "models/author"

module ActiveRecord
  module Associations
    class AssociationScopeTest < ActiveRecord::TestCase
      test "does not duplicate conditions" do
        scope = AssociationScope.scope(Author.new.association(:welcome_posts),
                                        Author.connection)
        binds = scope.where_clause.binds.map(&:value)
        assert_equal binds.uniq, binds
      end
    end
  end
end
require "active_support/core_ext/enumerable"
require "active_support/core_ext/string/conversions"
require "active_support/core_ext/module/remove_method"
require "active_record/errors"

module ActiveRecord
  class AssociationNotFoundError < ConfigurationError #:nodoc:
    def initialize(record = nil, association_name = nil)
      if record && association_name
        super("Association named '#{association_name}' was not found on #{record.class.name}; perhaps you misspelled it?")
      else
        super("Association was not found.")
      end
    end
  end

  class InverseOfAssociationNotFoundError < ActiveRecordError #:nodoc:
    def initialize(reflection = nil, associated_class = nil)
      if reflection
        super("Could not find the inverse association for #{reflection.name} (#{reflection.options[:inverse_of].inspect} in #{associated_class.nil? ? reflection.class_name : associated_class.name})")
      else
        super("Could not find the inverse association.")
      end
    end
  end

  class HasManyThroughAssociationNotFoundError < ActiveRecordError #:nodoc:
    def initialize(owner_class_name = nil, reflection = nil)
      if owner_class_name && reflection
        super("Could not find the association #{reflection.options[:through].inspect} in model #{owner_class_name}")
      else
        super("Could not find the association.")
      end
    end
  end

  class HasManyThroughAssociationPolymorphicSourceError < ActiveRecordError #:nodoc:
    def initialize(owner_class_name = nil, reflection = nil, source_reflection = nil)
      if owner_class_name && reflection && source_reflection
        super("Cannot have a has_many :through association '#{owner_class_name}##{reflection.name}' on the polymorphic object '#{source_reflection.class_name}##{source_reflection.name}' without 'source_type'. Try adding 'source_type: \"#{reflection.name.to_s.classify}\"' to 'has_many :through' definition.")
      else
        super("Cannot have a has_many :through association.")
      end
    end
  end

  class HasManyThroughAssociationPolymorphicThroughError < ActiveRecordError #:nodoc:
    def initialize(owner_class_name = nil, reflection = nil)
      if owner_class_name && reflection
        super("Cannot have a has_many :through association '#{owner_class_name}##{reflection.name}' which goes through the polymorphic association '#{owner_class_name}##{reflection.through_reflection.name}'.")
      else
        super("Cannot have a has_many :through association.")
      end
    end
  end

  class HasManyThroughAssociationPointlessSourceTypeError < ActiveRecordError #:nodoc:
    def initialize(owner_class_name = nil, reflection = nil, source_reflection = nil)
      if owner_class_name && reflection && source_reflection
        super("Cannot have a has_many :through association '#{owner_class_name}##{reflection.name}' with a :source_type option if the '#{reflection.through_reflection.class_name}##{source_reflection.name}' is not polymorphic. Try removing :source_type on your association.")
      else
        super("Cannot have a has_many :through association.")
      end
    end
  end

  class HasOneThroughCantAssociateThroughCollection < ActiveRecordError #:nodoc:
    def initialize(owner_class_name = nil, reflection = nil, through_reflection = nil)
      if owner_class_name && reflection && through_reflection
        super("Cannot have a has_one :through association '#{owner_class_name}##{reflection.name}' where the :through association '#{owner_class_name}##{through_reflection.name}' is a collection. Specify a has_one or belongs_to association in the :through option instead.")
      else
        super("Cannot have a has_one :through association.")
      end
    end
  end

  class HasOneAssociationPolymorphicThroughError < ActiveRecordError #:nodoc:
    def initialize(owner_class_name = nil, reflection = nil)
      if owner_class_name && reflection
        super("Cannot have a has_one :through association '#{owner_class_name}##{reflection.name}' which goes through the polymorphic association '#{owner_class_name}##{reflection.through_reflection.name}'.")
      else
        super("Cannot have a has_one :through association.")
      end
    end
  end

  class HasManyThroughSourceAssociationNotFoundError < ActiveRecordError #:nodoc:
    def initialize(reflection = nil)
      if reflection
        through_reflection      = reflection.through_reflection
        source_reflection_names = reflection.source_reflection_names
        source_associations     = reflection.through_reflection.klass._reflections.keys
        super("Could not find the source association(s) #{source_reflection_names.collect(&:inspect).to_sentence(two_words_connector: ' or ', last_word_connector: ', or ', locale: :en)} in model #{through_reflection.klass}. Try 'has_many #{reflection.name.inspect}, :through => #{through_reflection.name.inspect}, :source => <name>'. Is it one of #{source_associations.to_sentence(two_words_connector: ' or ', last_word_connector: ', or ', locale: :en)}?")
      else
        super("Could not find the source association(s).")
      end
    end
  end

  class ThroughCantAssociateThroughHasOneOrManyReflection < ActiveRecordError #:nodoc:
    def initialize(owner = nil, reflection = nil)
      if owner && reflection
        super("Cannot modify association '#{owner.class.name}##{reflection.name}' because the source reflection class '#{reflection.source_reflection.class_name}' is associated to '#{reflection.through_reflection.class_name}' via :#{reflection.source_reflection.macro}.")
      else
        super("Cannot modify association.")
      end
    end
  end

  class HasManyThroughCantAssociateThroughHasOneOrManyReflection < ThroughCantAssociateThroughHasOneOrManyReflection #:nodoc:
  end

  class HasOneThroughCantAssociateThroughHasOneOrManyReflection < ThroughCantAssociateThroughHasOneOrManyReflection #:nodoc:
  end

  class HasManyThroughCantAssociateNewRecords < ActiveRecordError #:nodoc:
    def initialize(owner = nil, reflection = nil)
      if owner && reflection
        super("Cannot associate new records through '#{owner.class.name}##{reflection.name}' on '#{reflection.source_reflection.class_name rescue nil}##{reflection.source_reflection.name rescue nil}'. Both records must have an id in order to create the has_many :through record associating them.")
      else
        super("Cannot associate new records.")
      end
    end
  end

  class HasManyThroughCantDissociateNewRecords < ActiveRecordError #:nodoc:
    def initialize(owner = nil, reflection = nil)
      if owner && reflection
        super("Cannot dissociate new records through '#{owner.class.name}##{reflection.name}' on '#{reflection.source_reflection.class_name rescue nil}##{reflection.source_reflection.name rescue nil}'. Both records must have an id in order to delete the has_many :through record associating them.")
      else
        super("Cannot dissociate new records.")
      end
    end
  end

  class ThroughNestedAssociationsAreReadonly < ActiveRecordError #:nodoc:
    def initialize(owner = nil, reflection = nil)
      if owner && reflection
        super("Cannot modify association '#{owner.class.name}##{reflection.name}' because it goes through more than one other association.")
      else
        super("Through nested associations are read-only.")
      end
    end
  end

  class HasManyThroughNestedAssociationsAreReadonly < ThroughNestedAssociationsAreReadonly #:nodoc:
  end

  class HasOneThroughNestedAssociationsAreReadonly < ThroughNestedAssociationsAreReadonly #:nodoc:
  end

  # This error is raised when trying to eager load a polymorphic association using a JOIN.
  # Eager loading polymorphic associations is only possible with
  # {ActiveRecord::Relation#preload}[rdoc-ref:QueryMethods#preload].
  class EagerLoadPolymorphicError < ActiveRecordError
    def initialize(reflection = nil)
      if reflection
        super("Cannot eagerly load the polymorphic association #{reflection.name.inspect}")
      else
        super("Eager load polymorphic error.")
      end
    end
  end

  class ReadOnlyAssociation < ActiveRecordError #:nodoc:
    def initialize(reflection = nil)
      if reflection
        super("Cannot add to a has_many :through association. Try adding to #{reflection.through_reflection.name.inspect}.")
      else
        super("Read-only reflection error.")
      end
    end
  end

  # This error is raised when trying to destroy a parent instance in N:1 or 1:1 associations
  # (has_many, has_one) when there is at least 1 child associated instance.
  # ex: if @project.tasks.size > 0, DeleteRestrictionError will be raised when trying to destroy @project
  class DeleteRestrictionError < ActiveRecordError #:nodoc:
    def initialize(name = nil)
      if name
        super("Cannot delete record because of dependent #{name}")
      else
        super("Delete restriction error.")
      end
    end
  end

  # See ActiveRecord::Associations::ClassMethods for documentation.
  module Associations # :nodoc:
    extend ActiveSupport::Autoload
    extend ActiveSupport::Concern

    # These classes will be loaded when associations are created.
    # So there is no need to eager load them.
    autoload :Association
    autoload :SingularAssociation
    autoload :CollectionAssociation
    autoload :ForeignAssociation
    autoload :CollectionProxy

    autoload :BelongsToAssociation
    autoload :BelongsToPolymorphicAssociation
    autoload :HasManyAssociation
    autoload :HasManyThroughAssociation
    autoload :HasOneAssociation
    autoload :HasOneThroughAssociation
    autoload :ThroughAssociation

    module Builder #:nodoc:
      autoload :Association,           "active_record/associations/builder/association"
      autoload :SingularAssociation,   "active_record/associations/builder/singular_association"
      autoload :CollectionAssociation, "active_record/associations/builder/collection_association"

      autoload :BelongsTo,           "active_record/associations/builder/belongs_to"
      autoload :HasOne,              "active_record/associations/builder/has_one"
      autoload :HasMany,             "active_record/associations/builder/has_many"
      autoload :HasAndBelongsToMany, "active_record/associations/builder/has_and_belongs_to_many"
    end

    eager_autoload do
      autoload :Preloader
      autoload :JoinDependency
      autoload :AssociationScope
      autoload :AliasTracker
    end

    # Returns the association instance for the given name, instantiating it if it doesn't already exist
    def association(name) #:nodoc:
      association = association_instance_get(name)

      if association.nil?
        unless reflection = self.class._reflect_on_association(name)
          raise AssociationNotFoundError.new(self, name)
        end
        association = reflection.association_class.new(self, reflection)
        association_instance_set(name, association)
      end

      association
    end

    def association_cached?(name) # :nodoc
      @association_cache.key?(name)
    end

    def initialize_dup(*) # :nodoc:
      @association_cache = {}
      super
    end

    def reload(*) # :nodoc:
      clear_association_cache
      super
    end

    private
      # Clears out the association cache.
      def clear_association_cache # :nodoc:
        @association_cache.clear if persisted?
      end

      def init_internals # :nodoc:
        @association_cache = {}
        super
      end

      # Returns the specified association instance if it exists, nil otherwise.
      def association_instance_get(name)
        @association_cache[name]
      end

      # Set the specified association instance.
      def association_instance_set(name, association)
        @association_cache[name] = association
      end

    # \Associations are a set of macro-like class methods for tying objects together through
    # foreign keys. They express relationships like "Project has one Project Manager"
    # or "Project belongs to a Portfolio". Each macro adds a number of methods to the
    # class which are specialized according to the collection or association symbol and the
    # options hash. It works much the same way as Ruby's own <tt>attr*</tt>
    # methods.
    #
    #   class Project < ActiveRecord::Base
    #     belongs_to              :portfolio
    #     has_one                 :project_manager
    #     has_many                :milestones
    #     has_and_belongs_to_many :categories
    #   end
    #
    # The project class now has the following methods (and more) to ease the traversal and
    # manipulation of its relationships:
    # * <tt>Project#portfolio, Project#portfolio=(portfolio), Project#portfolio.nil?</tt>
    # * <tt>Project#project_manager, Project#project_manager=(project_manager), Project#project_manager.nil?,</tt>
    # * <tt>Project#milestones.empty?, Project#milestones.size, Project#milestones, Project#milestones<<(milestone),</tt>
    #   <tt>Project#milestones.delete(milestone), Project#milestones.destroy(milestone), Project#milestones.find(milestone_id),</tt>
    #   <tt>Project#milestones.build, Project#milestones.create</tt>
    # * <tt>Project#categories.empty?, Project#categories.size, Project#categories, Project#categories<<(category1),</tt>
    #   <tt>Project#categories.delete(category1), Project#categories.destroy(category1)</tt>
    #
    # === A word of warning
    #
    # Don't create associations that have the same name as {instance methods}[rdoc-ref:ActiveRecord::Core] of
    # <tt>ActiveRecord::Base</tt>. Since the association adds a method with that name to
    # its model, using an association with the same name as one provided by <tt>ActiveRecord::Base</tt> will override the method inherited through <tt>ActiveRecord::Base</tt> and will break things.
    # For instance, +attributes+ and +connection+ would be bad choices for association names, because those names already exist in the list of <tt>ActiveRecord::Base</tt> instance methods.
    #
    # == Auto-generated methods
    # See also Instance Public methods below for more details.
    #
    # === Singular associations (one-to-one)
    #                                     |            |  belongs_to  |
    #   generated methods                 | belongs_to | :polymorphic | has_one
    #   ----------------------------------+------------+--------------+---------
    #   other(force_reload=false)         |     X      |      X       |    X
    #   other=(other)                     |     X      |      X       |    X
    #   build_other(attributes={})        |     X      |              |    X
    #   create_other(attributes={})       |     X      |              |    X
    #   create_other!(attributes={})      |     X      |              |    X
    #
    # === Collection associations (one-to-many / many-to-many)
    #                                     |       |          | has_many
    #   generated methods                 | habtm | has_many | :through
    #   ----------------------------------+-------+----------+----------
    #   others(force_reload=false)        |   X   |    X     |    X
    #   others=(other,other,...)          |   X   |    X     |    X
    #   other_ids                         |   X   |    X     |    X
    #   other_ids=(id,id,...)             |   X   |    X     |    X
    #   others<<                          |   X   |    X     |    X
    #   others.push                       |   X   |    X     |    X
    #   others.concat                     |   X   |    X     |    X
    #   others.build(attributes={})       |   X   |    X     |    X
    #   others.create(attributes={})      |   X   |    X     |    X
    #   others.create!(attributes={})     |   X   |    X     |    X
    #   others.size                       |   X   |    X     |    X
    #   others.length                     |   X   |    X     |    X
    #   others.count                      |   X   |    X     |    X
    #   others.sum(*args)                 |   X   |    X     |    X
    #   others.empty?                     |   X   |    X     |    X
    #   others.clear                      |   X   |    X     |    X
    #   others.delete(other,other,...)    |   X   |    X     |    X
    #   others.delete_all                 |   X   |    X     |    X
    #   others.destroy(other,other,...)   |   X   |    X     |    X
    #   others.destroy_all                |   X   |    X     |    X
    #   others.find(*args)                |   X   |    X     |    X
    #   others.exists?                    |   X   |    X     |    X
    #   others.distinct                   |   X   |    X     |    X
    #   others.reset                      |   X   |    X     |    X
    #
    # === Overriding generated methods
    #
    # Association methods are generated in a module that is included into the model class,
    # which allows you to easily override with your own methods and call the original
    # generated method with +super+. For example:
    #
    #   class Car < ActiveRecord::Base
    #     belongs_to :owner
    #     belongs_to :old_owner
    #     def owner=(new_owner)
    #       self.old_owner = self.owner
    #       super
    #     end
    #   end
    #
    # If your model class is <tt>Project</tt>, then the module is
    # named <tt>Project::GeneratedAssociationMethods</tt>. The +GeneratedAssociationMethods+ module is
    # included in the model class immediately after the (anonymous) generated attributes methods
    # module, meaning an association will override the methods for an attribute with the same name.
    #
    # == Cardinality and associations
    #
    # Active Record associations can be used to describe one-to-one, one-to-many and many-to-many
    # relationships between models. Each model uses an association to describe its role in
    # the relation. The #belongs_to association is always used in the model that has
    # the foreign key.
    #
    # === One-to-one
    #
    # Use #has_one in the base, and #belongs_to in the associated model.
    #
    #   class Employee < ActiveRecord::Base
    #     has_one :office
    #   end
    #   class Office < ActiveRecord::Base
    #     belongs_to :employee    # foreign key - employee_id
    #   end
    #
    # === One-to-many
    #
    # Use #has_many in the base, and #belongs_to in the associated model.
    #
    #   class Manager < ActiveRecord::Base
    #     has_many :employees
    #   end
    #   class Employee < ActiveRecord::Base
    #     belongs_to :manager     # foreign key - manager_id
    #   end
    #
    # === Many-to-many
    #
    # There are two ways to build a many-to-many relationship.
    #
    # The first way uses a #has_many association with the <tt>:through</tt> option and a join model, so
    # there are two stages of associations.
    #
    #   class Assignment < ActiveRecord::Base
    #     belongs_to :programmer  # foreign key - programmer_id
    #     belongs_to :project     # foreign key - project_id
    #   end
    #   class Programmer < ActiveRecord::Base
    #     has_many :assignments
    #     has_many :projects, through: :assignments
    #   end
    #   class Project < ActiveRecord::Base
    #     has_many :assignments
    #     has_many :programmers, through: :assignments
    #   end
    #
    # For the second way, use #has_and_belongs_to_many in both models. This requires a join table
    # that has no corresponding model or primary key.
    #
    #   class Programmer < ActiveRecord::Base
    #     has_and_belongs_to_many :projects       # foreign keys in the join table
    #   end
    #   class Project < ActiveRecord::Base
    #     has_and_belongs_to_many :programmers    # foreign keys in the join table
    #   end
    #
    # Choosing which way to build a many-to-many relationship is not always simple.
    # If you need to work with the relationship model as its own entity,
    # use #has_many <tt>:through</tt>. Use #has_and_belongs_to_many when working with legacy schemas or when
    # you never work directly with the relationship itself.
    #
    # == Is it a #belongs_to or #has_one association?
    #
    # Both express a 1-1 relationship. The difference is mostly where to place the foreign
    # key, which goes on the table for the class declaring the #belongs_to relationship.
    #
    #   class User < ActiveRecord::Base
    #     # I reference an account.
    #     belongs_to :account
    #   end
    #
    #   class Account < ActiveRecord::Base
    #     # One user references me.
    #     has_one :user
    #   end
    #
    # The tables for these classes could look something like:
    #
    #   CREATE TABLE users (
    #     id int NOT NULL auto_increment,
    #     account_id int default NULL,
    #     name varchar default NULL,
    #     PRIMARY KEY  (id)
    #   )
    #
    #   CREATE TABLE accounts (
    #     id int NOT NULL auto_increment,
    #     name varchar default NULL,
    #     PRIMARY KEY  (id)
    #   )
    #
    # == Unsaved objects and associations
    #
    # You can manipulate objects and associations before they are saved to the database, but
    # there is some special behavior you should be aware of, mostly involving the saving of
    # associated objects.
    #
    # You can set the <tt>:autosave</tt> option on a #has_one, #belongs_to,
    # #has_many, or #has_and_belongs_to_many association. Setting it
    # to +true+ will _always_ save the members, whereas setting it to +false+ will
    # _never_ save the members. More details about <tt>:autosave</tt> option is available at
    # AutosaveAssociation.
    #
    # === One-to-one associations
    #
    # * Assigning an object to a #has_one association automatically saves that object and
    #   the object being replaced (if there is one), in order to update their foreign
    #   keys - except if the parent object is unsaved (<tt>new_record? == true</tt>).
    # * If either of these saves fail (due to one of the objects being invalid), an
    #   ActiveRecord::RecordNotSaved exception is raised and the assignment is
    #   cancelled.
    # * If you wish to assign an object to a #has_one association without saving it,
    #   use the <tt>#build_association</tt> method (documented below). The object being
    #   replaced will still be saved to update its foreign key.
    # * Assigning an object to a #belongs_to association does not save the object, since
    #   the foreign key field belongs on the parent. It does not save the parent either.
    #
    # === Collections
    #
    # * Adding an object to a collection (#has_many or #has_and_belongs_to_many) automatically
    #   saves that object, except if the parent object (the owner of the collection) is not yet
    #   stored in the database.
    # * If saving any of the objects being added to a collection (via <tt>push</tt> or similar)
    #   fails, then <tt>push</tt> returns +false+.
    # * If saving fails while replacing the collection (via <tt>association=</tt>), an
    #   ActiveRecord::RecordNotSaved exception is raised and the assignment is
    #   cancelled.
    # * You can add an object to a collection without automatically saving it by using the
    #   <tt>collection.build</tt> method (documented below).
    # * All unsaved (<tt>new_record? == true</tt>) members of the collection are automatically
    #   saved when the parent is saved.
    #
    # == Customizing the query
    #
    # \Associations are built from <tt>Relation</tt> objects, and you can use the Relation syntax
    # to customize them. For example, to add a condition:
    #
    #   class Blog < ActiveRecord::Base
    #     has_many :published_posts, -> { where(published: true) }, class_name: 'Post'
    #   end
    #
    # Inside the <tt>-> { ... }</tt> block you can use all of the usual Relation methods.
    #
    # === Accessing the owner object
    #
    # Sometimes it is useful to have access to the owner object when building the query. The owner
    # is passed as a parameter to the block. For example, the following association would find all
    # events that occur on the user's birthday:
    #
    #   class User < ActiveRecord::Base
    #     has_many :birthday_events, ->(user) { where(starts_on: user.birthday) }, class_name: 'Event'
    #   end
    #
    # Note: Joining, eager loading and preloading of these associations is not fully possible.
    # These operations happen before instance creation and the scope will be called with a +nil+ argument.
    # This can lead to unexpected behavior and is deprecated.
    #
    # == Association callbacks
    #
    # Similar to the normal callbacks that hook into the life cycle of an Active Record object,
    # you can also define callbacks that get triggered when you add an object to or remove an
    # object from an association collection.
    #
    #   class Project
    #     has_and_belongs_to_many :developers, after_add: :evaluate_velocity
    #
    #     def evaluate_velocity(developer)
    #       ...
    #     end
    #   end
    #
    # It's possible to stack callbacks by passing them as an array. Example:
    #
    #   class Project
    #     has_and_belongs_to_many :developers,
    #                             after_add: [:evaluate_velocity, Proc.new { |p, d| p.shipping_date = Time.now}]
    #   end
    #
    # Possible callbacks are: +before_add+, +after_add+, +before_remove+ and +after_remove+.
    #
    # If any of the +before_add+ callbacks throw an exception, the object will not be
    # added to the collection.
    #
    # Similarly, if any of the +before_remove+ callbacks throw an exception, the object
    # will not be removed from the collection.
    #
    # == Association extensions
    #
    # The proxy objects that control the access to associations can be extended through anonymous
    # modules. This is especially beneficial for adding new finders, creators, and other
    # factory-type methods that are only used as part of this association.
    #
    #   class Account < ActiveRecord::Base
    #     has_many :people do
    #       def find_or_create_by_name(name)
    #         first_name, last_name = name.split(" ", 2)
    #         find_or_create_by(first_name: first_name, last_name: last_name)
    #       end
    #     end
    #   end
    #
    #   person = Account.first.people.find_or_create_by_name("David Heinemeier Hansson")
    #   person.first_name # => "David"
    #   person.last_name  # => "Heinemeier Hansson"
    #
    # If you need to share the same extensions between many associations, you can use a named
    # extension module.
    #
    #   module FindOrCreateByNameExtension
    #     def find_or_create_by_name(name)
    #       first_name, last_name = name.split(" ", 2)
    #       find_or_create_by(first_name: first_name, last_name: last_name)
    #     end
    #   end
    #
    #   class Account < ActiveRecord::Base
    #     has_many :people, -> { extending FindOrCreateByNameExtension }
    #   end
    #
    #   class Company < ActiveRecord::Base
    #     has_many :people, -> { extending FindOrCreateByNameExtension }
    #   end
    #
    # Some extensions can only be made to work with knowledge of the association's internals.
    # Extensions can access relevant state using the following methods (where +items+ is the
    # name of the association):
    #
    # * <tt>record.association(:items).owner</tt> - Returns the object the association is part of.
    # * <tt>record.association(:items).reflection</tt> - Returns the reflection object that describes the association.
    # * <tt>record.association(:items).target</tt> - Returns the associated object for #belongs_to and #has_one, or
    #   the collection of associated objects for #has_many and #has_and_belongs_to_many.
    #
    # However, inside the actual extension code, you will not have access to the <tt>record</tt> as
    # above. In this case, you can access <tt>proxy_association</tt>. For example,
    # <tt>record.association(:items)</tt> and <tt>record.items.proxy_association</tt> will return
    # the same object, allowing you to make calls like <tt>proxy_association.owner</tt> inside
    # association extensions.
    #
    # == Association Join Models
    #
    # Has Many associations can be configured with the <tt>:through</tt> option to use an
    # explicit join model to retrieve the data. This operates similarly to a
    # #has_and_belongs_to_many association. The advantage is that you're able to add validations,
    # callbacks, and extra attributes on the join model. Consider the following schema:
    #
    #   class Author < ActiveRecord::Base
    #     has_many :authorships
    #     has_many :books, through: :authorships
    #   end
    #
    #   class Authorship < ActiveRecord::Base
    #     belongs_to :author
    #     belongs_to :book
    #   end
    #
    #   @author = Author.first
    #   @author.authorships.collect { |a| a.book } # selects all books that the author's authorships belong to
    #   @author.books                              # selects all books by using the Authorship join model
    #
    # You can also go through a #has_many association on the join model:
    #
    #   class Firm < ActiveRecord::Base
    #     has_many   :clients
    #     has_many   :invoices, through: :clients
    #   end
    #
    #   class Client < ActiveRecord::Base
    #     belongs_to :firm
    #     has_many   :invoices
    #   end
    #
    #   class Invoice < ActiveRecord::Base
    #     belongs_to :client
    #   end
    #
    #   @firm = Firm.first
    #   @firm.clients.flat_map { |c| c.invoices } # select all invoices for all clients of the firm
    #   @firm.invoices                            # selects all invoices by going through the Client join model
    #
    # Similarly you can go through a #has_one association on the join model:
    #
    #   class Group < ActiveRecord::Base
    #     has_many   :users
    #     has_many   :avatars, through: :users
    #   end
    #
    #   class User < ActiveRecord::Base
    #     belongs_to :group
    #     has_one    :avatar
    #   end
    #
    #   class Avatar < ActiveRecord::Base
    #     belongs_to :user
    #   end
    #
    #   @group = Group.first
    #   @group.users.collect { |u| u.avatar }.compact # select all avatars for all users in the group
    #   @group.avatars                                # selects all avatars by going through the User join model.
    #
    # An important caveat with going through #has_one or #has_many associations on the
    # join model is that these associations are *read-only*. For example, the following
    # would not work following the previous example:
    #
    #   @group.avatars << Avatar.new   # this would work if User belonged_to Avatar rather than the other way around
    #   @group.avatars.delete(@group.avatars.last)  # so would this
    #
    # == Setting Inverses
    #
    # If you are using a #belongs_to on the join model, it is a good idea to set the
    # <tt>:inverse_of</tt> option on the #belongs_to, which will mean that the following example
    # works correctly (where <tt>tags</tt> is a #has_many <tt>:through</tt> association):
    #
    #   @post = Post.first
    #   @tag = @post.tags.build name: "ruby"
    #   @tag.save
    #
    # The last line ought to save the through record (a <tt>Tagging</tt>). This will only work if the
    # <tt>:inverse_of</tt> is set:
    #
    #   class Tagging < ActiveRecord::Base
    #     belongs_to :post
    #     belongs_to :tag, inverse_of: :taggings
    #   end
    #
    # If you do not set the <tt>:inverse_of</tt> record, the association will
    # do its best to match itself up with the correct inverse. Automatic
    # inverse detection only works on #has_many, #has_one, and
    # #belongs_to associations.
    #
    # Extra options on the associations, as defined in the
    # <tt>AssociationReflection::INVALID_AUTOMATIC_INVERSE_OPTIONS</tt> constant, will
    # also prevent the association's inverse from being found automatically.
    #
    # The automatic guessing of the inverse association uses a heuristic based
    # on the name of the class, so it may not work for all associations,
    # especially the ones with non-standard names.
    #
    # You can turn off the automatic detection of inverse associations by setting
    # the <tt>:inverse_of</tt> option to <tt>false</tt> like so:
    #
    #   class Tagging < ActiveRecord::Base
    #     belongs_to :tag, inverse_of: false
    #   end
    #
    # == Nested \Associations
    #
    # You can actually specify *any* association with the <tt>:through</tt> option, including an
    # association which has a <tt>:through</tt> option itself. For example:
    #
    #   class Author < ActiveRecord::Base
    #     has_many :posts
    #     has_many :comments, through: :posts
    #     has_many :commenters, through: :comments
    #   end
    #
    #   class Post < ActiveRecord::Base
    #     has_many :comments
    #   end
    #
    #   class Comment < ActiveRecord::Base
    #     belongs_to :commenter
    #   end
    #
    #   @author = Author.first
    #   @author.commenters # => People who commented on posts written by the author
    #
    # An equivalent way of setting up this association this would be:
    #
    #   class Author < ActiveRecord::Base
    #     has_many :posts
    #     has_many :commenters, through: :posts
    #   end
    #
    #   class Post < ActiveRecord::Base
    #     has_many :comments
    #     has_many :commenters, through: :comments
    #   end
    #
    #   class Comment < ActiveRecord::Base
    #     belongs_to :commenter
    #   end
    #
    # When using a nested association, you will not be able to modify the association because there
    # is not enough information to know what modification to make. For example, if you tried to
    # add a <tt>Commenter</tt> in the example above, there would be no way to tell how to set up the
    # intermediate <tt>Post</tt> and <tt>Comment</tt> objects.
    #
    # == Polymorphic \Associations
    #
    # Polymorphic associations on models are not restricted on what types of models they
    # can be associated with. Rather, they specify an interface that a #has_many association
    # must adhere to.
    #
    #   class Asset < ActiveRecord::Base
    #     belongs_to :attachable, polymorphic: true
    #   end
    #
    #   class Post < ActiveRecord::Base
    #     has_many :assets, as: :attachable         # The :as option specifies the polymorphic interface to use.
    #   end
    #
    #   @asset.attachable = @post
    #
    # This works by using a type column in addition to a foreign key to specify the associated
    # record. In the Asset example, you'd need an +attachable_id+ integer column and an
    # +attachable_type+ string column.
    #
    # Using polymorphic associations in combination with single table inheritance (STI) is
    # a little tricky. In order for the associations to work as expected, ensure that you
    # store the base model for the STI models in the type column of the polymorphic
    # association. To continue with the asset example above, suppose there are guest posts
    # and member posts that use the posts table for STI. In this case, there must be a +type+
    # column in the posts table.
    #
    # Note: The <tt>attachable_type=</tt> method is being called when assigning an +attachable+.
    # The +class_name+ of the +attachable+ is passed as a String.
    #
    #   class Asset < ActiveRecord::Base
    #     belongs_to :attachable, polymorphic: true
    #
    #     def attachable_type=(class_name)
    #        super(class_name.constantize.base_class.to_s)
    #     end
    #   end
    #
    #   class Post < ActiveRecord::Base
    #     # because we store "Post" in attachable_type now dependent: :destroy will work
    #     has_many :assets, as: :attachable, dependent: :destroy
    #   end
    #
    #   class GuestPost < Post
    #   end
    #
    #   class MemberPost < Post
    #   end
    #
    # == Caching
    #
    # All of the methods are built on a simple caching principle that will keep the result
    # of the last query around unless specifically instructed not to. The cache is even
    # shared across methods to make it even cheaper to use the macro-added methods without
    # worrying too much about performance at the first go.
    #
    #   project.milestones             # fetches milestones from the database
    #   project.milestones.size        # uses the milestone cache
    #   project.milestones.empty?      # uses the milestone cache
    #   project.milestones(true).size  # fetches milestones from the database
    #   project.milestones             # uses the milestone cache
    #
    # == Eager loading of associations
    #
    # Eager loading is a way to find objects of a certain class and a number of named associations.
    # It is one of the easiest ways to prevent the dreaded N+1 problem in which fetching 100
    # posts that each need to display their author triggers 101 database queries. Through the
    # use of eager loading, the number of queries will be reduced from 101 to 2.
    #
    #   class Post < ActiveRecord::Base
    #     belongs_to :author
    #     has_many   :comments
    #   end
    #
    # Consider the following loop using the class above:
    #
    #   Post.all.each do |post|
    #     puts "Post:            " + post.title
    #     puts "Written by:      " + post.author.name
    #     puts "Last comment on: " + post.comments.first.created_on
    #   end
    #
    # To iterate over these one hundred posts, we'll generate 201 database queries. Let's
    # first just optimize it for retrieving the author:
    #
    #   Post.includes(:author).each do |post|
    #
    # This references the name of the #belongs_to association that also used the <tt>:author</tt>
    # symbol. After loading the posts, +find+ will collect the +author_id+ from each one and load
    # all of the referenced authors with one query. Doing so will cut down the number of queries
    # from 201 to 102.
    #
    # We can improve upon the situation further by referencing both associations in the finder with:
    #
    #   Post.includes(:author, :comments).each do |post|
    #
    # This will load all comments with a single query. This reduces the total number of queries
    # to 3. In general, the number of queries will be 1 plus the number of associations
    # named (except if some of the associations are polymorphic #belongs_to - see below).
    #
    # To include a deep hierarchy of associations, use a hash:
    #
    #   Post.includes(:author, { comments: { author: :gravatar } }).each do |post|
    #
    # The above code will load all the comments and all of their associated
    # authors and gravatars. You can mix and match any combination of symbols,
    # arrays, and hashes to retrieve the associations you want to load.
    #
    # All of this power shouldn't fool you into thinking that you can pull out huge amounts
    # of data with no performance penalty just because you've reduced the number of queries.
    # The database still needs to send all the data to Active Record and it still needs to
    # be processed. So it's no catch-all for performance problems, but it's a great way to
    # cut down on the number of queries in a situation as the one described above.
    #
    # Since only one table is loaded at a time, conditions or orders cannot reference tables
    # other than the main one. If this is the case, Active Record falls back to the previously
    # used <tt>LEFT OUTER JOIN</tt> based strategy. For example:
    #
    #   Post.includes([:author, :comments]).where(['comments.approved = ?', true])
    #
    # This will result in a single SQL query with joins along the lines of:
    # <tt>LEFT OUTER JOIN comments ON comments.post_id = posts.id</tt> and
    # <tt>LEFT OUTER JOIN authors ON authors.id = posts.author_id</tt>. Note that using conditions
    # like this can have unintended consequences.
    # In the above example, posts with no approved comments are not returned at all because
    # the conditions apply to the SQL statement as a whole and not just to the association.
    #
    # You must disambiguate column references for this fallback to happen, for example
    # <tt>order: "author.name DESC"</tt> will work but <tt>order: "name DESC"</tt> will not.
    #
    # If you want to load all posts (including posts with no approved comments), then write
    # your own <tt>LEFT OUTER JOIN</tt> query using <tt>ON</tt>:
    #
    #   Post.joins("LEFT OUTER JOIN comments ON comments.post_id = posts.id AND comments.approved = '1'")
    #
    # In this case, it is usually more natural to include an association which has conditions defined on it:
    #
    #   class Post < ActiveRecord::Base
    #     has_many :approved_comments, -> { where(approved: true) }, class_name: 'Comment'
    #   end
    #
    #   Post.includes(:approved_comments)
    #
    # This will load posts and eager load the +approved_comments+ association, which contains
    # only those comments that have been approved.
    #
    # If you eager load an association with a specified <tt>:limit</tt> option, it will be ignored,
    # returning all the associated objects:
    #
    #   class Picture < ActiveRecord::Base
    #     has_many :most_recent_comments, -> { order('id DESC').limit(10) }, class_name: 'Comment'
    #   end
    #
    #   Picture.includes(:most_recent_comments).first.most_recent_comments # => returns all associated comments.
    #
    # Eager loading is supported with polymorphic associations.
    #
    #   class Address < ActiveRecord::Base
    #     belongs_to :addressable, polymorphic: true
    #   end
    #
    # A call that tries to eager load the addressable model
    #
    #   Address.includes(:addressable)
    #
    # This will execute one query to load the addresses and load the addressables with one
    # query per addressable type.
    # For example, if all the addressables are either of class Person or Company, then a total
    # of 3 queries will be executed. The list of addressable types to load is determined on
    # the back of the addresses loaded. This is not supported if Active Record has to fallback
    # to the previous implementation of eager loading and will raise ActiveRecord::EagerLoadPolymorphicError.
    # The reason is that the parent model's type is a column value so its corresponding table
    # name cannot be put in the +FROM+/+JOIN+ clauses of that query.
    #
    # == Table Aliasing
    #
    # Active Record uses table aliasing in the case that a table is referenced multiple times
    # in a join. If a table is referenced only once, the standard table name is used. The
    # second time, the table is aliased as <tt>#{reflection_name}_#{parent_table_name}</tt>.
    # Indexes are appended for any more successive uses of the table name.
    #
    #   Post.joins(:comments)
    #   # => SELECT ... FROM posts INNER JOIN comments ON ...
    #   Post.joins(:special_comments) # STI
    #   # => SELECT ... FROM posts INNER JOIN comments ON ... AND comments.type = 'SpecialComment'
    #   Post.joins(:comments, :special_comments) # special_comments is the reflection name, posts is the parent table name
    #   # => SELECT ... FROM posts INNER JOIN comments ON ... INNER JOIN comments special_comments_posts
    #
    # Acts as tree example:
    #
    #   TreeMixin.joins(:children)
    #   # => SELECT ... FROM mixins INNER JOIN mixins childrens_mixins ...
    #   TreeMixin.joins(children: :parent)
    #   # => SELECT ... FROM mixins INNER JOIN mixins childrens_mixins ...
    #                               INNER JOIN parents_mixins ...
    #   TreeMixin.joins(children: {parent: :children})
    #   # => SELECT ... FROM mixins INNER JOIN mixins childrens_mixins ...
    #                               INNER JOIN parents_mixins ...
    #                               INNER JOIN mixins childrens_mixins_2
    #
    # Has and Belongs to Many join tables use the same idea, but add a <tt>_join</tt> suffix:
    #
    #   Post.joins(:categories)
    #   # => SELECT ... FROM posts INNER JOIN categories_posts ... INNER JOIN categories ...
    #   Post.joins(categories: :posts)
    #   # => SELECT ... FROM posts INNER JOIN categories_posts ... INNER JOIN categories ...
    #                              INNER JOIN categories_posts posts_categories_join INNER JOIN posts posts_categories
    #   Post.joins(categories: {posts: :categories})
    #   # => SELECT ... FROM posts INNER JOIN categories_posts ... INNER JOIN categories ...
    #                              INNER JOIN categories_posts posts_categories_join INNER JOIN posts posts_categories
    #                              INNER JOIN categories_posts categories_posts_join INNER JOIN categories categories_posts_2
    #
    # If you wish to specify your own custom joins using ActiveRecord::QueryMethods#joins method, those table
    # names will take precedence over the eager associations:
    #
    #   Post.joins(:comments).joins("inner join comments ...")
    #   # => SELECT ... FROM posts INNER JOIN comments_posts ON ... INNER JOIN comments ...
    #   Post.joins(:comments, :special_comments).joins("inner join comments ...")
    #   # => SELECT ... FROM posts INNER JOIN comments comments_posts ON ...
    #                              INNER JOIN comments special_comments_posts ...
    #                              INNER JOIN comments ...
    #
    # Table aliases are automatically truncated according to the maximum length of table identifiers
    # according to the specific database.
    #
    # == Modules
    #
    # By default, associations will look for objects within the current module scope. Consider:
    #
    #   module MyApplication
    #     module Business
    #       class Firm < ActiveRecord::Base
    #         has_many :clients
    #       end
    #
    #       class Client < ActiveRecord::Base; end
    #     end
    #   end
    #
    # When <tt>Firm#clients</tt> is called, it will in turn call
    # <tt>MyApplication::Business::Client.find_all_by_firm_id(firm.id)</tt>.
    # If you want to associate with a class in another module scope, this can be done by
    # specifying the complete class name.
    #
    #   module MyApplication
    #     module Business
    #       class Firm < ActiveRecord::Base; end
    #     end
    #
    #     module Billing
    #       class Account < ActiveRecord::Base
    #         belongs_to :firm, class_name: "MyApplication::Business::Firm"
    #       end
    #     end
    #   end
    #
    # == Bi-directional associations
    #
    # When you specify an association, there is usually an association on the associated model
    # that specifies the same relationship in reverse. For example, with the following models:
    #
    #    class Dungeon < ActiveRecord::Base
    #      has_many :traps
    #      has_one :evil_wizard
    #    end
    #
    #    class Trap < ActiveRecord::Base
    #      belongs_to :dungeon
    #    end
    #
    #    class EvilWizard < ActiveRecord::Base
    #      belongs_to :dungeon
    #    end
    #
    # The +traps+ association on +Dungeon+ and the +dungeon+ association on +Trap+ are
    # the inverse of each other, and the inverse of the +dungeon+ association on +EvilWizard+
    # is the +evil_wizard+ association on +Dungeon+ (and vice-versa). By default,
    # Active Record can guess the inverse of the association based on the name
    # of the class. The result is the following:
    #
    #    d = Dungeon.first
    #    t = d.traps.first
    #    d.object_id == t.dungeon.object_id # => true
    #
    # The +Dungeon+ instances +d+ and <tt>t.dungeon</tt> in the above example refer to
    # the same in-memory instance since the association matches the name of the class.
    # The result would be the same if we added +:inverse_of+ to our model definitions:
    #
    #    class Dungeon < ActiveRecord::Base
    #      has_many :traps, inverse_of: :dungeon
    #      has_one :evil_wizard, inverse_of: :dungeon
    #    end
    #
    #    class Trap < ActiveRecord::Base
    #      belongs_to :dungeon, inverse_of: :traps
    #    end
    #
    #    class EvilWizard < ActiveRecord::Base
    #      belongs_to :dungeon, inverse_of: :evil_wizard
    #    end
    #
    # There are limitations to <tt>:inverse_of</tt> support:
    #
    # * does not work with <tt>:through</tt> associations.
    # * does not work with <tt>:polymorphic</tt> associations.
    # * inverse associations for #belongs_to associations #has_many are ignored.
    #
    # For more information, see the documentation for the +:inverse_of+ option.
    #
    # == Deleting from associations
    #
    # === Dependent associations
    #
    # #has_many, #has_one, and #belongs_to associations support the <tt>:dependent</tt> option.
    # This allows you to specify that associated records should be deleted when the owner is
    # deleted.
    #
    # For example:
    #
    #     class Author
    #       has_many :posts, dependent: :destroy
    #     end
    #     Author.find(1).destroy # => Will destroy all of the author's posts, too
    #
    # The <tt>:dependent</tt> option can have different values which specify how the deletion
    # is done. For more information, see the documentation for this option on the different
    # specific association types. When no option is given, the behavior is to do nothing
    # with the associated records when destroying a record.
    #
    # Note that <tt>:dependent</tt> is implemented using Rails' callback
    # system, which works by processing callbacks in order. Therefore, other
    # callbacks declared either before or after the <tt>:dependent</tt> option
    # can affect what it does.
    #
    # Note that <tt>:dependent</tt> option is ignored for #has_one <tt>:through</tt> associations.
    #
    # === Delete or destroy?
    #
    # #has_many and #has_and_belongs_to_many associations have the methods <tt>destroy</tt>,
    # <tt>delete</tt>, <tt>destroy_all</tt> and <tt>delete_all</tt>.
    #
    # For #has_and_belongs_to_many, <tt>delete</tt> and <tt>destroy</tt> are the same: they
    # cause the records in the join table to be removed.
    #
    # For #has_many, <tt>destroy</tt> and <tt>destroy_all</tt> will always call the <tt>destroy</tt> method of the
    # record(s) being removed so that callbacks are run. However <tt>delete</tt> and <tt>delete_all</tt> will either
    # do the deletion according to the strategy specified by the <tt>:dependent</tt> option, or
    # if no <tt>:dependent</tt> option is given, then it will follow the default strategy.
    # The default strategy is to do nothing (leave the foreign keys with the parent ids set), except for
    # #has_many <tt>:through</tt>, where the default strategy is <tt>delete_all</tt> (delete
    # the join records, without running their callbacks).
    #
    # There is also a <tt>clear</tt> method which is the same as <tt>delete_all</tt>, except that
    # it returns the association rather than the records which have been deleted.
    #
    # === What gets deleted?
    #
    # There is a potential pitfall here: #has_and_belongs_to_many and #has_many <tt>:through</tt>
    # associations have records in join tables, as well as the associated records. So when we
    # call one of these deletion methods, what exactly should be deleted?
    #
    # The answer is that it is assumed that deletion on an association is about removing the
    # <i>link</i> between the owner and the associated object(s), rather than necessarily the
    # associated objects themselves. So with #has_and_belongs_to_many and #has_many
    # <tt>:through</tt>, the join records will be deleted, but the associated records won't.
    #
    # This makes sense if you think about it: if you were to call <tt>post.tags.delete(Tag.find_by(name: 'food'))</tt>
    # you would want the 'food' tag to be unlinked from the post, rather than for the tag itself
    # to be removed from the database.
    #
    # However, there are examples where this strategy doesn't make sense. For example, suppose
    # a person has many projects, and each project has many tasks. If we deleted one of a person's
    # tasks, we would probably not want the project to be deleted. In this scenario, the delete method
    # won't actually work: it can only be used if the association on the join model is a
    # #belongs_to. In other situations you are expected to perform operations directly on
    # either the associated records or the <tt>:through</tt> association.
    #
    # With a regular #has_many there is no distinction between the "associated records"
    # and the "link", so there is only one choice for what gets deleted.
    #
    # With #has_and_belongs_to_many and #has_many <tt>:through</tt>, if you want to delete the
    # associated records themselves, you can always do something along the lines of
    # <tt>person.tasks.each(&:destroy)</tt>.
    #
    # == Type safety with ActiveRecord::AssociationTypeMismatch
    #
    # If you attempt to assign an object to an association that doesn't match the inferred
    # or specified <tt>:class_name</tt>, you'll get an ActiveRecord::AssociationTypeMismatch.
    #
    # == Options
    #
    # All of the association macros can be specialized through options. This makes cases
    # more complex than the simple and guessable ones possible.
      module ClassMethods
        # Specifies a one-to-many association. The following methods for retrieval and query of
        # collections of associated objects will be added:
        #
        # +collection+ is a placeholder for the symbol passed as the +name+ argument, so
        # <tt>has_many :clients</tt> would add among others <tt>clients.empty?</tt>.
        #
        # [collection(force_reload = false)]
        #   Returns an array of all the associated objects.
        #   An empty array is returned if none are found.
        # [collection<<(object, ...)]
        #   Adds one or more objects to the collection by setting their foreign keys to the collection's primary key.
        #   Note that this operation instantly fires update SQL without waiting for the save or update call on the
        #   parent object, unless the parent object is a new record.
        #   This will also run validations and callbacks of associated object(s).
        # [collection.delete(object, ...)]
        #   Removes one or more objects from the collection by setting their foreign keys to +NULL+.
        #   Objects will be in addition destroyed if they're associated with <tt>dependent: :destroy</tt>,
        #   and deleted if they're associated with <tt>dependent: :delete_all</tt>.
        #
        #   If the <tt>:through</tt> option is used, then the join records are deleted (rather than
        #   nullified) by default, but you can specify <tt>dependent: :destroy</tt> or
        #   <tt>dependent: :nullify</tt> to override this.
        # [collection.destroy(object, ...)]
        #   Removes one or more objects from the collection by running <tt>destroy</tt> on
        #   each record, regardless of any dependent option, ensuring callbacks are run.
        #
        #   If the <tt>:through</tt> option is used, then the join records are destroyed
        #   instead, not the objects themselves.
        # [collection=objects]
        #   Replaces the collections content by deleting and adding objects as appropriate. If the <tt>:through</tt>
        #   option is true callbacks in the join models are triggered except destroy callbacks, since deletion is
        #   direct by default. You can specify <tt>dependent: :destroy</tt> or
        #   <tt>dependent: :nullify</tt> to override this.
        # [collection_singular_ids]
        #   Returns an array of the associated objects' ids
        # [collection_singular_ids=ids]
        #   Replace the collection with the objects identified by the primary keys in +ids+. This
        #   method loads the models and calls <tt>collection=</tt>. See above.
        # [collection.clear]
        #   Removes every object from the collection. This destroys the associated objects if they
        #   are associated with <tt>dependent: :destroy</tt>, deletes them directly from the
        #   database if <tt>dependent: :delete_all</tt>, otherwise sets their foreign keys to +NULL+.
        #   If the <tt>:through</tt> option is true no destroy callbacks are invoked on the join models.
        #   Join models are directly deleted.
        # [collection.empty?]
        #   Returns +true+ if there are no associated objects.
        # [collection.size]
        #   Returns the number of associated objects.
        # [collection.find(...)]
        #   Finds an associated object according to the same rules as ActiveRecord::FinderMethods#find.
        # [collection.exists?(...)]
        #   Checks whether an associated object with the given conditions exists.
        #   Uses the same rules as ActiveRecord::FinderMethods#exists?.
        # [collection.build(attributes = {}, ...)]
        #   Returns one or more new objects of the collection type that have been instantiated
        #   with +attributes+ and linked to this object through a foreign key, but have not yet
        #   been saved.
        # [collection.create(attributes = {})]
        #   Returns a new object of the collection type that has been instantiated
        #   with +attributes+, linked to this object through a foreign key, and that has already
        #   been saved (if it passed the validation). *Note*: This only works if the base model
        #   already exists in the DB, not if it is a new (unsaved) record!
        # [collection.create!(attributes = {})]
        #   Does the same as <tt>collection.create</tt>, but raises ActiveRecord::RecordInvalid
        #   if the record is invalid.
        #
        # === Example
        #
        # A <tt>Firm</tt> class declares <tt>has_many :clients</tt>, which will add:
        # * <tt>Firm#clients</tt> (similar to <tt>Client.where(firm_id: id)</tt>)
        # * <tt>Firm#clients<<</tt>
        # * <tt>Firm#clients.delete</tt>
        # * <tt>Firm#clients.destroy</tt>
        # * <tt>Firm#clients=</tt>
        # * <tt>Firm#client_ids</tt>
        # * <tt>Firm#client_ids=</tt>
        # * <tt>Firm#clients.clear</tt>
        # * <tt>Firm#clients.empty?</tt> (similar to <tt>firm.clients.size == 0</tt>)
        # * <tt>Firm#clients.size</tt> (similar to <tt>Client.count "firm_id = #{id}"</tt>)
        # * <tt>Firm#clients.find</tt> (similar to <tt>Client.where(firm_id: id).find(id)</tt>)
        # * <tt>Firm#clients.exists?(name: 'ACME')</tt> (similar to <tt>Client.exists?(name: 'ACME', firm_id: firm.id)</tt>)
        # * <tt>Firm#clients.build</tt> (similar to <tt>Client.new("firm_id" => id)</tt>)
        # * <tt>Firm#clients.create</tt> (similar to <tt>c = Client.new("firm_id" => id); c.save; c</tt>)
        # * <tt>Firm#clients.create!</tt> (similar to <tt>c = Client.new("firm_id" => id); c.save!</tt>)
        # The declaration can also include an +options+ hash to specialize the behavior of the association.
        #
        # === Scopes
        #
        # You can pass a second argument +scope+ as a callable (i.e. proc or
        # lambda) to retrieve a specific set of records or customize the generated
        # query when you access the associated collection.
        #
        # Scope examples:
        #   has_many :comments, -> { where(author_id: 1) }
        #   has_many :employees, -> { joins(:address) }
        #   has_many :posts, ->(post) { where("max_post_length > ?", post.length) }
        #
        # === Extensions
        #
        # The +extension+ argument allows you to pass a block into a has_many
        # association. This is useful for adding new finders, creators and other
        # factory-type methods to be used as part of the association.
        #
        # Extension examples:
        #   has_many :employees do
        #     def find_or_create_by_name(name)
        #       first_name, last_name = name.split(" ", 2)
        #       find_or_create_by(first_name: first_name, last_name: last_name)
        #     end
        #   end
        #
        # === Options
        # [:class_name]
        #   Specify the class name of the association. Use it only if that name can't be inferred
        #   from the association name. So <tt>has_many :products</tt> will by default be linked
        #   to the +Product+ class, but if the real class name is +SpecialProduct+, you'll have to
        #   specify it with this option.
        # [:foreign_key]
        #   Specify the foreign key used for the association. By default this is guessed to be the name
        #   of this class in lower-case and "_id" suffixed. So a Person class that makes a #has_many
        #   association will use "person_id" as the default <tt>:foreign_key</tt>.
        # [:foreign_type]
        #   Specify the column used to store the associated object's type, if this is a polymorphic
        #   association. By default this is guessed to be the name of the polymorphic association
        #   specified on "as" option with a "_type" suffix. So a class that defines a
        #   <tt>has_many :tags, as: :taggable</tt> association will use "taggable_type" as the
        #   default <tt>:foreign_type</tt>.
        # [:primary_key]
        #   Specify the name of the column to use as the primary key for the association. By default this is +id+.
        # [:dependent]
        #   Controls what happens to the associated objects when
        #   their owner is destroyed. Note that these are implemented as
        #   callbacks, and Rails executes callbacks in order. Therefore, other
        #   similar callbacks may affect the <tt>:dependent</tt> behavior, and the
        #   <tt>:dependent</tt> behavior may affect other callbacks.
        #
        #   * <tt>:destroy</tt> causes all the associated objects to also be destroyed.
        #   * <tt>:delete_all</tt> causes all the associated objects to be deleted directly from the database (so callbacks will not be executed).
        #   * <tt>:nullify</tt> causes the foreign keys to be set to +NULL+. Callbacks are not executed.
        #   * <tt>:restrict_with_exception</tt> causes an exception to be raised if there are any associated records.
        #   * <tt>:restrict_with_error</tt> causes an error to be added to the owner if there are any associated objects.
        #
        #   If using with the <tt>:through</tt> option, the association on the join model must be
        #   a #belongs_to, and the records which get deleted are the join records, rather than
        #   the associated records.
        # [:counter_cache]
        #   This option can be used to configure a custom named <tt>:counter_cache.</tt> You only need this option,
        #   when you customized the name of your <tt>:counter_cache</tt> on the #belongs_to association.
        # [:as]
        #   Specifies a polymorphic interface (See #belongs_to).
        # [:through]
        #   Specifies an association through which to perform the query. This can be any other type
        #   of association, including other <tt>:through</tt> associations. Options for <tt>:class_name</tt>,
        #   <tt>:primary_key</tt> and <tt>:foreign_key</tt> are ignored, as the association uses the
        #   source reflection.
        #
        #   If the association on the join model is a #belongs_to, the collection can be modified
        #   and the records on the <tt>:through</tt> model will be automatically created and removed
        #   as appropriate. Otherwise, the collection is read-only, so you should manipulate the
        #   <tt>:through</tt> association directly.
        #
        #   If you are going to modify the association (rather than just read from it), then it is
        #   a good idea to set the <tt>:inverse_of</tt> option on the source association on the
        #   join model. This allows associated records to be built which will automatically create
        #   the appropriate join model records when they are saved. (See the 'Association Join Models'
        #   section above.)
        # [:source]
        #   Specifies the source association name used by #has_many <tt>:through</tt> queries.
        #   Only use it if the name cannot be inferred from the association.
        #   <tt>has_many :subscribers, through: :subscriptions</tt> will look for either <tt>:subscribers</tt> or
        #   <tt>:subscriber</tt> on Subscription, unless a <tt>:source</tt> is given.
        # [:source_type]
        #   Specifies type of the source association used by #has_many <tt>:through</tt> queries where the source
        #   association is a polymorphic #belongs_to.
        # [:validate]
        #   When set to +true+, validates new objects added to association when saving the parent object. +true+ by default.
        #   If you want to ensure associated objects are revalidated on every update, use +validates_associated+.
        # [:autosave]
        #   If true, always save the associated objects or destroy them if marked for destruction,
        #   when saving the parent object. If false, never save or destroy the associated objects.
        #   By default, only save associated objects that are new records. This option is implemented as a
        #   +before_save+ callback. Because callbacks are run in the order they are defined, associated objects
        #   may need to be explicitly saved in any user-defined +before_save+ callbacks.
        #
        #   Note that NestedAttributes::ClassMethods#accepts_nested_attributes_for sets
        #   <tt>:autosave</tt> to <tt>true</tt>.
        # [:inverse_of]
        #   Specifies the name of the #belongs_to association on the associated object
        #   that is the inverse of this #has_many association. Does not work in combination
        #   with <tt>:through</tt> or <tt>:as</tt> options.
        #   See ActiveRecord::Associations::ClassMethods's overview on Bi-directional associations for more detail.
        # [:extend]
        #   Specifies a module or array of modules that will be extended into the association object returned.
        #   Useful for defining methods on associations, especially when they should be shared between multiple
        #   association objects.
        #
        # Option examples:
        #   has_many :comments, -> { order("posted_on") }
        #   has_many :comments, -> { includes(:author) }
        #   has_many :people, -> { where(deleted: false).order("name") }, class_name: "Person"
        #   has_many :tracks, -> { order("position") }, dependent: :destroy
        #   has_many :comments, dependent: :nullify
        #   has_many :tags, as: :taggable
        #   has_many :reports, -> { readonly }
        #   has_many :subscribers, through: :subscriptions, source: :user
        def has_many(name, scope = nil, options = {}, &extension)
          reflection = Builder::HasMany.build(self, name, scope, options, &extension)
          Reflection.add_reflection self, name, reflection
        end

        # Specifies a one-to-one association with another class. This method should only be used
        # if the other class contains the foreign key. If the current class contains the foreign key,
        # then you should use #belongs_to instead. See also ActiveRecord::Associations::ClassMethods's overview
        # on when to use #has_one and when to use #belongs_to.
        #
        # The following methods for retrieval and query of a single associated object will be added:
        #
        # +association+ is a placeholder for the symbol passed as the +name+ argument, so
        # <tt>has_one :manager</tt> would add among others <tt>manager.nil?</tt>.
        #
        # [association(force_reload = false)]
        #   Returns the associated object. +nil+ is returned if none is found.
        # [association=(associate)]
        #   Assigns the associate object, extracts the primary key, sets it as the foreign key,
        #   and saves the associate object. To avoid database inconsistencies, permanently deletes an existing
        #   associated object when assigning a new one, even if the new one isn't saved to database.
        # [build_association(attributes = {})]
        #   Returns a new object of the associated type that has been instantiated
        #   with +attributes+ and linked to this object through a foreign key, but has not
        #   yet been saved.
        # [create_association(attributes = {})]
        #   Returns a new object of the associated type that has been instantiated
        #   with +attributes+, linked to this object through a foreign key, and that
        #   has already been saved (if it passed the validation).
        # [create_association!(attributes = {})]
        #   Does the same as <tt>create_association</tt>, but raises ActiveRecord::RecordInvalid
        #   if the record is invalid.
        #
        # === Example
        #
        # An Account class declares <tt>has_one :beneficiary</tt>, which will add:
        # * <tt>Account#beneficiary</tt> (similar to <tt>Beneficiary.where(account_id: id).first</tt>)
        # * <tt>Account#beneficiary=(beneficiary)</tt> (similar to <tt>beneficiary.account_id = account.id; beneficiary.save</tt>)
        # * <tt>Account#build_beneficiary</tt> (similar to <tt>Beneficiary.new("account_id" => id)</tt>)
        # * <tt>Account#create_beneficiary</tt> (similar to <tt>b = Beneficiary.new("account_id" => id); b.save; b</tt>)
        # * <tt>Account#create_beneficiary!</tt> (similar to <tt>b = Beneficiary.new("account_id" => id); b.save!; b</tt>)
        #
        # === Scopes
        #
        # You can pass a second argument +scope+ as a callable (i.e. proc or
        # lambda) to retrieve a specific record or customize the generated query
        # when you access the associated object.
        #
        # Scope examples:
        #   has_one :author, -> { where(comment_id: 1) }
        #   has_one :employer, -> { joins(:company) }
        #   has_one :dob, ->(dob) { where("Date.new(2000, 01, 01) > ?", dob) }
        #
        # === Options
        #
        # The declaration can also include an +options+ hash to specialize the behavior of the association.
        #
        # Options are:
        # [:class_name]
        #   Specify the class name of the association. Use it only if that name can't be inferred
        #   from the association name. So <tt>has_one :manager</tt> will by default be linked to the Manager class, but
        #   if the real class name is Person, you'll have to specify it with this option.
        # [:dependent]
        #   Controls what happens to the associated object when
        #   its owner is destroyed:
        #
        #   * <tt>:destroy</tt> causes the associated object to also be destroyed
        #   * <tt>:delete</tt> causes the associated object to be deleted directly from the database (so callbacks will not execute)
        #   * <tt>:nullify</tt> causes the foreign key to be set to +NULL+. Callbacks are not executed.
        #   * <tt>:restrict_with_exception</tt> causes an exception to be raised if there is an associated record
        #   * <tt>:restrict_with_error</tt> causes an error to be added to the owner if there is an associated object
        #
        #   Note that <tt>:dependent</tt> option is ignored when using <tt>:through</tt> option.
        # [:foreign_key]
        #   Specify the foreign key used for the association. By default this is guessed to be the name
        #   of this class in lower-case and "_id" suffixed. So a Person class that makes a #has_one association
        #   will use "person_id" as the default <tt>:foreign_key</tt>.
        # [:foreign_type]
        #   Specify the column used to store the associated object's type, if this is a polymorphic
        #   association. By default this is guessed to be the name of the polymorphic association
        #   specified on "as" option with a "_type" suffix. So a class that defines a
        #   <tt>has_one :tag, as: :taggable</tt> association will use "taggable_type" as the
        #   default <tt>:foreign_type</tt>.
        # [:primary_key]
        #   Specify the method that returns the primary key used for the association. By default this is +id+.
        # [:as]
        #   Specifies a polymorphic interface (See #belongs_to).
        # [:through]
        #   Specifies a Join Model through which to perform the query. Options for <tt>:class_name</tt>,
        #   <tt>:primary_key</tt>, and <tt>:foreign_key</tt> are ignored, as the association uses the
        #   source reflection. You can only use a <tt>:through</tt> query through a #has_one
        #   or #belongs_to association on the join model.
        # [:source]
        #   Specifies the source association name used by #has_one <tt>:through</tt> queries.
        #   Only use it if the name cannot be inferred from the association.
        #   <tt>has_one :favorite, through: :favorites</tt> will look for a
        #   <tt>:favorite</tt> on Favorite, unless a <tt>:source</tt> is given.
        # [:source_type]
        #   Specifies type of the source association used by #has_one <tt>:through</tt> queries where the source
        #   association is a polymorphic #belongs_to.
        # [:validate]
        #   When set to +true+, validates new objects added to association when saving the parent object. +false+ by default.
        #   If you want to ensure associated objects are revalidated on every update, use +validates_associated+.
        # [:autosave]
        #   If true, always save the associated object or destroy it if marked for destruction,
        #   when saving the parent object. If false, never save or destroy the associated object.
        #   By default, only save the associated object if it's a new record.
        #
        #   Note that NestedAttributes::ClassMethods#accepts_nested_attributes_for sets
        #   <tt>:autosave</tt> to <tt>true</tt>.
        # [:inverse_of]
        #   Specifies the name of the #belongs_to association on the associated object
        #   that is the inverse of this #has_one association. Does not work in combination
        #   with <tt>:through</tt> or <tt>:as</tt> options.
        #   See ActiveRecord::Associations::ClassMethods's overview on Bi-directional associations for more detail.
        # [:required]
        #   When set to +true+, the association will also have its presence validated.
        #   This will validate the association itself, not the id. You can use
        #   +:inverse_of+ to avoid an extra query during validation.
        #
        # Option examples:
        #   has_one :credit_card, dependent: :destroy  # destroys the associated credit card
        #   has_one :credit_card, dependent: :nullify  # updates the associated records foreign
        #                                                 # key value to NULL rather than destroying it
        #   has_one :last_comment, -> { order('posted_on') }, class_name: "Comment"
        #   has_one :project_manager, -> { where(role: 'project_manager') }, class_name: "Person"
        #   has_one :attachment, as: :attachable
        #   has_one :boss, -> { readonly }
        #   has_one :club, through: :membership
        #   has_one :primary_address, -> { where(primary: true) }, through: :addressables, source: :addressable
        #   has_one :credit_card, required: true
        def has_one(name, scope = nil, options = {})
          reflection = Builder::HasOne.build(self, name, scope, options)
          Reflection.add_reflection self, name, reflection
        end

        # Specifies a one-to-one association with another class. This method should only be used
        # if this class contains the foreign key. If the other class contains the foreign key,
        # then you should use #has_one instead. See also ActiveRecord::Associations::ClassMethods's overview
        # on when to use #has_one and when to use #belongs_to.
        #
        # Methods will be added for retrieval and query for a single associated object, for which
        # this object holds an id:
        #
        # +association+ is a placeholder for the symbol passed as the +name+ argument, so
        # <tt>belongs_to :author</tt> would add among others <tt>author.nil?</tt>.
        #
        # [association(force_reload = false)]
        #   Returns the associated object. +nil+ is returned if none is found.
        # [association=(associate)]
        #   Assigns the associate object, extracts the primary key, and sets it as the foreign key.
        # [build_association(attributes = {})]
        #   Returns a new object of the associated type that has been instantiated
        #   with +attributes+ and linked to this object through a foreign key, but has not yet been saved.
        # [create_association(attributes = {})]
        #   Returns a new object of the associated type that has been instantiated
        #   with +attributes+, linked to this object through a foreign key, and that
        #   has already been saved (if it passed the validation).
        # [create_association!(attributes = {})]
        #   Does the same as <tt>create_association</tt>, but raises ActiveRecord::RecordInvalid
        #   if the record is invalid.
        #
        # === Example
        #
        # A Post class declares <tt>belongs_to :author</tt>, which will add:
        # * <tt>Post#author</tt> (similar to <tt>Author.find(author_id)</tt>)
        # * <tt>Post#author=(author)</tt> (similar to <tt>post.author_id = author.id</tt>)
        # * <tt>Post#build_author</tt> (similar to <tt>post.author = Author.new</tt>)
        # * <tt>Post#create_author</tt> (similar to <tt>post.author = Author.new; post.author.save; post.author</tt>)
        # * <tt>Post#create_author!</tt> (similar to <tt>post.author = Author.new; post.author.save!; post.author</tt>)
        # The declaration can also include an +options+ hash to specialize the behavior of the association.
        #
        # === Scopes
        #
        # You can pass a second argument +scope+ as a callable (i.e. proc or
        # lambda) to retrieve a specific record or customize the generated query
        # when you access the associated object.
        #
        # Scope examples:
        #   belongs_to :firm, -> { where(id: 2) }
        #   belongs_to :user, -> { joins(:friends) }
        #   belongs_to :level, ->(level) { where("game_level > ?", level.current) }
        #
        # === Options
        #
        # [:class_name]
        #   Specify the class name of the association. Use it only if that name can't be inferred
        #   from the association name. So <tt>belongs_to :author</tt> will by default be linked to the Author class, but
        #   if the real class name is Person, you'll have to specify it with this option.
        # [:foreign_key]
        #   Specify the foreign key used for the association. By default this is guessed to be the name
        #   of the association with an "_id" suffix. So a class that defines a <tt>belongs_to :person</tt>
        #   association will use "person_id" as the default <tt>:foreign_key</tt>. Similarly,
        #   <tt>belongs_to :favorite_person, class_name: "Person"</tt> will use a foreign key
        #   of "favorite_person_id".
        # [:foreign_type]
        #   Specify the column used to store the associated object's type, if this is a polymorphic
        #   association. By default this is guessed to be the name of the association with a "_type"
        #   suffix. So a class that defines a <tt>belongs_to :taggable, polymorphic: true</tt>
        #   association will use "taggable_type" as the default <tt>:foreign_type</tt>.
        # [:primary_key]
        #   Specify the method that returns the primary key of associated object used for the association.
        #   By default this is id.
        # [:dependent]
        #   If set to <tt>:destroy</tt>, the associated object is destroyed when this object is. If set to
        #   <tt>:delete</tt>, the associated object is deleted *without* calling its destroy method.
        #   This option should not be specified when #belongs_to is used in conjunction with
        #   a #has_many relationship on another class because of the potential to leave
        #   orphaned records behind.
        # [:counter_cache]
        #   Caches the number of belonging objects on the associate class through the use of CounterCache::ClassMethods#increment_counter
        #   and CounterCache::ClassMethods#decrement_counter. The counter cache is incremented when an object of this
        #   class is created and decremented when it's destroyed. This requires that a column
        #   named <tt>#{table_name}_count</tt> (such as +comments_count+ for a belonging Comment class)
        #   is used on the associate class (such as a Post class) - that is the migration for
        #   <tt>#{table_name}_count</tt> is created on the associate class (such that <tt>Post.comments_count</tt> will
        #   return the count cached, see note below). You can also specify a custom counter
        #   cache column by providing a column name instead of a +true+/+false+ value to this
        #   option (e.g., <tt>counter_cache: :my_custom_counter</tt>.)
        #   Note: Specifying a counter cache will add it to that model's list of readonly attributes
        #   using +attr_readonly+.
        # [:polymorphic]
        #   Specify this association is a polymorphic association by passing +true+.
        #   Note: If you've enabled the counter cache, then you may want to add the counter cache attribute
        #   to the +attr_readonly+ list in the associated classes (e.g. <tt>class Post; attr_readonly :comments_count; end</tt>).
        # [:validate]
        #   When set to +true+, validates new objects added to association when saving the parent object. +false+ by default.
        #   If you want to ensure associated objects are revalidated on every update, use +validates_associated+.
        # [:autosave]
        #   If true, always save the associated object or destroy it if marked for destruction, when
        #   saving the parent object.
        #   If false, never save or destroy the associated object.
        #   By default, only save the associated object if it's a new record.
        #
        #   Note that NestedAttributes::ClassMethods#accepts_nested_attributes_for
        #   sets <tt>:autosave</tt> to <tt>true</tt>.
        # [:touch]
        #   If true, the associated object will be touched (the updated_at/on attributes set to current time)
        #   when this record is either saved or destroyed. If you specify a symbol, that attribute
        #   will be updated with the current time in addition to the updated_at/on attribute.
        #   Please note that with touching no validation is performed and only the +after_touch+,
        #   +after_commit+ and +after_rollback+ callbacks are executed.
        # [:inverse_of]
        #   Specifies the name of the #has_one or #has_many association on the associated
        #   object that is the inverse of this #belongs_to association. Does not work in
        #   combination with the <tt>:polymorphic</tt> options.
        #   See ActiveRecord::Associations::ClassMethods's overview on Bi-directional associations for more detail.
        # [:optional]
        #   When set to +true+, the association will not have its presence validated.
        # [:required]
        #   When set to +true+, the association will also have its presence validated.
        #   This will validate the association itself, not the id. You can use
        #   +:inverse_of+ to avoid an extra query during validation.
        #   NOTE: <tt>required</tt> is set to <tt>true</tt> by default and is deprecated. If
        #   you don't want to have association presence validated, use <tt>optional: true</tt>.
        #
        # Option examples:
        #   belongs_to :firm, foreign_key: "client_of"
        #   belongs_to :person, primary_key: "name", foreign_key: "person_name"
        #   belongs_to :author, class_name: "Person", foreign_key: "author_id"
        #   belongs_to :valid_coupon, ->(o) { where "discounts > ?", o.payments_count },
        #                             class_name: "Coupon", foreign_key: "coupon_id"
        #   belongs_to :attachable, polymorphic: true
        #   belongs_to :project, -> { readonly }
        #   belongs_to :post, counter_cache: true
        #   belongs_to :comment, touch: true
        #   belongs_to :company, touch: :employees_last_updated_at
        #   belongs_to :user, optional: true
        def belongs_to(name, scope = nil, options = {})
          reflection = Builder::BelongsTo.build(self, name, scope, options)
          Reflection.add_reflection self, name, reflection
        end

        # Specifies a many-to-many relationship with another class. This associates two classes via an
        # intermediate join table. Unless the join table is explicitly specified as an option, it is
        # guessed using the lexical order of the class names. So a join between Developer and Project
        # will give the default join table name of "developers_projects" because "D" precedes "P" alphabetically.
        # Note that this precedence is calculated using the <tt><</tt> operator for String. This
        # means that if the strings are of different lengths, and the strings are equal when compared
        # up to the shortest length, then the longer string is considered of higher
        # lexical precedence than the shorter one. For example, one would expect the tables "paper_boxes" and "papers"
        # to generate a join table name of "papers_paper_boxes" because of the length of the name "paper_boxes",
        # but it in fact generates a join table name of "paper_boxes_papers". Be aware of this caveat, and use the
        # custom <tt>:join_table</tt> option if you need to.
        # If your tables share a common prefix, it will only appear once at the beginning. For example,
        # the tables "catalog_categories" and "catalog_products" generate a join table name of "catalog_categories_products".
        #
        # The join table should not have a primary key or a model associated with it. You must manually generate the
        # join table with a migration such as this:
        #
        #   class CreateDevelopersProjectsJoinTable < ActiveRecord::Migration[5.0]
        #     def change
        #       create_join_table :developers, :projects
        #     end
        #   end
        #
        # It's also a good idea to add indexes to each of those columns to speed up the joins process.
        # However, in MySQL it is advised to add a compound index for both of the columns as MySQL only
        # uses one index per table during the lookup.
        #
        # Adds the following methods for retrieval and query:
        #
        # +collection+ is a placeholder for the symbol passed as the +name+ argument, so
        # <tt>has_and_belongs_to_many :categories</tt> would add among others <tt>categories.empty?</tt>.
        #
        # [collection(force_reload = false)]
        #   Returns an array of all the associated objects.
        #   An empty array is returned if none are found.
        # [collection<<(object, ...)]
        #   Adds one or more objects to the collection by creating associations in the join table
        #   (<tt>collection.push</tt> and <tt>collection.concat</tt> are aliases to this method).
        #   Note that this operation instantly fires update SQL without waiting for the save or update call on the
        #   parent object, unless the parent object is a new record.
        # [collection.delete(object, ...)]
        #   Removes one or more objects from the collection by removing their associations from the join table.
        #   This does not destroy the objects.
        # [collection.destroy(object, ...)]
        #   Removes one or more objects from the collection by running destroy on each association in the join table, overriding any dependent option.
        #   This does not destroy the objects.
        # [collection=objects]
        #   Replaces the collection's content by deleting and adding objects as appropriate.
        # [collection_singular_ids]
        #   Returns an array of the associated objects' ids.
        # [collection_singular_ids=ids]
        #   Replace the collection by the objects identified by the primary keys in +ids+.
        # [collection.clear]
        #   Removes every object from the collection. This does not destroy the objects.
        # [collection.empty?]
        #   Returns +true+ if there are no associated objects.
        # [collection.size]
        #   Returns the number of associated objects.
        # [collection.find(id)]
        #   Finds an associated object responding to the +id+ and that
        #   meets the condition that it has to be associated with this object.
        #   Uses the same rules as ActiveRecord::FinderMethods#find.
        # [collection.exists?(...)]
        #   Checks whether an associated object with the given conditions exists.
        #   Uses the same rules as ActiveRecord::FinderMethods#exists?.
        # [collection.build(attributes = {})]
        #   Returns a new object of the collection type that has been instantiated
        #   with +attributes+ and linked to this object through the join table, but has not yet been saved.
        # [collection.create(attributes = {})]
        #   Returns a new object of the collection type that has been instantiated
        #   with +attributes+, linked to this object through the join table, and that has already been
        #   saved (if it passed the validation).
        #
        # === Example
        #
        # A Developer class declares <tt>has_and_belongs_to_many :projects</tt>, which will add:
        # * <tt>Developer#projects</tt>
        # * <tt>Developer#projects<<</tt>
        # * <tt>Developer#projects.delete</tt>
        # * <tt>Developer#projects.destroy</tt>
        # * <tt>Developer#projects=</tt>
        # * <tt>Developer#project_ids</tt>
        # * <tt>Developer#project_ids=</tt>
        # * <tt>Developer#projects.clear</tt>
        # * <tt>Developer#projects.empty?</tt>
        # * <tt>Developer#projects.size</tt>
        # * <tt>Developer#projects.find(id)</tt>
        # * <tt>Developer#projects.exists?(...)</tt>
        # * <tt>Developer#projects.build</tt> (similar to <tt>Project.new("developer_id" => id)</tt>)
        # * <tt>Developer#projects.create</tt> (similar to <tt>c = Project.new("developer_id" => id); c.save; c</tt>)
        # The declaration may include an +options+ hash to specialize the behavior of the association.
        #
        # === Scopes
        #
        # You can pass a second argument +scope+ as a callable (i.e. proc or
        # lambda) to retrieve a specific set of records or customize the generated
        # query when you access the associated collection.
        #
        # Scope examples:
        #   has_and_belongs_to_many :projects, -> { includes(:milestones, :manager) }
        #   has_and_belongs_to_many :categories, ->(category) {
        #     where("default_category = ?", category.name)
        #   }
        #
        # === Extensions
        #
        # The +extension+ argument allows you to pass a block into a
        # has_and_belongs_to_many association. This is useful for adding new
        # finders, creators and other factory-type methods to be used as part of
        # the association.
        #
        # Extension examples:
        #   has_and_belongs_to_many :contractors do
        #     def find_or_create_by_name(name)
        #       first_name, last_name = name.split(" ", 2)
        #       find_or_create_by(first_name: first_name, last_name: last_name)
        #     end
        #   end
        #
        # === Options
        #
        # [:class_name]
        #   Specify the class name of the association. Use it only if that name can't be inferred
        #   from the association name. So <tt>has_and_belongs_to_many :projects</tt> will by default be linked to the
        #   Project class, but if the real class name is SuperProject, you'll have to specify it with this option.
        # [:join_table]
        #   Specify the name of the join table if the default based on lexical order isn't what you want.
        #   <b>WARNING:</b> If you're overwriting the table name of either class, the +table_name+ method
        #   MUST be declared underneath any #has_and_belongs_to_many declaration in order to work.
        # [:foreign_key]
        #   Specify the foreign key used for the association. By default this is guessed to be the name
        #   of this class in lower-case and "_id" suffixed. So a Person class that makes
        #   a #has_and_belongs_to_many association to Project will use "person_id" as the
        #   default <tt>:foreign_key</tt>.
        # [:association_foreign_key]
        #   Specify the foreign key used for the association on the receiving side of the association.
        #   By default this is guessed to be the name of the associated class in lower-case and "_id" suffixed.
        #   So if a Person class makes a #has_and_belongs_to_many association to Project,
        #   the association will use "project_id" as the default <tt>:association_foreign_key</tt>.
        # [:validate]
        #   When set to +true+, validates new objects added to association when saving the parent object. +true+ by default.
        #   If you want to ensure associated objects are revalidated on every update, use +validates_associated+.
        # [:autosave]
        #   If true, always save the associated objects or destroy them if marked for destruction, when
        #   saving the parent object.
        #   If false, never save or destroy the associated objects.
        #   By default, only save associated objects that are new records.
        #
        #   Note that NestedAttributes::ClassMethods#accepts_nested_attributes_for sets
        #   <tt>:autosave</tt> to <tt>true</tt>.
        #
        # Option examples:
        #   has_and_belongs_to_many :projects
        #   has_and_belongs_to_many :projects, -> { includes(:milestones, :manager) }
        #   has_and_belongs_to_many :nations, class_name: "Country"
        #   has_and_belongs_to_many :categories, join_table: "prods_cats"
        #   has_and_belongs_to_many :categories, -> { readonly }
        def has_and_belongs_to_many(name, scope = nil, options = {}, &extension)
          if scope.is_a?(Hash)
            options = scope
            scope   = nil
          end

          habtm_reflection = ActiveRecord::Reflection::HasAndBelongsToManyReflection.new(name, scope, options, self)

          builder = Builder::HasAndBelongsToMany.new name, self, options

          join_model = builder.through_model

          const_set join_model.name, join_model
          private_constant join_model.name

          middle_reflection = builder.middle_reflection join_model

          Builder::HasMany.define_callbacks self, middle_reflection
          Reflection.add_reflection self, middle_reflection.name, middle_reflection
          middle_reflection.parent_reflection = habtm_reflection

          include Module.new {
            class_eval <<-RUBY, __FILE__, __LINE__ + 1
          def destroy_associations
            association(:#{middle_reflection.name}).delete_all(:delete_all)
            association(:#{name}).reset
            super
          end
          RUBY
          }

          hm_options = {}
          hm_options[:through] = middle_reflection.name
          hm_options[:source] = join_model.right_reflection.name

          [:before_add, :after_add, :before_remove, :after_remove, :autosave, :validate, :join_table, :class_name, :extend].each do |k|
            hm_options[k] = options[k] if options.key? k
          end

          has_many name, scope, hm_options, &extension
          self._reflections[name.to_s].parent_reflection = habtm_reflection
        end
      end
  end
end
require "cases/helper"
require "models/computer"
require "models/developer"
require "models/project"
require "models/company"
require "models/categorization"
require "models/category"
require "models/post"
require "models/author"
require "models/comment"
require "models/tag"
require "models/tagging"
require "models/person"
require "models/reader"
require "models/ship_part"
require "models/ship"
require "models/liquid"
require "models/molecule"
require "models/electron"
require "models/man"
require "models/interest"

class AssociationsTest < ActiveRecord::TestCase
  fixtures :accounts, :companies, :developers, :projects, :developers_projects,
           :computers, :people, :readers, :authors, :author_favorites

  def test_eager_loading_should_not_change_count_of_children
    liquid = Liquid.create(name: "salty")
    molecule = liquid.molecules.create(name: "molecule_1")
    molecule.electrons.create(name: "electron_1")
    molecule.electrons.create(name: "electron_2")

    liquids = Liquid.includes(molecules: :electrons).references(:molecules).where("molecules.id is not null")
    assert_equal 1, liquids[0].molecules.length
  end

  def test_subselect
    author = authors :david
    favs = author.author_favorites
    fav2 = author.author_favorites.where(author: Author.where(id: author.id)).to_a
    assert_equal favs, fav2
  end

  def test_loading_the_association_target_should_keep_child_records_marked_for_destruction
    ship = Ship.create!(name: "The good ship Dollypop")
    part = ship.parts.create!(name: "Mast")
    part.mark_for_destruction
    assert ship.parts[0].marked_for_destruction?
  end

  def test_loading_the_association_target_should_load_most_recent_attributes_for_child_records_marked_for_destruction
    ship = Ship.create!(name: "The good ship Dollypop")
    part = ship.parts.create!(name: "Mast")
    part.mark_for_destruction
    ShipPart.find(part.id).update_columns(name: "Deck")
    assert_equal "Deck", ship.parts[0].name
  end

  def test_include_with_order_works
    assert_nothing_raised {Account.all.merge!(order: "id", includes: :firm).first}
    assert_nothing_raised {Account.all.merge!(order: :id, includes: :firm).first}
  end

  def test_bad_collection_keys
    assert_raise(ArgumentError, "ActiveRecord should have barked on bad collection keys") do
      Class.new(ActiveRecord::Base).has_many(:wheels, name: "wheels")
    end
  end

  def test_should_construct_new_finder_sql_after_create
    person = Person.new first_name: "clark"
    assert_equal [], person.readers.to_a
    person.save!
    reader = Reader.create! person: person, post: Post.new(title: "foo", body: "bar")
    assert person.readers.find(reader.id)
  end

  def test_force_reload
    firm = Firm.new("name" => "A New Firm, Inc")
    firm.save
    firm.clients.each {} # forcing to load all clients
    assert firm.clients.empty?, "New firm shouldn't have client objects"
    assert_equal 0, firm.clients.size, "New firm should have 0 clients"

    client = Client.new("name" => "TheClient.com", "firm_id" => firm.id)
    client.save

    assert firm.clients.empty?, "New firm should have cached no client objects"
    assert_equal 0, firm.clients.size, "New firm should have cached 0 clients count"

    ActiveSupport::Deprecation.silence do
      assert !firm.clients(true).empty?, "New firm should have reloaded client objects"
      assert_equal 1, firm.clients(true).size, "New firm should have reloaded clients count"
    end
  end

  def test_using_limitable_reflections_helper
    using_limitable_reflections = lambda { |reflections| Tagging.all.send :using_limitable_reflections?, reflections }
    belongs_to_reflections = [Tagging.reflect_on_association(:tag), Tagging.reflect_on_association(:super_tag)]
    has_many_reflections = [Tag.reflect_on_association(:taggings), Developer.reflect_on_association(:projects)]
    mixed_reflections = (belongs_to_reflections + has_many_reflections).uniq
    assert using_limitable_reflections.call(belongs_to_reflections), "Belong to associations are limitable"
    assert !using_limitable_reflections.call(has_many_reflections), "All has many style associations are not limitable"
    assert !using_limitable_reflections.call(mixed_reflections), "No collection associations (has many style) should pass"
  end

  def test_force_reload_is_uncached
    firm = Firm.create!("name" => "A New Firm, Inc")
    Client.create!("name" => "TheClient.com", :firm => firm)

    ActiveSupport::Deprecation.silence do
      ActiveRecord::Base.cache do
        firm.clients.each {}
        assert_queries(0) { assert_not_nil firm.clients.each {} }
        assert_queries(1) { assert_not_nil firm.clients(true).each {} }
      end
    end
  end

  def test_association_with_references
    firm = companies(:first_firm)
    assert_includes firm.association_with_references.references_values, "foo"
  end
end

class AssociationProxyTest < ActiveRecord::TestCase
  fixtures :authors, :posts, :categorizations, :categories, :developers, :projects, :developers_projects

  def test_push_does_not_load_target
    david = authors(:david)

    david.posts << (post = Post.new(title: "New on Edge", body: "More cool stuff!"))
    assert !david.posts.loaded?
    assert david.posts.include?(post)
  end

  def test_push_has_many_through_does_not_load_target
    david = authors(:david)

    david.categories << categories(:technology)
    assert !david.categories.loaded?
    assert david.categories.include?(categories(:technology))
  end

  def test_push_followed_by_save_does_not_load_target
    david = authors(:david)

    david.posts << (post = Post.new(title: "New on Edge", body: "More cool stuff!"))
    assert !david.posts.loaded?
    david.save
    assert !david.posts.loaded?
    assert david.posts.include?(post)
  end

  def test_push_does_not_lose_additions_to_new_record
    josh = Author.new(name: "Josh")
    josh.posts << Post.new(title: "New on Edge", body: "More cool stuff!")
    assert josh.posts.loaded?
    assert_equal 1, josh.posts.size
  end

  def test_append_behaves_like_push
    josh = Author.new(name: "Josh")
    josh.posts.append Post.new(title: "New on Edge", body: "More cool stuff!")
    assert josh.posts.loaded?
    assert_equal 1, josh.posts.size
  end

  def test_prepend_is_not_defined
    josh = Author.new(name: "Josh")
    assert_raises(NoMethodError) { josh.posts.prepend Post.new }
  end

  def test_save_on_parent_does_not_load_target
    david = developers(:david)

    assert !david.projects.loaded?
    david.update_columns(created_at: Time.now)
    assert !david.projects.loaded?
  end

  def test_load_does_load_target
    david = developers(:david)

    assert !david.projects.loaded?
    david.projects.load
    assert david.projects.loaded?
  end

  def test_inspect_does_not_reload_a_not_yet_loaded_target
    andreas = Developer.new name: "Andreas", log: "new developer added"
    assert !andreas.audit_logs.loaded?
    assert_match(/message: "new developer added"/, andreas.audit_logs.inspect)
  end

  def test_save_on_parent_saves_children
    developer = Developer.create name: "Bryan", salary: 50_000
    assert_equal 1, developer.reload.audit_logs.size
  end

  def test_create_via_association_with_block
    post = authors(:david).posts.create(title: "New on Edge") {|p| p.body = "More cool stuff!"}
    assert_equal post.title, "New on Edge"
    assert_equal post.body, "More cool stuff!"
  end

  def test_create_with_bang_via_association_with_block
    post = authors(:david).posts.create!(title: "New on Edge") {|p| p.body = "More cool stuff!"}
    assert_equal post.title, "New on Edge"
    assert_equal post.body, "More cool stuff!"
  end

  def test_reload_returns_association
    david = developers(:david)
    assert_nothing_raised do
      assert_equal david.projects, david.projects.reload.reload
    end
  end

  def test_proxy_association_accessor
    david = developers(:david)
    assert_equal david.association(:projects), david.projects.proxy_association
  end

  def test_scoped_allows_conditions
    assert developers(:david).projects.merge(where: "foo").to_sql.include?("foo")
  end

  test "getting a scope from an association" do
    david = developers(:david)

    assert david.projects.scope.is_a?(ActiveRecord::Relation)
    assert_equal david.projects, david.projects.scope
  end

  test "proxy object is cached" do
    david = developers(:david)
    assert david.projects.equal?(david.projects)
  end

  test "inverses get set of subsets of the association" do
    man = Man.create
    man.interests.create

    man = Man.find(man.id)

    assert_queries(1) do
      assert_equal man, man.interests.where("1=1").first.man
    end
  end

  test "first! works on loaded associations" do
    david = authors(:david)
    assert_equal david.posts.first, david.posts.reload.first!
    assert david.posts.loaded?
    assert_no_queries { david.posts.first! }
  end

  def test_reset_unloads_target
    david = authors(:david)
    david.posts.reload

    assert david.posts.loaded?
    david.posts.reset
    assert !david.posts.loaded?
  end
end

class OverridingAssociationsTest < ActiveRecord::TestCase
  class DifferentPerson < ActiveRecord::Base; end

  class PeopleList < ActiveRecord::Base
    has_and_belongs_to_many :has_and_belongs_to_many, before_add: :enlist
    has_many :has_many, before_add: :enlist
    belongs_to :belongs_to
    has_one :has_one
  end

  class DifferentPeopleList < PeopleList
    # Different association with the same name, callbacks should be omitted here.
    has_and_belongs_to_many :has_and_belongs_to_many, class_name: "DifferentPerson"
    has_many :has_many, class_name: "DifferentPerson"
    belongs_to :belongs_to, class_name: "DifferentPerson"
    has_one :has_one, class_name: "DifferentPerson"
  end

  def test_habtm_association_redefinition_callbacks_should_differ_and_not_inherited
    # redeclared association on AR descendant should not inherit callbacks from superclass
    callbacks = PeopleList.before_add_for_has_and_belongs_to_many
    assert_equal(1, callbacks.length)
    callbacks = DifferentPeopleList.before_add_for_has_and_belongs_to_many
    assert_equal([], callbacks)
  end

  def test_has_many_association_redefinition_callbacks_should_differ_and_not_inherited
    # redeclared association on AR descendant should not inherit callbacks from superclass
    callbacks = PeopleList.before_add_for_has_many
    assert_equal(1, callbacks.length)
    callbacks = DifferentPeopleList.before_add_for_has_many
    assert_equal([], callbacks)
  end

  def test_habtm_association_redefinition_reflections_should_differ_and_not_inherited
    assert_not_equal(
      PeopleList.reflect_on_association(:has_and_belongs_to_many),
      DifferentPeopleList.reflect_on_association(:has_and_belongs_to_many)
    )
  end

  def test_has_many_association_redefinition_reflections_should_differ_and_not_inherited
    assert_not_equal(
      PeopleList.reflect_on_association(:has_many),
      DifferentPeopleList.reflect_on_association(:has_many)
    )
  end

  def test_belongs_to_association_redefinition_reflections_should_differ_and_not_inherited
    assert_not_equal(
      PeopleList.reflect_on_association(:belongs_to),
      DifferentPeopleList.reflect_on_association(:belongs_to)
    )
  end

  def test_has_one_association_redefinition_reflections_should_differ_and_not_inherited
    assert_not_equal(
      PeopleList.reflect_on_association(:has_one),
      DifferentPeopleList.reflect_on_association(:has_one)
    )
  end

  def test_requires_symbol_argument
    assert_raises ArgumentError do
      Class.new(Post) do
        belongs_to "author"
      end
    end
  end
end

class GeneratedMethodsTest < ActiveRecord::TestCase
  fixtures :developers, :computers, :posts, :comments
  def test_association_methods_override_attribute_methods_of_same_name
    assert_equal(developers(:david), computers(:workstation).developer)
    # this next line will fail if the attribute methods module is generated lazily
    # after the association methods module is generated
    assert_equal(developers(:david), computers(:workstation).developer)
    assert_equal(developers(:david).id, computers(:workstation)[:developer])
  end

  def test_model_method_overrides_association_method
    assert_equal(comments(:greetings).body, posts(:welcome).first_comment)
  end

  module MyModule
    def comments; :none end
  end

  class MyArticle < ActiveRecord::Base
    self.table_name = "articles"
    include MyModule
    has_many :comments, inverse_of: false
  end

  def test_included_module_overwrites_association_methods
    assert_equal :none, MyArticle.new.comments
  end
end
require "cases/helper"
require "models/topic"
require "models/reply"
require "models/man"
require "models/interest"

class AssociationValidationTest < ActiveRecord::TestCase
  fixtures :topics

  repair_validations(Topic, Reply)

  def test_validates_associated_many
    Topic.validates_associated(:replies)
    Reply.validates_presence_of(:content)
    t = Topic.create("title" => "uhohuhoh", "content" => "whatever")
    t.replies << [r = Reply.new("title" => "A reply"), r2 = Reply.new("title" => "Another reply", "content" => "non-empty"), r3 = Reply.new("title" => "Yet another reply"), r4 = Reply.new("title" => "The last reply", "content" => "non-empty")]
    assert !t.valid?
    assert t.errors[:replies].any?
    assert_equal 1, r.errors.count  # make sure all associated objects have been validated
    assert_equal 0, r2.errors.count
    assert_equal 1, r3.errors.count
    assert_equal 0, r4.errors.count
    r.content = r3.content = "non-empty"
    assert t.valid?
  end

  def test_validates_associated_one
    Reply.validates :topic, associated: true
    Topic.validates_presence_of( :content )
    r = Reply.new("title" => "A reply", "content" => "with content!")
    r.topic = Topic.create("title" => "uhohuhoh")
    assert !r.valid?
    assert r.errors[:topic].any?
    r.topic.content = "non-empty"
    assert r.valid?
  end

  def test_validates_associated_marked_for_destruction
    Topic.validates_associated(:replies)
    Reply.validates_presence_of(:content)
    t = Topic.new
    t.replies << Reply.new
    assert t.invalid?
    t.replies.first.mark_for_destruction
    assert t.valid?
  end

  def test_validates_associated_without_marked_for_destruction
    reply = Class.new do
      def valid?
        true
      end
    end
    Topic.validates_associated(:replies)
    t = Topic.new
    t.define_singleton_method(:replies) { [reply.new] }
    assert t.valid?
  end

  def test_validates_associated_with_custom_message_using_quotes
    Reply.validates_associated :topic, message: "This string contains 'single' and \"double\" quotes"
    Topic.validates_presence_of :content
    r = Reply.create("title" => "A reply", "content" => "with content!")
    r.topic = Topic.create("title" => "uhohuhoh")
    assert_not_operator r, :valid?
    assert_equal ["This string contains 'single' and \"double\" quotes"], r.errors[:topic]
  end

  def test_validates_associated_missing
    Reply.validates_presence_of(:topic)
    r = Reply.create("title" => "A reply", "content" => "with content!")
    assert !r.valid?
    assert r.errors[:topic].any?

    r.topic = Topic.first
    assert r.valid?
  end

  def test_validates_presence_of_belongs_to_association__parent_is_new_record
    repair_validations(Interest) do
      # Note that Interest and Man have the :inverse_of option set
      Interest.validates_presence_of(:man)
      man = Man.new(name: "John")
      interest = man.interests.build(topic: "Airplanes")
      assert interest.valid?, "Expected interest to be valid, but was not. Interest should have a man object associated"
    end
  end

  def test_validates_presence_of_belongs_to_association__existing_parent
    repair_validations(Interest) do
      Interest.validates_presence_of(:man)
      man = Man.create!(name: "John")
      interest = man.interests.build(topic: "Airplanes")
      assert interest.valid?, "Expected interest to be valid, but was not. Interest should have a man object associated"
    end
  end
end
require "securerandom"
require "concurrent/scheduled_task"
require "concurrent/executor/thread_pool_executor"
require "concurrent/utility/processor_counter"

module ActiveJob
  module QueueAdapters
    # == Active Job Async adapter
    #
    # The Async adapter runs jobs with an in-process thread pool.
    #
    # This is the default queue adapter. It's well-suited for dev/test since
    # it doesn't need an external infrastructure, but it's a poor fit for
    # production since it drops pending jobs on restart.
    #
    # To use this adapter, set queue adapter to +:async+:
    #
    #   config.active_job.queue_adapter = :async
    #
    # To configure the adapter's thread pool, instantiate the adapter and
    # pass your own config:
    #
    #   config.active_job.queue_adapter = ActiveJob::QueueAdapters::AsyncAdapter.new \
    #     min_threads: 1,
    #     max_threads: 2 * Concurrent.processor_count,
    #     idletime: 600.seconds
    #
    # The adapter uses a {Concurrent Ruby}[https://github.com/ruby-concurrency/concurrent-ruby] thread pool to schedule and execute
    # jobs. Since jobs share a single thread pool, long-running jobs will block
    # short-lived jobs. Fine for dev/test; bad for production.
    class AsyncAdapter
      # See {Concurrent::ThreadPoolExecutor}[http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/ThreadPoolExecutor.html] for executor options.
      def initialize(**executor_options)
        @scheduler = Scheduler.new(**executor_options)
      end

      def enqueue(job) #:nodoc:
        @scheduler.enqueue JobWrapper.new(job), queue_name: job.queue_name
      end

      def enqueue_at(job, timestamp) #:nodoc:
        @scheduler.enqueue_at JobWrapper.new(job), timestamp, queue_name: job.queue_name
      end

      # Gracefully stop processing jobs. Finishes in-progress work and handles
      # any new jobs following the executor's fallback policy (`caller_runs`).
      # Waits for termination by default. Pass `wait: false` to continue.
      def shutdown(wait: true) #:nodoc:
        @scheduler.shutdown wait: wait
      end

      # Used for our test suite.
      def immediate=(immediate) #:nodoc:
        @scheduler.immediate = immediate
      end

      # Note that we don't actually need to serialize the jobs since we're
      # performing them in-process, but we do so anyway for parity with other
      # adapters and deployment environments. Otherwise, serialization bugs
      # may creep in undetected.
      class JobWrapper #:nodoc:
        def initialize(job)
          job.provider_job_id = SecureRandom.uuid
          @job_data = job.serialize
        end

        def perform
          Base.execute @job_data
        end
      end

      class Scheduler #:nodoc:
        DEFAULT_EXECUTOR_OPTIONS = {
          min_threads:     0,
          max_threads:     Concurrent.processor_count,
          auto_terminate:  true,
          idletime:        60, # 1 minute
          max_queue:       0, # unlimited
          fallback_policy: :caller_runs # shouldn't matter -- 0 max queue
        }.freeze

        attr_accessor :immediate

        def initialize(**options)
          self.immediate = false
          @immediate_executor = Concurrent::ImmediateExecutor.new
          @async_executor = Concurrent::ThreadPoolExecutor.new(DEFAULT_EXECUTOR_OPTIONS.merge(options))
        end

        def enqueue(job, queue_name:)
          executor.post(job, &:perform)
        end

        def enqueue_at(job, timestamp, queue_name:)
          delay = timestamp - Time.current.to_f
          if delay > 0
            Concurrent::ScheduledTask.execute(delay, args: [job], executor: executor, &:perform)
          else
            enqueue(job, queue_name: queue_name)
          end
        end

        def shutdown(wait: true)
          @async_executor.shutdown
          @async_executor.wait_for_termination if wait
        end

        def executor
          immediate ? @immediate_executor : @async_executor
        end
      end
    end
  end
end
require "action_cable/subscription_adapter/inline"

module ActionCable
  module SubscriptionAdapter
    class Async < Inline # :nodoc:
      private
        def new_subscriber_map
          AsyncSubscriberMap.new(server.event_loop)
        end

        class AsyncSubscriberMap < SubscriberMap
          def initialize(event_loop)
            @event_loop = event_loop
            super()
          end

          def add_subscriber(*)
            @event_loop.post { super }
          end

          def invoke_callback(*)
            @event_loop.post { super }
          end
        end
    end
  end
end
require "test_helper"
require_relative "./common"

class AsyncAdapterTest < ActionCable::TestCase
  include CommonSubscriptionAdapterTest

  def setup
    super

    @tx_adapter.shutdown
    @tx_adapter = @rx_adapter
  end

  def cable_config
    { adapter: "async" }
  end
end
require "set"

module ActionView
  # = Action View Atom Feed Helpers
  module Helpers
    module AtomFeedHelper
      # Adds easy defaults to writing Atom feeds with the Builder template engine (this does not work on ERB or any other
      # template languages).
      #
      # Full usage example:
      #
      #   config/routes.rb:
      #     Rails.application.routes.draw do
      #       resources :posts
      #       root to: "posts#index"
      #     end
      #
      #   app/controllers/posts_controller.rb:
      #     class PostsController < ApplicationController
      #       # GET /posts.html
      #       # GET /posts.atom
      #       def index
      #         @posts = Post.all
      #
      #         respond_to do |format|
      #           format.html
      #           format.atom
      #         end
      #       end
      #     end
      #
      #   app/views/posts/index.atom.builder:
      #     atom_feed do |feed|
      #       feed.title("My great blog!")
      #       feed.updated(@posts[0].created_at) if @posts.length > 0
      #
      #       @posts.each do |post|
      #         feed.entry(post) do |entry|
      #           entry.title(post.title)
      #           entry.content(post.body, type: 'html')
      #
      #           entry.author do |author|
      #             author.name("DHH")
      #           end
      #         end
      #       end
      #     end
      #
      # The options for atom_feed are:
      #
      # * <tt>:language</tt>: Defaults to "en-US".
      # * <tt>:root_url</tt>: The HTML alternative that this feed is doubling for. Defaults to / on the current host.
      # * <tt>:url</tt>: The URL for this feed. Defaults to the current URL.
      # * <tt>:id</tt>: The id for this feed. Defaults to "tag:localhost,2005:/posts", in this case.
      # * <tt>:schema_date</tt>: The date at which the tag scheme for the feed was first used. A good default is the year you
      #   created the feed. See http://feedvalidator.org/docs/error/InvalidTAG.html for more information. If not specified,
      #   2005 is used (as an "I don't care" value).
      # * <tt>:instruct</tt>: Hash of XML processing instructions in the form {target => {attribute => value, }} or {target => [{attribute => value, }, ]}
      #
      # Other namespaces can be added to the root element:
      #
      #   app/views/posts/index.atom.builder:
      #     atom_feed({'xmlns:app' => 'http://www.w3.org/2007/app',
      #         'xmlns:openSearch' => 'http://a9.com/-/spec/opensearch/1.1/'}) do |feed|
      #       feed.title("My great blog!")
      #       feed.updated((@posts.first.created_at))
      #       feed.tag!('openSearch:totalResults', 10)
      #
      #       @posts.each do |post|
      #         feed.entry(post) do |entry|
      #           entry.title(post.title)
      #           entry.content(post.body, type: 'html')
      #           entry.tag!('app:edited', Time.now)
      #
      #           entry.author do |author|
      #             author.name("DHH")
      #           end
      #         end
      #       end
      #     end
      #
      # The Atom spec defines five elements (content rights title subtitle
      # summary) which may directly contain xhtml content if type: 'xhtml'
      # is specified as an attribute. If so, this helper will take care of
      # the enclosing div and xhtml namespace declaration. Example usage:
      #
      #    entry.summary type: 'xhtml' do |xhtml|
      #      xhtml.p pluralize(order.line_items.count, "line item")
      #      xhtml.p "Shipped to #{order.address}"
      #      xhtml.p "Paid by #{order.pay_type}"
      #    end
      #
      #
      # <tt>atom_feed</tt> yields an +AtomFeedBuilder+ instance. Nested elements yield
      # an +AtomBuilder+ instance.
      def atom_feed(options = {}, &block)
        if options[:schema_date]
          options[:schema_date] = options[:schema_date].strftime("%Y-%m-%d") if options[:schema_date].respond_to?(:strftime)
        else
          options[:schema_date] = "2005" # The Atom spec copyright date
        end

        xml = options.delete(:xml) || eval("xml", block.binding)
        xml.instruct!
        if options[:instruct]
          options[:instruct].each do |target,attrs|
            if attrs.respond_to?(:keys)
              xml.instruct!(target, attrs)
            elsif attrs.respond_to?(:each)
              attrs.each { |attr_group| xml.instruct!(target, attr_group) }
            end
          end
        end

        feed_opts = {"xml:lang" => options[:language] || "en-US", "xmlns" => "http://www.w3.org/2005/Atom"}
        feed_opts.merge!(options).reject!{|k,v| !k.to_s.match(/^xml/)}

        xml.feed(feed_opts) do
          xml.id(options[:id] || "tag:#{request.host},#{options[:schema_date]}:#{request.fullpath.split(".")[0]}")
          xml.link(rel: "alternate", type: "text/html", href: options[:root_url] || (request.protocol + request.host_with_port))
          xml.link(rel: "self", type: "application/atom+xml", href: options[:url] || request.url)

          yield AtomFeedBuilder.new(xml, self, options)
        end
      end

      class AtomBuilder #:nodoc:
        XHTML_TAG_NAMES = %w(content rights title subtitle summary).to_set

        def initialize(xml)
          @xml = xml
        end

        private
          # Delegate to xml builder, first wrapping the element in an xhtml
          # namespaced div element if the method and arguments indicate
          # that an xhtml_block? is desired.
          def method_missing(method, *arguments, &block)
            if xhtml_block?(method, arguments)
              @xml.__send__(method, *arguments) do
                @xml.div(xmlns: "http://www.w3.org/1999/xhtml") do |xhtml|
                  block.call(xhtml)
                end
              end
            else
              @xml.__send__(method, *arguments, &block)
            end
          end

          # True if the method name matches one of the five elements defined
          # in the Atom spec as potentially containing XHTML content and
          # if type: 'xhtml' is, in fact, specified.
          def xhtml_block?(method, arguments)
            if XHTML_TAG_NAMES.include?(method.to_s)
              last = arguments.last
              last.is_a?(Hash) && last[:type].to_s == "xhtml"
            end
          end
      end

      class AtomFeedBuilder < AtomBuilder #:nodoc:
        def initialize(xml, view, feed_options = {})
          @xml, @view, @feed_options = xml, view, feed_options
        end

        # Accepts a Date or Time object and inserts it in the proper format. If nil is passed, current time in UTC is used.
        def updated(date_or_time = nil)
          @xml.updated((date_or_time || Time.now.utc).xmlschema)
        end

        # Creates an entry tag for a specific record and prefills the id using class and id.
        #
        # Options:
        #
        # * <tt>:published</tt>: Time first published. Defaults to the created_at attribute on the record if one such exists.
        # * <tt>:updated</tt>: Time of update. Defaults to the updated_at attribute on the record if one such exists.
        # * <tt>:url</tt>: The URL for this entry or false or nil for not having a link tag. Defaults to the polymorphic_url for the record.
        # * <tt>:id</tt>: The ID for this entry. Defaults to "tag:#{@view.request.host},#{@feed_options[:schema_date]}:#{record.class}/#{record.id}"
        # * <tt>:type</tt>: The TYPE for this entry. Defaults to "text/html".
        def entry(record, options = {})
          @xml.entry do
            @xml.id(options[:id] || "tag:#{@view.request.host},#{@feed_options[:schema_date]}:#{record.class}/#{record.id}")

            if options[:published] || (record.respond_to?(:created_at) && record.created_at)
              @xml.published((options[:published] || record.created_at).xmlschema)
            end

            if options[:updated] || (record.respond_to?(:updated_at) && record.updated_at)
              @xml.updated((options[:updated] || record.updated_at).xmlschema)
            end

            type = options.fetch(:type, "text/html")

            url = options.fetch(:url) { @view.polymorphic_url(record) }
            @xml.link(rel: "alternate", type: type, href: url) if url

            yield AtomBuilder.new(@xml)
          end
        end
      end
    end
  end
end
require "abstract_unit"

class Scroll < Struct.new(:id, :to_param, :title, :body, :updated_at, :created_at)
  extend ActiveModel::Naming
  include ActiveModel::Conversion

  def persisted?
    false
  end
end

class ScrollsController < ActionController::Base
  FEEDS = {}
  FEEDS["defaults"] = <<-EOT
        atom_feed(:schema_date => '2008') do |feed|
          feed.title("My great blog!")
          feed.updated(@scrolls.first.created_at)

          @scrolls.each do |scroll|
            feed.entry(scroll) do |entry|
              entry.title(scroll.title)
              entry.content(scroll.body, :type => 'html')

              entry.author do |author|
                author.name("DHH")
              end
            end
          end
        end
    EOT
  FEEDS["entry_options"] = <<-EOT
        atom_feed do |feed|
          feed.title("My great blog!")
          feed.updated(@scrolls.first.created_at)

          @scrolls.each do |scroll|
            feed.entry(scroll, :url => "/otherstuff/" + scroll.to_param.to_s, :updated => Time.utc(2007, 1, scroll.id)) do |entry|
              entry.title(scroll.title)
              entry.content(scroll.body, :type => 'html')

              entry.author do |author|
                author.name("DHH")
              end
            end
          end
        end
    EOT
  FEEDS["entry_type_options"] = <<-EOT
        atom_feed(:schema_date => '2008') do |feed|
          feed.title("My great blog!")
          feed.updated(@scrolls.first.created_at)

          @scrolls.each do |scroll|
            feed.entry(scroll, :type => 'text/xml') do |entry|
              entry.title(scroll.title)
              entry.content(scroll.body, :type => 'html')

              entry.author do |author|
                author.name("DHH")
              end
            end
          end
        end
    EOT
  FEEDS["entry_url_false_option"] = <<-EOT
        atom_feed do |feed|
          feed.title("My great blog!")
          feed.updated(@scrolls.first.created_at)

          @scrolls.each do |scroll|
            feed.entry(scroll, :url => false) do |entry|
              entry.title(scroll.title)
              entry.content(scroll.body, :type => 'html')

              entry.author do |author|
                author.name("DHH")
              end
            end
          end
        end
    EOT
  FEEDS["xml_block"] = <<-EOT
        atom_feed do |feed|
          feed.title("My great blog!")
          feed.updated(@scrolls.first.created_at)

          feed.author do |author|
            author.name("DHH")
          end

          @scrolls.each do |scroll|
            feed.entry(scroll, :url => "/otherstuff/" + scroll.to_param.to_s, :updated => Time.utc(2007, 1, scroll.id)) do |entry|
              entry.title(scroll.title)
              entry.content(scroll.body, :type => 'html')
            end
          end
        end
    EOT
  FEEDS["feed_with_atomPub_namespace"] = <<-EOT
        atom_feed({'xmlns:app' => 'http://www.w3.org/2007/app',
                 'xmlns:openSearch' => 'http://a9.com/-/spec/opensearch/1.1/'}) do |feed|
          feed.title("My great blog!")
          feed.updated(@scrolls.first.created_at)

          @scrolls.each do |scroll|
            feed.entry(scroll) do |entry|
              entry.title(scroll.title)
              entry.content(scroll.body, :type => 'html')
              entry.tag!('app:edited', Time.now)

              entry.author do |author|
                author.name("DHH")
              end
            end
          end
        end
    EOT
  FEEDS["feed_with_overridden_ids"] = <<-EOT
        atom_feed({:id => 'tag:test.rubyonrails.org,2008:test/'}) do |feed|
          feed.title("My great blog!")
          feed.updated(@scrolls.first.created_at)

          @scrolls.each do |scroll|
            feed.entry(scroll, :id => "tag:test.rubyonrails.org,2008:"+scroll.id.to_s) do |entry|
              entry.title(scroll.title)
              entry.content(scroll.body, :type => 'html')
              entry.tag!('app:edited', Time.now)

              entry.author do |author|
                author.name("DHH")
              end
            end
          end
        end
    EOT
  FEEDS["feed_with_xml_processing_instructions"] = <<-EOT
        atom_feed(:schema_date => '2008',
          :instruct => {'xml-stylesheet' => { :href=> 't.css', :type => 'text/css' }}) do |feed|
          feed.title("My great blog!")
          feed.updated(@scrolls.first.created_at)

          @scrolls.each do |scroll|
            feed.entry(scroll) do |entry|
              entry.title(scroll.title)
              entry.content(scroll.body, :type => 'html')

              entry.author do |author|
                author.name("DHH")
              end
            end
          end
        end
    EOT
  FEEDS["feed_with_xml_processing_instructions_duplicate_targets"] = <<-EOT
        atom_feed(:schema_date => '2008',
          :instruct => {'target1' => [{ :a => '1', :b => '2' }, { :c => '3', :d => '4' }]}) do |feed|
          feed.title("My great blog!")
          feed.updated(@scrolls.first.created_at)

          @scrolls.each do |scroll|
            feed.entry(scroll) do |entry|
              entry.title(scroll.title)
              entry.content(scroll.body, :type => 'html')

              entry.author do |author|
                author.name("DHH")
              end
            end
          end
        end
    EOT
  FEEDS["feed_with_xhtml_content"] = <<-'EOT'
        atom_feed do |feed|
          feed.title("My great blog!")
          feed.updated(@scrolls.first.created_at)

          @scrolls.each do |scroll|
            feed.entry(scroll) do |entry|
              entry.title(scroll.title)
              entry.summary(:type => 'xhtml') do |xhtml|
                xhtml.p "before #{scroll.id}"
                xhtml.p {xhtml << scroll.body}
                xhtml.p "after #{scroll.id}"
              end
              entry.tag!('app:edited', Time.now)

              entry.author do |author|
                author.name("DHH")
              end
            end
          end
        end
    EOT
  FEEDS["provide_builder"] = <<-'EOT'
          # we pass in the new_xml to the helper so it doesn't
          # call anything on the original builder
          new_xml = Builder::XmlMarkup.new(:target=>'')
          atom_feed(:xml => new_xml) do |feed|
            feed.title("My great blog!")
            feed.updated(@scrolls.first.created_at)

            @scrolls.each do |scroll|
              feed.entry(scroll) do |entry|
                entry.title(scroll.title)
                entry.content(scroll.body, :type => 'html')

                entry.author do |author|
                  author.name("DHH")
                end
              end
            end
          end
    EOT
  def index
    @scrolls = [
      Scroll.new(1, "1", "Hello One", "Something <i>COOL!</i>", Time.utc(2007, 12, 12, 15), Time.utc(2007, 12, 12, 15)),
      Scroll.new(2, "2", "Hello Two", "Something Boring", Time.utc(2007, 12, 12, 15)),
    ]

    render inline: FEEDS[params[:id]], type: :builder
  end
end

class AtomFeedTest < ActionController::TestCase
  tests ScrollsController

  def setup
    super
    @request.host = "www.nextangle.com"
  end

  def test_feed_should_use_default_language_if_none_is_given
    with_restful_routing(:scrolls) do
      get :index, params: { id: "defaults" }
      assert_match(%r{xml:lang="en-US"}, @response.body)
    end
  end

  def test_feed_should_include_two_entries
    with_restful_routing(:scrolls) do
      get :index, params: { id: "defaults" }
      assert_select "entry", 2
    end
  end

  def test_entry_should_only_use_published_if_created_at_is_present
    with_restful_routing(:scrolls) do
      get :index, params: { id: "defaults" }
      assert_select "published", 1
    end
  end

  def test_providing_builder_to_atom_feed
    with_restful_routing(:scrolls) do
      get :index, params: { id: "provide_builder" }
      # because we pass in the non-default builder, the content generated by the
      # helper should go 'nowhere'.  Leaving the response body blank.
      assert @response.body.blank?
    end
  end

  def test_entry_with_prefilled_options_should_use_those_instead_of_querying_the_record
    with_restful_routing(:scrolls) do
      get :index, params: { id: "entry_options" }

      assert_select "updated", Time.utc(2007, 1, 1).xmlschema
      assert_select "updated", Time.utc(2007, 1, 2).xmlschema
    end
  end

  def test_self_url_should_default_to_current_request_url
    with_restful_routing(:scrolls) do
      get :index, params: { id: "defaults" }
      assert_select "link[rel=self][href=\"http://www.nextangle.com/scrolls?id=defaults\"]"
    end
  end

  def test_feed_id_should_be_a_valid_tag
    with_restful_routing(:scrolls) do
      get :index, params: { id: "defaults" }
      assert_select "id", text: "tag:www.nextangle.com,2008:/scrolls?id=defaults"
    end
  end

  def test_entry_id_should_be_a_valid_tag
    with_restful_routing(:scrolls) do
      get :index, params: { id: "defaults" }
      assert_select "entry id", text: "tag:www.nextangle.com,2008:Scroll/1"
      assert_select "entry id", text: "tag:www.nextangle.com,2008:Scroll/2"
    end
  end

  def test_feed_should_allow_nested_xml_blocks
    with_restful_routing(:scrolls) do
      get :index, params: { id: "xml_block" }
      assert_select "author name", text: "DHH"
    end
  end

  def test_feed_should_include_atomPub_namespace
    with_restful_routing(:scrolls) do
      get :index, params: { id: "feed_with_atomPub_namespace" }
      assert_match %r{xml:lang="en-US"}, @response.body
      assert_match %r{xmlns="http://www.w3.org/2005/Atom"}, @response.body
      assert_match %r{xmlns:app="http://www.w3.org/2007/app"}, @response.body
    end
  end

  def test_feed_should_allow_overriding_ids
    with_restful_routing(:scrolls) do
      get :index, params: { id: "feed_with_overridden_ids" }
      assert_select "id", text: "tag:test.rubyonrails.org,2008:test/"
      assert_select "entry id", text: "tag:test.rubyonrails.org,2008:1"
      assert_select "entry id", text: "tag:test.rubyonrails.org,2008:2"
    end
  end

  def test_feed_xml_processing_instructions
    with_restful_routing(:scrolls) do
      get :index, params: { id: "feed_with_xml_processing_instructions" }
      assert_match %r{<\?xml-stylesheet [^\?]*type="text/css"}, @response.body
      assert_match %r{<\?xml-stylesheet [^\?]*href="t.css"}, @response.body
    end
  end

  def test_feed_xml_processing_instructions_duplicate_targets
    with_restful_routing(:scrolls) do
      get :index, params: { id: "feed_with_xml_processing_instructions_duplicate_targets" }
      assert_match %r{<\?target1 (a="1" b="2"|b="2" a="1")\?>}, @response.body
      assert_match %r{<\?target1 (c="3" d="4"|d="4" c="3")\?>}, @response.body
    end
  end

  def test_feed_xhtml
    with_restful_routing(:scrolls) do
      get :index, params: { id:  "feed_with_xhtml_content" }
      assert_match %r{xmlns="http://www.w3.org/1999/xhtml"}, @response.body
      assert_select "summary", text: /Something Boring/
      assert_select "summary", text: /after 2/
    end
  end

  def test_feed_entry_type_option_default_to_text_html
    with_restful_routing(:scrolls) do
      get :index, params: { id: "defaults" }
      assert_select "entry link[rel=alternate][type=\"text/html\"]"
    end
  end

  def test_feed_entry_type_option_specified
    with_restful_routing(:scrolls) do
      get :index, params: { id: "entry_type_options" }
      assert_select "entry link[rel=alternate][type=\"text/xml\"]"
    end
  end

  def test_feed_entry_url_false_option_adds_no_link
    with_restful_routing(:scrolls) do
      get :index, params: { id: "entry_url_false_option" }
      assert_select "entry link", false
    end
  end

  private
    def with_restful_routing(resources)
      with_routing do |set|
        set.draw do
          resources(resources)
        end
        yield
      end
    end
end
require "fileutils"

class File
  # Write to a file atomically. Useful for situations where you don't
  # want other processes or threads to see half-written files.
  #
  #   File.atomic_write('important.file') do |file|
  #     file.write('hello')
  #   end
  #
  # This method needs to create a temporary file. By default it will create it
  # in the same directory as the destination file. If you don't like this
  # behavior you can provide a different directory but it must be on the
  # same physical filesystem as the file you're trying to write.
  #
  #   File.atomic_write('/data/something.important', '/data/tmp') do |file|
  #     file.write('hello')
  #   end
  def self.atomic_write(file_name, temp_dir = dirname(file_name))
    require "tempfile" unless defined?(Tempfile)

    Tempfile.open(".#{basename(file_name)}", temp_dir) do |temp_file|
      temp_file.binmode
      return_val = yield temp_file
      temp_file.close

      old_stat = if exist?(file_name)
        # Get original file permissions
        stat(file_name)
      elsif temp_dir != dirname(file_name)
        # If not possible, probe which are the default permissions in the
        # destination directory.
        probe_stat_in(dirname(file_name))
      end

      if old_stat
        # Set correct permissions on new file
        begin
          chown(old_stat.uid, old_stat.gid, temp_file.path)
          # This operation will affect filesystem ACL's
          chmod(old_stat.mode, temp_file.path)
        rescue Errno::EPERM, Errno::EACCES
          # Changing file ownership failed, moving on.
        end
      end

      # Overwrite original file with temp file
      rename(temp_file.path, file_name)
      return_val
    end
  end

  # Private utility method.
  def self.probe_stat_in(dir) #:nodoc:
    basename = [
      ".permissions_check",
      Thread.current.object_id,
      Process.pid,
      rand(1000000)
    ].join(".")

    file_name = join(dir, basename)
    FileUtils.touch(file_name)
    stat(file_name)
  ensure
    FileUtils.rm_f(file_name) if file_name
  end
end
require "abstract_unit"
require "active_support/core_ext/module/attribute_accessors_per_thread"

class ModuleAttributeAccessorPerThreadTest < ActiveSupport::TestCase
  def setup
    @class = Class.new do
      thread_mattr_accessor :foo
      thread_mattr_accessor :bar,  instance_writer: false
      thread_mattr_reader   :shaq, instance_reader: false
      thread_mattr_accessor :camp, instance_accessor: false

      def self.name; "MyClass" end
    end

    @subclass = Class.new(@class) do
      def self.name; "SubMyClass" end
    end

    @object = @class.new
  end

  def test_should_use_mattr_default
    Thread.new do
      assert_nil @class.foo
      assert_nil @object.foo
    end.join
  end

  def test_should_set_mattr_value
    Thread.new do
      @class.foo = :test
      assert_equal :test, @class.foo

      @class.foo = :test2
      assert_equal :test2, @class.foo
    end.join
  end

  def test_should_not_create_instance_writer
    Thread.new do
      assert_respond_to @class, :foo
      assert_respond_to @class, :foo=
      assert_respond_to @object, :bar
      assert !@object.respond_to?(:bar=)
    end.join
  end

  def test_should_not_create_instance_reader
    Thread.new do
      assert_respond_to @class, :shaq
      assert !@object.respond_to?(:shaq)
    end.join
  end

  def test_should_not_create_instance_accessors
    Thread.new do
      assert_respond_to @class, :camp
      assert !@object.respond_to?(:camp)
      assert !@object.respond_to?(:camp=)
    end.join
  end

  def test_values_should_not_bleed_between_threads
    threads = []
    threads << Thread.new do
      @class.foo = "things"
      sleep 1
      assert_equal "things", @class.foo
    end

    threads << Thread.new do
      @class.foo = "other things"
      sleep 1
      assert_equal "other things", @class.foo
    end

    threads << Thread.new do
      @class.foo = "really other things"
      sleep 1
      assert_equal "really other things", @class.foo
    end

    threads.each { |t| t.join }
  end

  def test_should_raise_name_error_if_attribute_name_is_invalid
    exception = assert_raises NameError do
      Class.new do
        thread_cattr_reader "1nvalid"
      end
    end
    assert_equal "invalid attribute name: 1nvalid", exception.message

    exception = assert_raises NameError do
      Class.new do
        thread_cattr_writer "1nvalid"
      end
    end
    assert_equal "invalid attribute name: 1nvalid", exception.message

    exception = assert_raises NameError do
      Class.new do
        thread_mattr_reader "1valid_part"
      end
    end
    assert_equal "invalid attribute name: 1valid_part", exception.message

    exception = assert_raises NameError do
      Class.new do
        thread_mattr_writer "2valid_part"
      end
    end
    assert_equal "invalid attribute name: 2valid_part", exception.message
  end

  def test_should_return_same_value_by_class_or_instance_accessor
    @class.foo = "fries"

    assert_equal @class.foo, @object.foo
  end

  def test_should_not_affect_superclass_if_subclass_set_value
    @class.foo = "super"
    assert_equal @class.foo, "super"
    assert_nil @subclass.foo

    @subclass.foo = "sub"
    assert_equal @class.foo, "super"
    assert_equal @subclass.foo, "sub"
  end
end
require "active_support/core_ext/array/extract_options"
require "active_support/core_ext/regexp"

# Extends the module object with class/module and instance accessors for
# class/module attributes, just like the native attr* accessors for instance
# attributes, but does so on a per-thread basis.
#
# So the values are scoped within the Thread.current space under the class name
# of the module.
class Module
  # Defines a per-thread class attribute and creates class and instance reader methods.
  # The underlying per-thread class variable is set to +nil+, if it is not previously defined.
  #
  #   module Current
  #     thread_mattr_reader :user
  #   end
  #
  #   Current.user # => nil
  #   Thread.current[:attr_Current_user] = "DHH"
  #   Current.user # => "DHH"
  #
  # The attribute name must be a valid method name in Ruby.
  #
  #   module Foo
  #     thread_mattr_reader :"1_Badname"
  #   end
  #   # => NameError: invalid attribute name: 1_Badname
  #
  # If you want to opt out of the creation of the instance reader method, pass
  # <tt>instance_reader: false</tt> or <tt>instance_accessor: false</tt>.
  #
  #   class Current
  #     thread_mattr_reader :user, instance_reader: false
  #   end
  #
  #   Current.new.user # => NoMethodError
  def thread_mattr_reader(*syms)
    options = syms.extract_options!

    syms.each do |sym|
      raise NameError.new("invalid attribute name: #{sym}") unless /^[_A-Za-z]\w*$/.match?(sym)

      # The following generated method concatenates `name` because we want it
      # to work with inheritance via polymorphism.
      class_eval(<<-EOS, __FILE__, __LINE__ + 1)
        def self.#{sym}
          Thread.current["attr_" + name + "_#{sym}"]
        end
      EOS

      unless options[:instance_reader] == false || options[:instance_accessor] == false
        class_eval(<<-EOS, __FILE__, __LINE__ + 1)
          def #{sym}
            self.class.#{sym}
          end
        EOS
      end
    end
  end
  alias :thread_cattr_reader :thread_mattr_reader

  # Defines a per-thread class attribute and creates a class and instance writer methods to
  # allow assignment to the attribute.
  #
  #   module Current
  #     thread_mattr_writer :user
  #   end
  #
  #   Current.user = "DHH"
  #   Thread.current[:attr_Current_user] # => "DHH"
  #
  # If you want to opt out of the creation of the instance writer method, pass
  # <tt>instance_writer: false</tt> or <tt>instance_accessor: false</tt>.
  #
  #   class Current
  #     thread_mattr_writer :user, instance_writer: false
  #   end
  #
  #   Current.new.user = "DHH" # => NoMethodError
  def thread_mattr_writer(*syms)
    options = syms.extract_options!
    syms.each do |sym|
      raise NameError.new("invalid attribute name: #{sym}") unless /^[_A-Za-z]\w*$/.match?(sym)

      # The following generated method concatenates `name` because we want it
      # to work with inheritance via polymorphism.
      class_eval(<<-EOS, __FILE__, __LINE__ + 1)
        def self.#{sym}=(obj)
          Thread.current["attr_" + name + "_#{sym}"] = obj
        end
      EOS

      unless options[:instance_writer] == false || options[:instance_accessor] == false
        class_eval(<<-EOS, __FILE__, __LINE__ + 1)
          def #{sym}=(obj)
            self.class.#{sym} = obj
          end
        EOS
      end
    end
  end
  alias :thread_cattr_writer :thread_mattr_writer

  # Defines both class and instance accessors for class attributes.
  #
  #   class Account
  #     thread_mattr_accessor :user
  #   end
  #
  #   Account.user = "DHH"
  #   Account.user     # => "DHH"
  #   Account.new.user # => "DHH"
  #
  # If a subclass changes the value, the parent class' value is not changed.
  # Similarly, if the parent class changes the value, the value of subclasses
  # is not changed.
  #
  #   class Customer < Account
  #   end
  #
  #   Customer.user = "Rafael"
  #   Customer.user # => "Rafael"
  #   Account.user  # => "DHH"
  #
  # To opt out of the instance writer method, pass <tt>instance_writer: false</tt>.
  # To opt out of the instance reader method, pass <tt>instance_reader: false</tt>.
  #
  #   class Current
  #     thread_mattr_accessor :user, instance_writer: false, instance_reader: false
  #   end
  #
  #   Current.new.user = "DHH"  # => NoMethodError
  #   Current.new.user          # => NoMethodError
  #
  # Or pass <tt>instance_accessor: false</tt>, to opt out both instance methods.
  #
  #   class Current
  #     mattr_accessor :user, instance_accessor: false
  #   end
  #
  #   Current.new.user = "DHH"  # => NoMethodError
  #   Current.new.user          # => NoMethodError
  def thread_mattr_accessor(*syms, &blk)
    thread_mattr_reader(*syms, &blk)
    thread_mattr_writer(*syms, &blk)
  end
  alias :thread_cattr_accessor :thread_mattr_accessor
end
# cattr_* became mattr_* aliases in 7dfbd91b0780fbd6a1dd9bfbc176e10894871d2d,
# but we keep this around for libraries that directly require it knowing they
# want cattr_*. No need to deprecate.
require "active_support/core_ext/module/attribute_accessors"
require "abstract_unit"
require "active_support/core_ext/module/attribute_accessors"

class ModuleAttributeAccessorTest < ActiveSupport::TestCase
  def setup
    m = @module = Module.new do
      mattr_accessor :foo
      mattr_accessor :bar, instance_writer: false
      mattr_reader   :shaq, instance_reader: false
      mattr_accessor :camp, instance_accessor: false

      cattr_accessor(:defa) { "default_accessor_value" }
      cattr_reader(:defr) { "default_reader_value" }
      cattr_writer(:defw) { "default_writer_value" }
      cattr_accessor(:quux) { :quux }
    end
    @class = Class.new
    @class.instance_eval { include m }
    @object = @class.new
  end

  def test_should_use_mattr_default
    assert_nil @module.foo
    assert_nil @object.foo
  end

  def test_should_set_mattr_value
    @module.foo = :test
    assert_equal :test, @object.foo

    @object.foo = :test2
    assert_equal :test2, @module.foo
  end

  def test_cattr_accessor_default_value
    assert_equal :quux, @module.quux
    assert_equal :quux, @object.quux
  end

  def test_should_not_create_instance_writer
    assert_respond_to @module, :foo
    assert_respond_to @module, :foo=
    assert_respond_to @object, :bar
    assert !@object.respond_to?(:bar=)
  end

  def test_should_not_create_instance_reader
    assert_respond_to @module, :shaq
    assert !@object.respond_to?(:shaq)
  end

  def test_should_not_create_instance_accessors
    assert_respond_to @module, :camp
    assert !@object.respond_to?(:camp)
    assert !@object.respond_to?(:camp=)
  end

  def test_should_raise_name_error_if_attribute_name_is_invalid
    exception = assert_raises NameError do
      Class.new do
        cattr_reader "1nvalid"
      end
    end
    assert_equal "invalid attribute name: 1nvalid", exception.message

    exception = assert_raises NameError do
      Class.new do
        cattr_writer "1nvalid"
      end
    end
    assert_equal "invalid attribute name: 1nvalid", exception.message

    exception = assert_raises NameError do
      Class.new do
        mattr_reader "valid_part\ninvalid_part"
      end
    end
    assert_equal "invalid attribute name: valid_part\ninvalid_part", exception.message

    exception = assert_raises NameError do
      Class.new do
        mattr_writer "valid_part\ninvalid_part"
      end
    end
    assert_equal "invalid attribute name: valid_part\ninvalid_part", exception.message
  end

  def test_should_use_default_value_if_block_passed
    assert_equal "default_accessor_value", @module.defa
    assert_equal "default_reader_value", @module.defr
    assert_equal "default_writer_value", @module.class_variable_get("@@defw")
  end

  def test_should_not_invoke_default_value_block_multiple_times
    count = 0
    @module.cattr_accessor(:defcount){ count += 1 }
    assert_equal 1, count
  end
end
require "abstract_unit"
require "active_support/core_ext/module/aliasing"

module AttributeAliasing
  class Content
    attr_accessor :title, :Data

    def initialize
      @title, @Data = nil, nil
    end

    def title?
      !title.nil?
    end

    def Data?
      !self.Data.nil?
    end
  end

  class Email < Content
    alias_attribute :subject, :title
    alias_attribute :body, :Data
  end
end

class AttributeAliasingTest < ActiveSupport::TestCase
  def test_attribute_alias
    e = AttributeAliasing::Email.new

    assert !e.subject?

    e.title = "Upgrade computer"
    assert_equal "Upgrade computer", e.subject
    assert e.subject?

    e.subject = "We got a long way to go"
    assert_equal "We got a long way to go", e.title
    assert e.title?
  end

  def test_aliasing_to_uppercase_attributes
    # Although it's very un-Ruby, some people's AR-mapped tables have
    # upper-case attributes, and when people want to alias those names
    # to more sensible ones, everything goes *foof*.
    e = AttributeAliasing::Email.new

    assert !e.body?
    assert !e.Data?

    e.body = "No, really, this is not a joke."
    assert_equal "No, really, this is not a joke.", e.Data
    assert e.Data?

    e.Data = "Uppercased methods are teh suck"
    assert_equal "Uppercased methods are teh suck", e.body
    assert e.body?
  end
end
require "active_support/core_ext/hash/keys"

module ActiveModel
  module AttributeAssignment
    include ActiveModel::ForbiddenAttributesProtection

    # Allows you to set all the attributes by passing in a hash of attributes with
    # keys matching the attribute names.
    #
    # If the passed hash responds to <tt>permitted?</tt> method and the return value
    # of this method is +false+ an <tt>ActiveModel::ForbiddenAttributesError</tt>
    # exception is raised.
    #
    #   class Cat
    #     include ActiveModel::AttributeAssignment
    #     attr_accessor :name, :status
    #   end
    #
    #   cat = Cat.new
    #   cat.assign_attributes(name: "Gorby", status: "yawning")
    #   cat.name # => 'Gorby'
    #   cat.status => 'yawning'
    #   cat.assign_attributes(status: "sleeping")
    #   cat.name # => 'Gorby'
    #   cat.status => 'sleeping'
    def assign_attributes(new_attributes)
      if !new_attributes.respond_to?(:stringify_keys)
        raise ArgumentError, "When assigning attributes, you must pass a hash as an argument."
      end
      return if new_attributes.nil? || new_attributes.empty?

      attributes = new_attributes.stringify_keys
      _assign_attributes(sanitize_for_mass_assignment(attributes))
    end

    private

      def _assign_attributes(attributes)
        attributes.each do |k, v|
          _assign_attribute(k, v)
        end
      end

      def _assign_attribute(k, v)
        if respond_to?("#{k}=")
          public_send("#{k}=", v)
        else
          raise UnknownAttributeError.new(self, k)
        end
      end
  end
end
require "cases/helper"
require "active_support/core_ext/hash/indifferent_access"
require "active_support/hash_with_indifferent_access"

class AttributeAssignmentTest < ActiveModel::TestCase
  class Model
    include ActiveModel::AttributeAssignment

    attr_accessor :name, :description

    def initialize(attributes = {})
      assign_attributes(attributes)
    end

    def broken_attribute=(value)
      raise ErrorFromAttributeWriter
    end

    protected

      attr_writer :metadata
  end

  class ErrorFromAttributeWriter < StandardError
  end

  class ProtectedParams
    attr_accessor :permitted
    alias :permitted? :permitted

    delegate :keys, :key?, :has_key?, :empty?, to: :@parameters

    def initialize(attributes)
      @parameters = attributes.with_indifferent_access
      @permitted = false
    end

    def permit!
      @permitted = true
      self
    end

    def [](key)
      @parameters[key]
    end

    def to_h
      @parameters
    end

    def stringify_keys
      dup
    end

    def dup
      super.tap do |duplicate|
        duplicate.instance_variable_set :@permitted, permitted?
      end
    end
  end

  test "simple assignment" do
    model = Model.new

    model.assign_attributes(name: "hello", description: "world")
    assert_equal "hello", model.name
    assert_equal "world", model.description
  end

  test "assign non-existing attribute" do
    model = Model.new
    error = assert_raises(ActiveModel::UnknownAttributeError) do
      model.assign_attributes(hz: 1)
    end

    assert_equal model, error.record
    assert_equal "hz", error.attribute
  end

  test "assign private attribute" do
    model = Model.new
    assert_raises(ActiveModel::UnknownAttributeError) do
      model.assign_attributes(metadata: { a: 1 })
    end
  end

  test "does not swallow errors raised in an attribute writer" do
    assert_raises(ErrorFromAttributeWriter) do
      Model.new(broken_attribute: 1)
    end
  end

  test "an ArgumentError is raised if a non-hash-like object is passed" do
    assert_raises(ArgumentError) do
      Model.new(1)
    end
  end

  test "forbidden attributes cannot be used for mass assignment" do
    params = ProtectedParams.new(name: "Guille", description: "m")

    assert_raises(ActiveModel::ForbiddenAttributesError) do
      Model.new(params)
    end
  end

  test "permitted attributes can be used for mass assignment" do
    params = ProtectedParams.new(name: "Guille", description: "desc")
    params.permit!
    model = Model.new(params)

    assert_equal "Guille", model.name
    assert_equal "desc", model.description
  end

  test "regular hash should still be used for mass assignment" do
    model = Model.new(name: "Guille", description: "m")

    assert_equal "Guille", model.name
    assert_equal "m", model.description
  end

  test "assigning no attributes should not raise, even if the hash is un-permitted" do
    model = Model.new
    assert_nil model.assign_attributes(ProtectedParams.new({}))
  end
end
module ActiveRecord
  module AttributeDecorators # :nodoc:
    extend ActiveSupport::Concern

    included do
      class_attribute :attribute_type_decorations, instance_accessor: false # :internal:
      self.attribute_type_decorations = TypeDecorator.new
    end

    module ClassMethods # :nodoc:
      def decorate_attribute_type(column_name, decorator_name, &block)
        matcher = ->(name, _) { name == column_name.to_s }
        key = "_#{column_name}_#{decorator_name}"
        decorate_matching_attribute_types(matcher, key, &block)
      end

      def decorate_matching_attribute_types(matcher, decorator_name, &block)
        reload_schema_from_cache
        decorator_name = decorator_name.to_s

        # Create new hashes so we don't modify parent classes
        self.attribute_type_decorations = attribute_type_decorations.merge(decorator_name => [matcher, block])
      end

      private

        def load_schema!
          super
          attribute_types.each do |name, type|
            decorated_type = attribute_type_decorations.apply(name, type)
            define_attribute(name, decorated_type)
          end
        end
    end

    class TypeDecorator # :nodoc:
      delegate :clear, to: :@decorations

      def initialize(decorations = {})
        @decorations = decorations
      end

      def merge(*args)
        TypeDecorator.new(@decorations.merge(*args))
      end

      def apply(name, type)
        decorations = decorators_for(name, type)
        decorations.inject(type) do |new_type, block|
          block.call(new_type)
        end
      end

      private

        def decorators_for(name, type)
          matching(name, type).map(&:last)
        end

        def matching(name, type)
          @decorations.values.select do |(matcher, _)|
            matcher.call(name, type)
          end
        end
    end
  end
end
require "cases/helper"

module ActiveRecord
  class AttributeDecoratorsTest < ActiveRecord::TestCase
    class Model < ActiveRecord::Base
      self.table_name = "attribute_decorators_model"
    end

    class StringDecorator < SimpleDelegator
      def initialize(delegate, decoration = "decorated!")
        @decoration = decoration
        super(delegate)
      end

      def cast(value)
        "#{super} #{@decoration}"
      end

      alias deserialize cast
    end

    setup do
      @connection = ActiveRecord::Base.connection
      @connection.create_table :attribute_decorators_model, force: true do |t|
        t.string :a_string
      end
    end

    teardown do
      return unless @connection
      @connection.drop_table "attribute_decorators_model", if_exists: true
      Model.attribute_type_decorations.clear
      Model.reset_column_information
    end

    test "attributes can be decorated" do
      model = Model.new(a_string: "Hello")
      assert_equal "Hello", model.a_string

      Model.decorate_attribute_type(:a_string, :test) { |t| StringDecorator.new(t) }

      model = Model.new(a_string: "Hello")
      assert_equal "Hello decorated!", model.a_string
    end

    test "decoration does not eagerly load existing columns" do
      Model.reset_column_information
      assert_no_queries do
        Model.decorate_attribute_type(:a_string, :test) { |t| StringDecorator.new(t) }
      end
    end

    test "undecorated columns are not touched" do
      Model.attribute :another_string, :string, default: "something or other"
      Model.decorate_attribute_type(:a_string, :test) { |t| StringDecorator.new(t) }

      assert_equal "something or other", Model.new.another_string
    end

    test "decorators can be chained" do
      Model.decorate_attribute_type(:a_string, :test) { |t| StringDecorator.new(t) }
      Model.decorate_attribute_type(:a_string, :other) { |t| StringDecorator.new(t) }

      model = Model.new(a_string: "Hello!")

      assert_equal "Hello! decorated! decorated!", model.a_string
    end

    test "decoration of the same type multiple times is idempotent" do
      Model.decorate_attribute_type(:a_string, :test) { |t| StringDecorator.new(t) }
      Model.decorate_attribute_type(:a_string, :test) { |t| StringDecorator.new(t) }

      model = Model.new(a_string: "Hello")
      assert_equal "Hello decorated!", model.a_string
    end

    test "decorations occur in order of declaration" do
      Model.decorate_attribute_type(:a_string, :test) { |t| StringDecorator.new(t) }
      Model.decorate_attribute_type(:a_string, :other) do |type|
        StringDecorator.new(type, "decorated again!")
      end

      model = Model.new(a_string: "Hello!")

      assert_equal "Hello! decorated! decorated again!", model.a_string
    end

    test "decorating attributes does not modify parent classes" do
      Model.attribute :another_string, :string, default: "whatever"
      Model.decorate_attribute_type(:a_string, :test) { |t| StringDecorator.new(t) }
      child_class = Class.new(Model)
      child_class.decorate_attribute_type(:another_string, :test) { |t| StringDecorator.new(t) }
      child_class.decorate_attribute_type(:a_string, :other) { |t| StringDecorator.new(t) }

      model = Model.new(a_string: "Hello!")
      child = child_class.new(a_string: "Hello!")

      assert_equal "Hello! decorated!", model.a_string
      assert_equal "whatever", model.another_string
      assert_equal "Hello! decorated! decorated!", child.a_string
      assert_equal "whatever decorated!", child.another_string
    end

    class Multiplier < SimpleDelegator
      def cast(value)
        return if value.nil?
        value * 2
      end
      alias deserialize cast
    end

    test "decorating with a proc" do
      Model.attribute :an_int, :integer
      type_is_integer = proc { |_, type| type.type == :integer }
      Model.decorate_matching_attribute_types type_is_integer, :multiplier do |type|
        Multiplier.new(type)
      end

      model = Model.new(a_string: "whatever", an_int: 1)

      assert_equal "whatever", model.a_string
      assert_equal 2, model.an_int
    end
  end
end
require "concurrent/map"
require "mutex_m"
require "active_support/core_ext/regexp"

module ActiveModel
  # Raised when an attribute is not defined.
  #
  #   class User < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   user = User.first
  #   user.pets.select(:id).first.user_id
  #   # => ActiveModel::MissingAttributeError: missing attribute: user_id
  class MissingAttributeError < NoMethodError
  end

  # == Active \Model \Attribute \Methods
  #
  # Provides a way to add prefixes and suffixes to your methods as
  # well as handling the creation of <tt>ActiveRecord::Base</tt>-like
  # class methods such as +table_name+.
  #
  # The requirements to implement <tt>ActiveModel::AttributeMethods</tt> are to:
  #
  # * <tt>include ActiveModel::AttributeMethods</tt> in your class.
  # * Call each of its methods you want to add, such as +attribute_method_suffix+
  #   or +attribute_method_prefix+.
  # * Call +define_attribute_methods+ after the other methods are called.
  # * Define the various generic +_attribute+ methods that you have declared.
  # * Define an +attributes+ method which returns a hash with each
  #   attribute name in your model as hash key and the attribute value as hash value.
  #   Hash keys must be strings.
  #
  # A minimal implementation could be:
  #
  #   class Person
  #     include ActiveModel::AttributeMethods
  #
  #     attribute_method_affix  prefix: 'reset_', suffix: '_to_default!'
  #     attribute_method_suffix '_contrived?'
  #     attribute_method_prefix 'clear_'
  #     define_attribute_methods :name
  #
  #     attr_accessor :name
  #
  #     def attributes
  #       { 'name' => @name }
  #     end
  #
  #     private
  #
  #     def attribute_contrived?(attr)
  #       true
  #     end
  #
  #     def clear_attribute(attr)
  #       send("#{attr}=", nil)
  #     end
  #
  #     def reset_attribute_to_default!(attr)
  #       send("#{attr}=", 'Default Name')
  #     end
  #   end
  module AttributeMethods
    extend ActiveSupport::Concern

    NAME_COMPILABLE_REGEXP = /\A[a-zA-Z_]\w*[!?=]?\z/
    CALL_COMPILABLE_REGEXP = /\A[a-zA-Z_]\w*[!?]?\z/

    included do
      class_attribute :attribute_aliases, :attribute_method_matchers, instance_writer: false
      self.attribute_aliases = {}
      self.attribute_method_matchers = [ClassMethods::AttributeMethodMatcher.new]
    end

    module ClassMethods
      # Declares a method available for all attributes with the given prefix.
      # Uses +method_missing+ and <tt>respond_to?</tt> to rewrite the method.
      #
      #   #{prefix}#{attr}(*args, &block)
      #
      # to
      #
      #   #{prefix}attribute(#{attr}, *args, &block)
      #
      # An instance method <tt>#{prefix}attribute</tt> must exist and accept
      # at least the +attr+ argument.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_prefix 'clear_'
      #     define_attribute_methods :name
      #
      #     private
      #
      #     def clear_attribute(attr)
      #       send("#{attr}=", nil)
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name          # => "Bob"
      #   person.clear_name
      #   person.name          # => nil
      def attribute_method_prefix(*prefixes)
        self.attribute_method_matchers += prefixes.map! { |prefix| AttributeMethodMatcher.new prefix: prefix }
        undefine_attribute_methods
      end

      # Declares a method available for all attributes with the given suffix.
      # Uses +method_missing+ and <tt>respond_to?</tt> to rewrite the method.
      #
      #   #{attr}#{suffix}(*args, &block)
      #
      # to
      #
      #   attribute#{suffix}(#{attr}, *args, &block)
      #
      # An <tt>attribute#{suffix}</tt> instance method must exist and accept at
      # least the +attr+ argument.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name          # => "Bob"
      #   person.name_short?   # => true
      def attribute_method_suffix(*suffixes)
        self.attribute_method_matchers += suffixes.map! { |suffix| AttributeMethodMatcher.new suffix: suffix }
        undefine_attribute_methods
      end

      # Declares a method available for all attributes with the given prefix
      # and suffix. Uses +method_missing+ and <tt>respond_to?</tt> to rewrite
      # the method.
      #
      #   #{prefix}#{attr}#{suffix}(*args, &block)
      #
      # to
      #
      #   #{prefix}attribute#{suffix}(#{attr}, *args, &block)
      #
      # An <tt>#{prefix}attribute#{suffix}</tt> instance method must exist and
      # accept at least the +attr+ argument.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_affix prefix: 'reset_', suffix: '_to_default!'
      #     define_attribute_methods :name
      #
      #     private
      #
      #     def reset_attribute_to_default!(attr)
      #       send("#{attr}=", 'Default Name')
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name                         # => 'Gem'
      #   person.reset_name_to_default!
      #   person.name                         # => 'Default Name'
      def attribute_method_affix(*affixes)
        self.attribute_method_matchers += affixes.map! { |affix| AttributeMethodMatcher.new prefix: affix[:prefix], suffix: affix[:suffix] }
        undefine_attribute_methods
      end

      # Allows you to make aliases for attributes.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name
      #
      #     alias_attribute :nickname, :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name            # => "Bob"
      #   person.nickname        # => "Bob"
      #   person.name_short?     # => true
      #   person.nickname_short? # => true
      def alias_attribute(new_name, old_name)
        self.attribute_aliases = attribute_aliases.merge(new_name.to_s => old_name.to_s)
        attribute_method_matchers.each do |matcher|
          matcher_new = matcher.method_name(new_name).to_s
          matcher_old = matcher.method_name(old_name).to_s
          define_proxy_call false, self, matcher_new, matcher_old
        end
      end

      # Is +new_name+ an alias?
      def attribute_alias?(new_name)
        attribute_aliases.key? new_name.to_s
      end

      # Returns the original name for the alias +name+
      def attribute_alias(name)
        attribute_aliases[name.to_s]
      end

      # Declares the attributes that should be prefixed and suffixed by
      # <tt>ActiveModel::AttributeMethods</tt>.
      #
      # To use, pass attribute names (as strings or symbols). Be sure to declare
      # +define_attribute_methods+ after you define any prefix, suffix or affix
      # methods, or they will not hook in.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name, :age, :address
      #     attribute_method_prefix 'clear_'
      #
      #     # Call to define_attribute_methods must appear after the
      #     # attribute_method_prefix, attribute_method_suffix or
      #     # attribute_method_affix declarations.
      #     define_attribute_methods :name, :age, :address
      #
      #     private
      #
      #     def clear_attribute(attr)
      #       send("#{attr}=", nil)
      #     end
      #   end
      def define_attribute_methods(*attr_names)
        attr_names.flatten.each { |attr_name| define_attribute_method(attr_name) }
      end

      # Declares an attribute that should be prefixed and suffixed by
      # <tt>ActiveModel::AttributeMethods</tt>.
      #
      # To use, pass an attribute name (as string or symbol). Be sure to declare
      # +define_attribute_method+ after you define any prefix, suffix or affix
      # method, or they will not hook in.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #
      #     # Call to define_attribute_method must appear after the
      #     # attribute_method_prefix, attribute_method_suffix or
      #     # attribute_method_affix declarations.
      #     define_attribute_method :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name        # => "Bob"
      #   person.name_short? # => true
      def define_attribute_method(attr_name)
        attribute_method_matchers.each do |matcher|
          method_name = matcher.method_name(attr_name)

          unless instance_method_already_implemented?(method_name)
            generate_method = "define_method_#{matcher.method_missing_target}"

            if respond_to?(generate_method, true)
              send(generate_method, attr_name)
            else
              define_proxy_call true, generated_attribute_methods, method_name, matcher.method_missing_target, attr_name.to_s
            end
          end
        end
        attribute_method_matchers_cache.clear
      end

      # Removes all the previously dynamically defined methods from the class.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_method :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name_short? # => true
      #
      #   Person.undefine_attribute_methods
      #
      #   person.name_short? # => NoMethodError
      def undefine_attribute_methods
        generated_attribute_methods.module_eval do
          instance_methods.each { |m| undef_method(m) }
        end
        attribute_method_matchers_cache.clear
      end

      def generated_attribute_methods #:nodoc:
        @generated_attribute_methods ||= Module.new {
          extend Mutex_m
        }.tap { |mod| include mod }
      end

      protected
        def instance_method_already_implemented?(method_name) #:nodoc:
          generated_attribute_methods.method_defined?(method_name)
        end

      private
        # The methods +method_missing+ and +respond_to?+ of this module are
        # invoked often in a typical rails, both of which invoke the method
        # +matched_attribute_method+. The latter method iterates through an
        # array doing regular expression matches, which results in a lot of
        # object creations. Most of the time it returns a +nil+ match. As the
        # match result is always the same given a +method_name+, this cache is
        # used to alleviate the GC, which ultimately also speeds up the app
        # significantly (in our case our test suite finishes 10% faster with
        # this cache).
        def attribute_method_matchers_cache #:nodoc:
          @attribute_method_matchers_cache ||= Concurrent::Map.new(initial_capacity: 4)
        end

        def attribute_method_matchers_matching(method_name) #:nodoc:
          attribute_method_matchers_cache.compute_if_absent(method_name) do
            # Must try to match prefixes/suffixes first, or else the matcher with no prefix/suffix
            # will match every time.
            matchers = attribute_method_matchers.partition(&:plain?).reverse.flatten(1)
            matchers.map { |method| method.match(method_name) }.compact
          end
        end

        # Define a method `name` in `mod` that dispatches to `send`
        # using the given `extra` args. This falls back on `define_method`
        # and `send` if the given names cannot be compiled.
        def define_proxy_call(include_private, mod, name, send, *extra) #:nodoc:
          defn = if NAME_COMPILABLE_REGEXP.match?(name)
            "def #{name}(*args)"
          else
            "define_method(:'#{name}') do |*args|"
          end

          extra = (extra.map!(&:inspect) << "*args").join(", ".freeze)

          target = if CALL_COMPILABLE_REGEXP.match?(send)
            "#{"self." unless include_private}#{send}(#{extra})"
          else
            "send(:'#{send}', #{extra})"
          end

          mod.module_eval <<-RUBY, __FILE__, __LINE__ + 1
            #{defn}
              #{target}
            end
          RUBY
        end

        class AttributeMethodMatcher #:nodoc:
          attr_reader :prefix, :suffix, :method_missing_target

          AttributeMethodMatch = Struct.new(:target, :attr_name, :method_name)

          def initialize(options = {})
            @prefix, @suffix = options.fetch(:prefix, ""), options.fetch(:suffix, "")
            @regex = /^(?:#{Regexp.escape(@prefix)})(.*)(?:#{Regexp.escape(@suffix)})$/
            @method_missing_target = "#{@prefix}attribute#{@suffix}"
            @method_name = "#{prefix}%s#{suffix}"
          end

          def match(method_name)
            if @regex =~ method_name
              AttributeMethodMatch.new(method_missing_target, $1, method_name)
            end
          end

          def method_name(attr_name)
            @method_name % attr_name
          end

          def plain?
            prefix.empty? && suffix.empty?
          end
        end
    end

    # Allows access to the object attributes, which are held in the hash
    # returned by <tt>attributes</tt>, as though they were first-class
    # methods. So a +Person+ class with a +name+ attribute can for example use
    # <tt>Person#name</tt> and <tt>Person#name=</tt> and never directly use
    # the attributes hash -- except for multiple assignments with
    # <tt>ActiveRecord::Base#attributes=</tt>.
    #
    # It's also possible to instantiate related objects, so a <tt>Client</tt>
    # class belonging to the +clients+ table with a +master_id+ foreign key
    # can instantiate master through <tt>Client#master</tt>.
    def method_missing(method, *args, &block)
      if respond_to_without_attributes?(method, true)
        super
      else
        match = matched_attribute_method(method.to_s)
        match ? attribute_missing(match, *args, &block) : super
      end
    end

    # +attribute_missing+ is like +method_missing+, but for attributes. When
    # +method_missing+ is called we check to see if there is a matching
    # attribute method. If so, we tell +attribute_missing+ to dispatch the
    # attribute. This method can be overloaded to customize the behavior.
    def attribute_missing(match, *args, &block)
      __send__(match.target, match.attr_name, *args, &block)
    end

    # A +Person+ instance with a +name+ attribute can ask
    # <tt>person.respond_to?(:name)</tt>, <tt>person.respond_to?(:name=)</tt>,
    # and <tt>person.respond_to?(:name?)</tt> which will all return +true+.
    alias :respond_to_without_attributes? :respond_to?
    def respond_to?(method, include_private_methods = false)
      if super
        true
      elsif !include_private_methods && super(method, true)
        # If we're here then we haven't found among non-private methods
        # but found among all methods. Which means that the given method is private.
        false
      else
        !matched_attribute_method(method.to_s).nil?
      end
    end

    protected
      def attribute_method?(attr_name) #:nodoc:
        respond_to_without_attributes?(:attributes) && attributes.include?(attr_name)
      end

    private
      # Returns a struct representing the matching attribute method.
      # The struct's attributes are prefix, base and suffix.
      def matched_attribute_method(method_name)
        matches = self.class.send(:attribute_method_matchers_matching, method_name)
        matches.detect { |match| attribute_method?(match.attr_name) }
      end

      def missing_attribute(attr_name, stack)
        raise ActiveModel::MissingAttributeError, "missing attribute: #{attr_name}", stack
      end
  end
end
require "cases/helper"

class ModelWithAttributes
  include ActiveModel::AttributeMethods

  class << self
    define_method(:bar) do
      "original bar"
    end
  end

  def attributes
    { foo: "value of foo", baz: "value of baz" }
  end

private
  def attribute(name)
    attributes[name.to_sym]
  end
end

class ModelWithAttributes2
  include ActiveModel::AttributeMethods

  attr_accessor :attributes

  attribute_method_suffix "_test"

private
  def attribute(name)
    attributes[name.to_s]
  end

  alias attribute_test attribute

  def private_method
    "<3 <3"
  end

protected

  def protected_method
    "O_o O_o"
  end
end

class ModelWithAttributesWithSpaces
  include ActiveModel::AttributeMethods

  def attributes
    { 'foo bar': "value of foo bar"}
  end

private
  def attribute(name)
    attributes[name.to_sym]
  end
end

class ModelWithWeirdNamesAttributes
  include ActiveModel::AttributeMethods

  class << self
    define_method(:'c?d') do
      "original c?d"
    end
  end

  def attributes
    { 'a?b': "value of a?b" }
  end

private
  def attribute(name)
    attributes[name.to_sym]
  end
end

class ModelWithRubyKeywordNamedAttributes
  include ActiveModel::AttributeMethods

  def attributes
    { begin: "value of begin", end: "value of end" }
  end

private
  def attribute(name)
    attributes[name.to_sym]
  end
end

class ModelWithoutAttributesMethod
  include ActiveModel::AttributeMethods
end

class AttributeMethodsTest < ActiveModel::TestCase
  test "method missing works correctly even if attributes method is not defined" do
    assert_raises(NoMethodError) { ModelWithoutAttributesMethod.new.foo }
  end

  test "unrelated classes should not share attribute method matchers" do
    assert_not_equal ModelWithAttributes.send(:attribute_method_matchers),
                     ModelWithAttributes2.send(:attribute_method_matchers)
  end

  test "#define_attribute_method generates attribute method" do
    begin
      ModelWithAttributes.define_attribute_method(:foo)

      assert_respond_to ModelWithAttributes.new, :foo
      assert_equal "value of foo", ModelWithAttributes.new.foo
    ensure
      ModelWithAttributes.undefine_attribute_methods
    end
  end

  test "#define_attribute_method does not generate attribute method if already defined in attribute module" do
    klass = Class.new(ModelWithAttributes)
    klass.generated_attribute_methods.module_eval do
      def foo
        "<3"
      end
    end
    klass.define_attribute_method(:foo)

    assert_equal "<3", klass.new.foo
  end

  test "#define_attribute_method generates a method that is already defined on the host" do
    klass = Class.new(ModelWithAttributes) do
      def foo
        super
      end
    end
    klass.define_attribute_method(:foo)

    assert_equal "value of foo", klass.new.foo
  end

  test "#define_attribute_method generates attribute method with invalid identifier characters" do
    begin
      ModelWithWeirdNamesAttributes.define_attribute_method(:'a?b')

      assert_respond_to ModelWithWeirdNamesAttributes.new, :'a?b'
      assert_equal "value of a?b", ModelWithWeirdNamesAttributes.new.send("a?b")
    ensure
      ModelWithWeirdNamesAttributes.undefine_attribute_methods
    end
  end

  test "#define_attribute_methods works passing multiple arguments" do
    begin
      ModelWithAttributes.define_attribute_methods(:foo, :baz)

      assert_equal "value of foo", ModelWithAttributes.new.foo
      assert_equal "value of baz", ModelWithAttributes.new.baz
    ensure
      ModelWithAttributes.undefine_attribute_methods
    end
  end

  test "#define_attribute_methods generates attribute methods" do
    begin
      ModelWithAttributes.define_attribute_methods(:foo)

      assert_respond_to ModelWithAttributes.new, :foo
      assert_equal "value of foo", ModelWithAttributes.new.foo
    ensure
      ModelWithAttributes.undefine_attribute_methods
    end
  end

  test "#alias_attribute generates attribute_aliases lookup hash" do
    klass = Class.new(ModelWithAttributes) do
      define_attribute_methods :foo
      alias_attribute :bar, :foo
    end

    assert_equal({ "bar" => "foo" }, klass.attribute_aliases)
  end

  test "#define_attribute_methods generates attribute methods with spaces in their names" do
    begin
      ModelWithAttributesWithSpaces.define_attribute_methods(:'foo bar')

      assert_respond_to ModelWithAttributesWithSpaces.new, :'foo bar'
      assert_equal "value of foo bar", ModelWithAttributesWithSpaces.new.send(:'foo bar')
    ensure
      ModelWithAttributesWithSpaces.undefine_attribute_methods
    end
  end

  test "#alias_attribute works with attributes with spaces in their names" do
    begin
      ModelWithAttributesWithSpaces.define_attribute_methods(:'foo bar')
      ModelWithAttributesWithSpaces.alias_attribute(:'foo_bar', :'foo bar')

      assert_equal "value of foo bar", ModelWithAttributesWithSpaces.new.foo_bar
    ensure
      ModelWithAttributesWithSpaces.undefine_attribute_methods
    end
  end

  test "#alias_attribute works with attributes named as a ruby keyword" do
    begin
      ModelWithRubyKeywordNamedAttributes.define_attribute_methods([:begin, :end])
      ModelWithRubyKeywordNamedAttributes.alias_attribute(:from, :begin)
      ModelWithRubyKeywordNamedAttributes.alias_attribute(:to, :end)

      assert_equal "value of begin", ModelWithRubyKeywordNamedAttributes.new.from
      assert_equal "value of end", ModelWithRubyKeywordNamedAttributes.new.to
    ensure
      ModelWithRubyKeywordNamedAttributes.undefine_attribute_methods
    end
  end

  test "#undefine_attribute_methods removes attribute methods" do
    ModelWithAttributes.define_attribute_methods(:foo)
    ModelWithAttributes.undefine_attribute_methods

    assert !ModelWithAttributes.new.respond_to?(:foo)
    assert_raises(NoMethodError) { ModelWithAttributes.new.foo }
  end

  test "accessing a suffixed attribute" do
    m = ModelWithAttributes2.new
    m.attributes = { "foo" => "bar" }

    assert_equal "bar", m.foo
    assert_equal "bar", m.foo_test
  end

  test "should not interfere with method_missing if the attr has a private/protected method" do
    m = ModelWithAttributes2.new
    m.attributes = { "private_method" => "<3", "protected_method" => "O_o" }

    # dispatches to the *method*, not the attribute
    assert_equal "<3 <3",   m.send(:private_method)
    assert_equal "O_o O_o", m.send(:protected_method)

    # sees that a method is already defined, so doesn't intervene
    assert_raises(NoMethodError) { m.private_method }
    assert_raises(NoMethodError) { m.protected_method }
  end

  class ClassWithProtected
    protected
      def protected_method
      end
  end

  test "should not interfere with respond_to? if the attribute has a private/protected method" do
    m = ModelWithAttributes2.new
    m.attributes = { "private_method" => "<3", "protected_method" => "O_o" }

    assert !m.respond_to?(:private_method)
    assert m.respond_to?(:private_method, true)

    c = ClassWithProtected.new

    # This is messed up, but it's how Ruby works at the moment. Apparently it will be changed
    # in the future.
    assert_equal c.respond_to?(:protected_method), m.respond_to?(:protected_method)
    assert m.respond_to?(:protected_method, true)
  end

  test "should use attribute_missing to dispatch a missing attribute" do
    m = ModelWithAttributes2.new
    m.attributes = { "foo" => "bar" }

    def m.attribute_missing(match, *args, &block)
      match
    end

    match = m.foo_test

    assert_equal "foo",            match.attr_name
    assert_equal "attribute_test", match.target
    assert_equal "foo_test",       match.method_name
  end
end
module ActiveRecord
  class AttributeMutationTracker # :nodoc:
    def initialize(attributes)
      @attributes = attributes
    end

    def changed_values
      attr_names.each_with_object({}.with_indifferent_access) do |attr_name, result|
        if changed?(attr_name)
          result[attr_name] = attributes[attr_name].original_value
        end
      end
    end

    def changes
      attr_names.each_with_object({}.with_indifferent_access) do |attr_name, result|
        if changed?(attr_name)
          result[attr_name] = [attributes[attr_name].original_value, attributes.fetch_value(attr_name)]
        end
      end
    end

    def changed?(attr_name)
      attr_name = attr_name.to_s
      attributes[attr_name].changed?
    end

    def changed_in_place?(attr_name)
      attributes[attr_name].changed_in_place?
    end

    def forget_change(attr_name)
      attr_name = attr_name.to_s
      attributes[attr_name] = attributes[attr_name].forgetting_assignment
    end

    protected

      attr_reader :attributes

    private

      def attr_names
        attributes.keys
      end
  end

  class NullMutationTracker # :nodoc:
    include Singleton

    def changed_values
      {}
    end

    def changes
      {}
    end

    def changed?(*)
      false
    end

    def changed_in_place?(*)
      false
    end

    def forget_change(*)
    end
  end
end
require "active_support/core_ext/kernel/singleton_class"
require "active_support/core_ext/module/remove_method"
require "active_support/core_ext/array/extract_options"

class Class
  # Declare a class-level attribute whose value is inheritable by subclasses.
  # Subclasses can change their own value and it will not impact parent class.
  #
  #   class Base
  #     class_attribute :setting
  #   end
  #
  #   class Subclass < Base
  #   end
  #
  #   Base.setting = true
  #   Subclass.setting            # => true
  #   Subclass.setting = false
  #   Subclass.setting            # => false
  #   Base.setting                # => true
  #
  # In the above case as long as Subclass does not assign a value to setting
  # by performing <tt>Subclass.setting = _something_ </tt>, <tt>Subclass.setting</tt>
  # would read value assigned to parent class. Once Subclass assigns a value then
  # the value assigned by Subclass would be returned.
  #
  # This matches normal Ruby method inheritance: think of writing an attribute
  # on a subclass as overriding the reader method. However, you need to be aware
  # when using +class_attribute+ with mutable structures as +Array+ or +Hash+.
  # In such cases, you don't want to do changes in place. Instead use setters:
  #
  #   Base.setting = []
  #   Base.setting                # => []
  #   Subclass.setting            # => []
  #
  #   # Appending in child changes both parent and child because it is the same object:
  #   Subclass.setting << :foo
  #   Base.setting               # => [:foo]
  #   Subclass.setting           # => [:foo]
  #
  #   # Use setters to not propagate changes:
  #   Base.setting = []
  #   Subclass.setting += [:foo]
  #   Base.setting               # => []
  #   Subclass.setting           # => [:foo]
  #
  # For convenience, an instance predicate method is defined as well.
  # To skip it, pass <tt>instance_predicate: false</tt>.
  #
  #   Subclass.setting?       # => false
  #
  # Instances may overwrite the class value in the same way:
  #
  #   Base.setting = true
  #   object = Base.new
  #   object.setting          # => true
  #   object.setting = false
  #   object.setting          # => false
  #   Base.setting            # => true
  #
  # To opt out of the instance reader method, pass <tt>instance_reader: false</tt>.
  #
  #   object.setting          # => NoMethodError
  #   object.setting?         # => NoMethodError
  #
  # To opt out of the instance writer method, pass <tt>instance_writer: false</tt>.
  #
  #   object.setting = false  # => NoMethodError
  #
  # To opt out of both instance methods, pass <tt>instance_accessor: false</tt>.
  def class_attribute(*attrs)
    options = attrs.extract_options!
    instance_reader = options.fetch(:instance_accessor, true) && options.fetch(:instance_reader, true)
    instance_writer = options.fetch(:instance_accessor, true) && options.fetch(:instance_writer, true)
    instance_predicate = options.fetch(:instance_predicate, true)

    attrs.each do |name|
      remove_possible_singleton_method(name)
      define_singleton_method(name) { nil }

      remove_possible_singleton_method("#{name}?")
      define_singleton_method("#{name}?") { !!public_send(name) } if instance_predicate

      ivar = "@#{name}"

      remove_possible_singleton_method("#{name}=")
      define_singleton_method("#{name}=") do |val|
        singleton_class.class_eval do
          remove_possible_method(name)
          define_method(name) { val }
        end

        if singleton_class?
          class_eval do
            remove_possible_method(name)
            define_method(name) do
              if instance_variable_defined? ivar
                instance_variable_get ivar
              else
                singleton_class.send name
              end
            end
          end
        end
        val
      end

      if instance_reader
        remove_possible_method name
        define_method(name) do
          if instance_variable_defined?(ivar)
            instance_variable_get ivar
          else
            self.class.public_send name
          end
        end

        remove_possible_method "#{name}?"
        define_method("#{name}?") { !!public_send(name) } if instance_predicate
      end

      if instance_writer
        remove_possible_method "#{name}="
        attr_writer name
      end
    end
  end
end
require "active_record/attribute_set/builder"
require "active_record/attribute_set/yaml_encoder"

module ActiveRecord
  class AttributeSet # :nodoc:
    delegate :each_value, :fetch, to: :attributes

    def initialize(attributes)
      @attributes = attributes
    end

    def [](name)
      attributes[name] || Attribute.null(name)
    end

    def []=(name, value)
      attributes[name] = value
    end

    def values_before_type_cast
      attributes.transform_values(&:value_before_type_cast)
    end

    def to_hash
      initialized_attributes.transform_values(&:value)
    end
    alias_method :to_h, :to_hash

    def key?(name)
      attributes.key?(name) && self[name].initialized?
    end

    def keys
      attributes.each_key.select { |name| self[name].initialized? }
    end

    if defined?(JRUBY_VERSION)
      # This form is significantly faster on JRuby, and this is one of our biggest hotspots.
      # https://github.com/jruby/jruby/pull/2562
      def fetch_value(name, &block)
        self[name].value(&block)
      end
    else
      def fetch_value(name)
        self[name].value { |n| yield n if block_given? }
      end
    end

    def write_from_database(name, value)
      attributes[name] = self[name].with_value_from_database(value)
    end

    def write_from_user(name, value)
      attributes[name] = self[name].with_value_from_user(value)
    end

    def write_cast_value(name, value)
      attributes[name] = self[name].with_cast_value(value)
    end

    def freeze
      @attributes.freeze
      super
    end

    def deep_dup
      dup.tap do |copy|
        copy.instance_variable_set(:@attributes, attributes.deep_dup)
      end
    end

    def initialize_dup(_)
      @attributes = attributes.dup
      super
    end

    def initialize_clone(_)
      @attributes = attributes.clone
      super
    end

    def reset(key)
      if key?(key)
        write_from_database(key, nil)
      end
    end

    def accessed
      attributes.select { |_, attr| attr.has_been_read? }.keys
    end

    def map(&block)
      new_attributes = attributes.transform_values(&block)
      AttributeSet.new(new_attributes)
    end

    def ==(other)
      attributes == other.attributes
    end

    protected

      attr_reader :attributes

    private

      def initialized_attributes
        attributes.select { |_, attr| attr.initialized? }
      end
  end
end
require "cases/helper"

module ActiveRecord
  class AttributeSetTest < ActiveRecord::TestCase
    test "building a new set from raw attributes" do
      builder = AttributeSet::Builder.new(foo: Type::Integer.new, bar: Type::Float.new)
      attributes = builder.build_from_database(foo: "1.1", bar: "2.2")

      assert_equal 1, attributes[:foo].value
      assert_equal 2.2, attributes[:bar].value
      assert_equal :foo, attributes[:foo].name
      assert_equal :bar, attributes[:bar].name
    end

    test "building with custom types" do
      builder = AttributeSet::Builder.new(foo: Type::Float.new)
      attributes = builder.build_from_database({ foo: "3.3", bar: "4.4" }, bar: Type::Integer.new)

      assert_equal 3.3, attributes[:foo].value
      assert_equal 4, attributes[:bar].value
    end

    test "[] returns a null object" do
      builder = AttributeSet::Builder.new(foo: Type::Float.new)
      attributes = builder.build_from_database(foo: "3.3")

      assert_equal "3.3", attributes[:foo].value_before_type_cast
      assert_equal nil, attributes[:bar].value_before_type_cast
      assert_equal :bar, attributes[:bar].name
    end

    test "duping creates a new hash, but does not dup the attributes" do
      builder = AttributeSet::Builder.new(foo: Type::Integer.new, bar: Type::String.new)
      attributes = builder.build_from_database(foo: 1, bar: "foo")

      # Ensure the type cast value is cached
      attributes[:foo].value
      attributes[:bar].value

      duped = attributes.dup
      duped.write_from_database(:foo, 2)
      duped[:bar].value << "bar"

      assert_equal 1, attributes[:foo].value
      assert_equal 2, duped[:foo].value
      assert_equal "foobar", attributes[:bar].value
      assert_equal "foobar", duped[:bar].value
    end

    test "deep_duping creates a new hash and dups each attribute" do
      builder = AttributeSet::Builder.new(foo: Type::Integer.new, bar: Type::String.new)
      attributes = builder.build_from_database(foo: 1, bar: "foo")

      # Ensure the type cast value is cached
      attributes[:foo].value
      attributes[:bar].value

      duped = attributes.deep_dup
      duped.write_from_database(:foo, 2)
      duped[:bar].value << "bar"

      assert_equal 1, attributes[:foo].value
      assert_equal 2, duped[:foo].value
      assert_equal "foo", attributes[:bar].value
      assert_equal "foobar", duped[:bar].value
    end

    test "freezing cloned set does not freeze original" do
      attributes = AttributeSet.new({})
      clone = attributes.clone

      clone.freeze

      assert clone.frozen?
      assert_not attributes.frozen?
    end

    test "to_hash returns a hash of the type cast values" do
      builder = AttributeSet::Builder.new(foo: Type::Integer.new, bar: Type::Float.new)
      attributes = builder.build_from_database(foo: "1.1", bar: "2.2")

      assert_equal({ foo: 1, bar: 2.2 }, attributes.to_hash)
      assert_equal({ foo: 1, bar: 2.2 }, attributes.to_h)
    end

    test "to_hash maintains order" do
      builder = AttributeSet::Builder.new(foo: Type::Integer.new, bar: Type::Float.new)
      attributes = builder.build_from_database(foo: "2.2", bar: "3.3")

      attributes[:bar]
      hash = attributes.to_h

      assert_equal [[:foo, 2], [:bar, 3.3]], hash.to_a
    end

    test "values_before_type_cast" do
      builder = AttributeSet::Builder.new(foo: Type::Integer.new, bar: Type::Integer.new)
      attributes = builder.build_from_database(foo: "1.1", bar: "2.2")

      assert_equal({ foo: "1.1", bar: "2.2" }, attributes.values_before_type_cast)
    end

    test "known columns are built with uninitialized attributes" do
      attributes = attributes_with_uninitialized_key
      assert attributes[:foo].initialized?
      assert_not attributes[:bar].initialized?
    end

    test "uninitialized attributes are not included in the attributes hash" do
      attributes = attributes_with_uninitialized_key
      assert_equal({ foo: 1 }, attributes.to_hash)
    end

    test "uninitialized attributes are not included in keys" do
      attributes = attributes_with_uninitialized_key
      assert_equal [:foo], attributes.keys
    end

    test "uninitialized attributes return false for key?" do
      attributes = attributes_with_uninitialized_key
      assert attributes.key?(:foo)
      assert_not attributes.key?(:bar)
    end

    test "unknown attributes return false for key?" do
      attributes = attributes_with_uninitialized_key
      assert_not attributes.key?(:wibble)
    end

    test "fetch_value returns the value for the given initialized attribute" do
      builder = AttributeSet::Builder.new(foo: Type::Integer.new, bar: Type::Float.new)
      attributes = builder.build_from_database(foo: "1.1", bar: "2.2")

      assert_equal 1, attributes.fetch_value(:foo)
      assert_equal 2.2, attributes.fetch_value(:bar)
    end

    test "fetch_value returns nil for unknown attributes" do
      attributes = attributes_with_uninitialized_key
      assert_nil attributes.fetch_value(:wibble) { "hello" }
    end

    test "fetch_value returns nil for unknown attributes when types has a default" do
      types = Hash.new(Type::Value.new)
      builder = AttributeSet::Builder.new(types)
      attributes = builder.build_from_database

      assert_nil attributes.fetch_value(:wibble) { "hello" }
    end

    test "fetch_value uses the given block for uninitialized attributes" do
      attributes = attributes_with_uninitialized_key
      value = attributes.fetch_value(:bar) { |n| n.to_s + "!" }
      assert_equal "bar!", value
    end

    test "fetch_value returns nil for uninitialized attributes if no block is given" do
      attributes = attributes_with_uninitialized_key
      assert_nil attributes.fetch_value(:bar)
    end

    test "the primary_key is always initialized" do
      builder = AttributeSet::Builder.new({ foo: Type::Integer.new }, :foo)
      attributes = builder.build_from_database

      assert attributes.key?(:foo)
      assert_equal [:foo], attributes.keys
      assert attributes[:foo].initialized?
    end

    class MyType
      def cast(value)
        return if value.nil?
        value + " from user"
      end

      def deserialize(value)
        return if value.nil?
        value + " from database"
      end

      def assert_valid_value(*)
      end
    end

    test "write_from_database sets the attribute with database typecasting" do
      builder = AttributeSet::Builder.new(foo: MyType.new)
      attributes = builder.build_from_database

      assert_nil attributes.fetch_value(:foo)

      attributes.write_from_database(:foo, "value")

      assert_equal "value from database", attributes.fetch_value(:foo)
    end

    test "write_from_user sets the attribute with user typecasting" do
      builder = AttributeSet::Builder.new(foo: MyType.new)
      attributes = builder.build_from_database

      assert_nil attributes.fetch_value(:foo)

      attributes.write_from_user(:foo, "value")

      assert_equal "value from user", attributes.fetch_value(:foo)
    end

    def attributes_with_uninitialized_key
      builder = AttributeSet::Builder.new(foo: Type::Integer.new, bar: Type::Float.new)
      builder.build_from_database(foo: "1.1")
    end

    test "freezing doesn't prevent the set from materializing" do
      builder = AttributeSet::Builder.new(foo: Type::String.new)
      attributes = builder.build_from_database(foo: "1")

      attributes.freeze
      assert_equal({ foo: "1" }, attributes.to_hash)
    end

    test "#accessed_attributes returns only attributes which have been read" do
      builder = AttributeSet::Builder.new(foo: Type::Value.new, bar: Type::Value.new)
      attributes = builder.build_from_database(foo: "1", bar: "2")

      assert_equal [], attributes.accessed

      attributes.fetch_value(:foo)

      assert_equal [:foo], attributes.accessed
    end

    test "#map returns a new attribute set with the changes applied" do
      builder = AttributeSet::Builder.new(foo: Type::Integer.new, bar: Type::Integer.new)
      attributes = builder.build_from_database(foo: "1", bar: "2")
      new_attributes = attributes.map do |attr|
        attr.with_cast_value(attr.value + 1)
      end

      assert_equal 2, new_attributes.fetch_value(:foo)
      assert_equal 3, new_attributes.fetch_value(:bar)
    end

    test "comparison for equality is correctly implemented" do
      builder = AttributeSet::Builder.new(foo: Type::Integer.new, bar: Type::Integer.new)
      attributes = builder.build_from_database(foo: "1", bar: "2")
      attributes2 = builder.build_from_database(foo: "1", bar: "2")
      attributes3 = builder.build_from_database(foo: "2", bar: "2")

      assert_equal attributes, attributes2
      assert_not_equal attributes2, attributes3
    end
  end
end
require "active_record/attribute/user_provided_default"

module ActiveRecord
  # See ActiveRecord::Attributes::ClassMethods for documentation
  module Attributes
    extend ActiveSupport::Concern

    included do
      class_attribute :attributes_to_define_after_schema_loads, instance_accessor: false # :internal:
      self.attributes_to_define_after_schema_loads = {}
    end

    module ClassMethods
      # Defines an attribute with a type on this model. It will override the
      # type of existing attributes if needed. This allows control over how
      # values are converted to and from SQL when assigned to a model. It also
      # changes the behavior of values passed to
      # {ActiveRecord::Base.where}[rdoc-ref:QueryMethods#where]. This will let you use
      # your domain objects across much of Active Record, without having to
      # rely on implementation details or monkey patching.
      #
      # +name+ The name of the methods to define attribute methods for, and the
      # column which this will persist to.
      #
      # +cast_type+ A symbol such as +:string+ or +:integer+, or a type object
      # to be used for this attribute. See the examples below for more
      # information about providing custom type objects.
      #
      # ==== Options
      #
      # The following options are accepted:
      #
      # +default+ The default value to use when no value is provided. If this option
      # is not passed, the previous default value (if any) will be used.
      # Otherwise, the default will be +nil+.
      #
      # +array+ (PostgreSQL only) specifies that the type should be an array (see the
      # examples below).
      #
      # +range+ (PostgreSQL only) specifies that the type should be a range (see the
      # examples below).
      #
      # ==== Examples
      #
      # The type detected by Active Record can be overridden.
      #
      #   # db/schema.rb
      #   create_table :store_listings, force: true do |t|
      #     t.decimal :price_in_cents
      #   end
      #
      #   # app/models/store_listing.rb
      #   class StoreListing < ActiveRecord::Base
      #   end
      #
      #   store_listing = StoreListing.new(price_in_cents: '10.1')
      #
      #   # before
      #   store_listing.price_in_cents # => BigDecimal.new(10.1)
      #
      #   class StoreListing < ActiveRecord::Base
      #     attribute :price_in_cents, :integer
      #   end
      #
      #   # after
      #   store_listing.price_in_cents # => 10
      #
      # A default can also be provided.
      #
      #   # db/schema.rb
      #   create_table :store_listings, force: true do |t|
      #     t.string :my_string, default: "original default"
      #   end
      #
      #   StoreListing.new.my_string # => "original default"
      #
      #   # app/models/store_listing.rb
      #   class StoreListing < ActiveRecord::Base
      #     attribute :my_string, :string, default: "new default"
      #   end
      #
      #   StoreListing.new.my_string # => "new default"
      #
      #   class Product < ActiveRecord::Base
      #     attribute :my_default_proc, :datetime, default: -> { Time.now }
      #   end
      #
      #   Product.new.my_default_proc # => 2015-05-30 11:04:48 -0600
      #   sleep 1
      #   Product.new.my_default_proc # => 2015-05-30 11:04:49 -0600
      #
      # \Attributes do not need to be backed by a database column.
      #
      #   # app/models/my_model.rb
      #   class MyModel < ActiveRecord::Base
      #     attribute :my_string, :string
      #     attribute :my_int_array, :integer, array: true
      #     attribute :my_float_range, :float, range: true
      #   end
      #
      #   model = MyModel.new(
      #     my_string: "string",
      #     my_int_array: ["1", "2", "3"],
      #     my_float_range: "[1,3.5]",
      #   )
      #   model.attributes
      #   # =>
      #     {
      #       my_string: "string",
      #       my_int_array: [1, 2, 3],
      #       my_float_range: 1.0..3.5
      #     }
      #
      # ==== Creating Custom Types
      #
      # Users may also define their own custom types, as long as they respond
      # to the methods defined on the value type. The method +deserialize+ or
      # +cast+ will be called on your type object, with raw input from the
      # database or from your controllers. See ActiveRecord::Type::Value for the
      # expected API. It is recommended that your type objects inherit from an
      # existing type, or from ActiveRecord::Type::Value
      #
      #   class MoneyType < ActiveRecord::Type::Integer
      #     def cast(value)
      #       if !value.kind_of?(Numeric) && value.include?('$')
      #         price_in_dollars = value.gsub(/\$/, '').to_f
      #         super(price_in_dollars * 100)
      #       else
      #         super
      #       end
      #     end
      #   end
      #
      #   # config/initializers/types.rb
      #   ActiveRecord::Type.register(:money, MoneyType)
      #
      #   # app/models/store_listing.rb
      #   class StoreListing < ActiveRecord::Base
      #     attribute :price_in_cents, :money
      #   end
      #
      #   store_listing = StoreListing.new(price_in_cents: '$10.00')
      #   store_listing.price_in_cents # => 1000
      #
      # For more details on creating custom types, see the documentation for
      # ActiveRecord::Type::Value. For more details on registering your types
      # to be referenced by a symbol, see ActiveRecord::Type.register. You can
      # also pass a type object directly, in place of a symbol.
      #
      # ==== \Querying
      #
      # When {ActiveRecord::Base.where}[rdoc-ref:QueryMethods#where] is called, it will
      # use the type defined by the model class to convert the value to SQL,
      # calling +serialize+ on your type object. For example:
      #
      #   class Money < Struct.new(:amount, :currency)
      #   end
      #
      #   class MoneyType < Type::Value
      #     def initialize(currency_converter:)
      #       @currency_converter = currency_converter
      #     end
      #
      #     # value will be the result of +deserialize+ or
      #     # +cast+. Assumed to be an instance of +Money+ in
      #     # this case.
      #     def serialize(value)
      #       value_in_bitcoins = @currency_converter.convert_to_bitcoins(value)
      #       value_in_bitcoins.amount
      #     end
      #   end
      #
      #   # config/initializers/types.rb
      #   ActiveRecord::Type.register(:money, MoneyType)
      #
      #   # app/models/product.rb
      #   class Product < ActiveRecord::Base
      #     currency_converter = ConversionRatesFromTheInternet.new
      #     attribute :price_in_bitcoins, :money, currency_converter: currency_converter
      #   end
      #
      #   Product.where(price_in_bitcoins: Money.new(5, "USD"))
      #   # => SELECT * FROM products WHERE price_in_bitcoins = 0.02230
      #
      #   Product.where(price_in_bitcoins: Money.new(5, "GBP"))
      #   # => SELECT * FROM products WHERE price_in_bitcoins = 0.03412
      #
      # ==== Dirty Tracking
      #
      # The type of an attribute is given the opportunity to change how dirty
      # tracking is performed. The methods +changed?+ and +changed_in_place?+
      # will be called from ActiveModel::Dirty. See the documentation for those
      # methods in ActiveRecord::Type::Value for more details.
      def attribute(name, cast_type, **options)
        name = name.to_s
        reload_schema_from_cache

        self.attributes_to_define_after_schema_loads =
          attributes_to_define_after_schema_loads.merge(
            name => [cast_type, options]
          )
      end

      # This is the low level API which sits beneath +attribute+. It only
      # accepts type objects, and will do its work immediately instead of
      # waiting for the schema to load. Automatic schema detection and
      # ClassMethods#attribute both call this under the hood. While this method
      # is provided so it can be used by plugin authors, application code
      # should probably use ClassMethods#attribute.
      #
      # +name+ The name of the attribute being defined. Expected to be a +String+.
      #
      # +cast_type+ The type object to use for this attribute.
      #
      # +default+ The default value to use when no value is provided. If this option
      # is not passed, the previous default value (if any) will be used.
      # Otherwise, the default will be +nil+. A proc can also be passed, and
      # will be called once each time a new value is needed.
      #
      # +user_provided_default+ Whether the default value should be cast using
      # +cast+ or +deserialize+.
      def define_attribute(
        name,
        cast_type,
        default: NO_DEFAULT_PROVIDED,
        user_provided_default: true
      )
        attribute_types[name] = cast_type
        define_default_attribute(name, default, cast_type, from_user: user_provided_default)
      end

      def load_schema! # :nodoc:
        super
        attributes_to_define_after_schema_loads.each do |name, (type, options)|
          if type.is_a?(Symbol)
            type = ActiveRecord::Type.lookup(type, **options.except(:default))
          end

          define_attribute(name, type, **options.slice(:default))
        end
      end

      private

        NO_DEFAULT_PROVIDED = Object.new # :nodoc:
        private_constant :NO_DEFAULT_PROVIDED

        def define_default_attribute(name, value, type, from_user:)
          if value == NO_DEFAULT_PROVIDED
            default_attribute = _default_attributes[name].with_type(type)
          elsif from_user
            default_attribute = Attribute::UserProvidedDefault.new(
              name,
              value,
              type,
              _default_attributes.fetch(name.to_s) { nil },
            )
          else
            default_attribute = Attribute.from_database(name, value, type)
          end
          _default_attributes[name] = default_attribute
        end
    end
  end
end
require "cases/helper"

class OverloadedType < ActiveRecord::Base
  attribute :overloaded_float, :integer
  attribute :overloaded_string_with_limit, :string, limit: 50
  attribute :non_existent_decimal, :decimal
  attribute :string_with_default, :string, default: "the overloaded default"
end

class ChildOfOverloadedType < OverloadedType
end

class GrandchildOfOverloadedType < ChildOfOverloadedType
  attribute :overloaded_float, :float
end

class UnoverloadedType < ActiveRecord::Base
  self.table_name = "overloaded_types"
end

module ActiveRecord
  class CustomPropertiesTest < ActiveRecord::TestCase
    test "overloading types" do
      data = OverloadedType.new

      data.overloaded_float = "1.1"
      data.unoverloaded_float = "1.1"

      assert_equal 1, data.overloaded_float
      assert_equal 1.1, data.unoverloaded_float
    end

    test "overloaded properties save" do
      data = OverloadedType.new

      data.overloaded_float = "2.2"
      data.save!
      data.reload

      assert_equal 2, data.overloaded_float
      assert_kind_of Integer, OverloadedType.last.overloaded_float
      assert_equal 2.0, UnoverloadedType.last.overloaded_float
      assert_kind_of Float, UnoverloadedType.last.overloaded_float
    end

    test "properties assigned in constructor" do
      data = OverloadedType.new(overloaded_float: "3.3")

      assert_equal 3, data.overloaded_float
    end

    test "overloaded properties with limit" do
      assert_equal 50, OverloadedType.type_for_attribute("overloaded_string_with_limit").limit
      assert_equal 255, UnoverloadedType.type_for_attribute("overloaded_string_with_limit").limit
    end

    test "nonexistent attribute" do
      data = OverloadedType.new(non_existent_decimal: 1)

      assert_equal BigDecimal.new(1), data.non_existent_decimal
      assert_raise ActiveRecord::UnknownAttributeError do
        UnoverloadedType.new(non_existent_decimal: 1)
      end
    end

    test "model with nonexistent attribute with default value can be saved" do
      klass = Class.new(OverloadedType) do
        attribute :non_existent_string_with_default, :string, default: "nonexistent"
      end

      model = klass.new
      assert model.save
    end

    test "changing defaults" do
      data = OverloadedType.new
      unoverloaded_data = UnoverloadedType.new

      assert_equal "the overloaded default", data.string_with_default
      assert_equal "the original default", unoverloaded_data.string_with_default
    end

    test "defaults are not touched on the columns" do
      assert_equal "the original default", OverloadedType.columns_hash["string_with_default"].default
    end

    test "children inherit custom properties" do
      data = ChildOfOverloadedType.new(overloaded_float: "4.4")

      assert_equal 4, data.overloaded_float
    end

    test "children can override parents" do
      data = GrandchildOfOverloadedType.new(overloaded_float: "4.4")

      assert_equal 4.4, data.overloaded_float
    end

    test "overloading properties does not attribute method order" do
      attribute_names = OverloadedType.attribute_names
      assert_equal %w(id overloaded_float unoverloaded_float overloaded_string_with_limit string_with_default non_existent_decimal), attribute_names
    end

    test "caches are cleared" do
      klass = Class.new(OverloadedType)

      assert_equal 6, klass.attribute_types.length
      assert_equal 6, klass.column_defaults.length
      assert_not klass.attribute_types.include?("wibble")

      klass.attribute :wibble, Type::Value.new

      assert_equal 7, klass.attribute_types.length
      assert_equal 7, klass.column_defaults.length
      assert klass.attribute_types.include?("wibble")
    end

    test "the given default value is cast from user" do
      custom_type = Class.new(Type::Value) do
        def cast(*)
          "from user"
        end

        def deserialize(*)
          "from database"
        end
      end

      klass = Class.new(OverloadedType) do
        attribute :wibble, custom_type.new, default: "default"
      end
      model = klass.new

      assert_equal "from user", model.wibble
    end

    test "procs for default values" do
      klass = Class.new(OverloadedType) do
        @@counter = 0
        attribute :counter, :integer, default: -> { @@counter += 1 }
      end

      assert_equal 1, klass.new.counter
      assert_equal 2, klass.new.counter
    end

    test "procs are memoized before type casting" do
      klass = Class.new(OverloadedType) do
        @@counter = 0
        attribute :counter, :integer, default: -> { @@counter += 1 }
      end

      model = klass.new
      assert_equal 1, model.counter_before_type_cast
      assert_equal 1, model.counter_before_type_cast
    end

    test "user provided defaults are persisted even if unchanged" do
      model = OverloadedType.create!

      assert_equal "the overloaded default", model.reload.string_with_default
    end

    if current_adapter?(:PostgreSQLAdapter)
      test "array types can be specified" do
        klass = Class.new(OverloadedType) do
          attribute :my_array, :string, limit: 50, array: true
          attribute :my_int_array, :integer, array: true
        end

        string_array = ConnectionAdapters::PostgreSQL::OID::Array.new(
          Type::String.new(limit: 50))
        int_array = ConnectionAdapters::PostgreSQL::OID::Array.new(
          Type::Integer.new)
        assert_not_equal string_array, int_array
        assert_equal string_array, klass.type_for_attribute("my_array")
        assert_equal int_array, klass.type_for_attribute("my_int_array")
      end

      test "range types can be specified" do
        klass = Class.new(OverloadedType) do
          attribute :my_range, :string, limit: 50, range: true
          attribute :my_int_range, :integer, range: true
        end

        string_range = ConnectionAdapters::PostgreSQL::OID::Range.new(
          Type::String.new(limit: 50))
        int_range = ConnectionAdapters::PostgreSQL::OID::Range.new(
          Type::Integer.new)
        assert_not_equal string_range, int_range
        assert_equal string_range, klass.type_for_attribute("my_range")
        assert_equal int_range, klass.type_for_attribute("my_int_range")
      end
    end

    test "attributes added after subclasses load are inherited" do
      parent = Class.new(ActiveRecord::Base) do
        self.table_name = "topics"
      end

      child = Class.new(parent)
      child.new # => force a schema load

      parent.attribute(:foo, Type::Value.new)

      assert_equal(:bar, child.new(foo: :bar).foo)
    end

    test "attributes not backed by database columns are not dirty when unchanged" do
      refute OverloadedType.new.non_existent_decimal_changed?
    end

    test "attributes not backed by database columns are always initialized" do
      OverloadedType.create!
      model = OverloadedType.first

      assert_nil model.non_existent_decimal
      model.non_existent_decimal = "123"
      assert_equal 123, model.non_existent_decimal
    end

    test "attributes not backed by database columns return the default on models loaded from database" do
      child = Class.new(OverloadedType) do
        attribute :non_existent_decimal, :decimal, default: 123
      end
      child.create!
      model = child.first

      assert_equal 123, model.non_existent_decimal
    end

    test "attributes not backed by database columns properly interact with mutation and dirty" do
      child = Class.new(ActiveRecord::Base) do
        self.table_name = "topics"
        attribute :foo, :string, default: "lol"
      end
      child.create!
      model = child.first

      assert_equal "lol", model.foo

      model.foo << "asdf"
      assert_equal "lolasdf", model.foo
      assert model.foo_changed?

      model.reload
      assert_equal "lol", model.foo

      model.foo = "lol"
      refute model.changed?
    end
  end
end
require "abstract_unit"
require "active_support/core_ext/class/attribute"

class ClassAttributeTest < ActiveSupport::TestCase
  def setup
    @klass = Class.new { class_attribute :setting }
    @sub = Class.new(@klass)
  end

  test "defaults to nil" do
    assert_nil @klass.setting
    assert_nil @sub.setting
  end

  test "inheritable" do
    @klass.setting = 1
    assert_equal 1, @sub.setting
  end

  test "overridable" do
    @sub.setting = 1
    assert_nil @klass.setting

    @klass.setting = 2
    assert_equal 1, @sub.setting

    assert_equal 1, Class.new(@sub).setting
  end

  test "predicate method" do
    assert_equal false, @klass.setting?
    @klass.setting = 1
    assert_equal true, @klass.setting?
  end

  test "instance reader delegates to class" do
    assert_nil @klass.new.setting

    @klass.setting = 1
    assert_equal 1, @klass.new.setting
  end

  test "instance override" do
    object = @klass.new
    object.setting = 1
    assert_nil @klass.setting
    @klass.setting = 2
    assert_equal 1, object.setting
  end

  test "instance predicate" do
    object = @klass.new
    assert_equal false, object.setting?
    object.setting = 1
    assert_equal true, object.setting?
  end

  test "disabling instance writer" do
    object = Class.new { class_attribute :setting, instance_writer: false }.new
    assert_raise(NoMethodError) { object.setting = "boom" }
  end

  test "disabling instance reader" do
    object = Class.new { class_attribute :setting, instance_reader: false }.new
    assert_raise(NoMethodError) { object.setting }
    assert_raise(NoMethodError) { object.setting? }
  end

  test "disabling both instance writer and reader" do
    object = Class.new { class_attribute :setting, instance_accessor: false }.new
    assert_raise(NoMethodError) { object.setting }
    assert_raise(NoMethodError) { object.setting? }
    assert_raise(NoMethodError) { object.setting = "boom" }
  end

  test "disabling instance predicate" do
    object = Class.new { class_attribute :setting, instance_predicate: false }.new
    assert_raise(NoMethodError) { object.setting? }
  end

  test "works well with singleton classes" do
    object = @klass.new
    object.singleton_class.setting = "foo"
    assert_equal "foo", object.setting
  end

  test "setter returns set value" do
    val = @klass.send(:setting=, 1)
    assert_equal 1, val
  end
end
class Module
  # Declares an attribute reader backed by an internally-named instance variable.
  def attr_internal_reader(*attrs)
    attrs.each {|attr_name| attr_internal_define(attr_name, :reader)}
  end

  # Declares an attribute writer backed by an internally-named instance variable.
  def attr_internal_writer(*attrs)
    attrs.each {|attr_name| attr_internal_define(attr_name, :writer)}
  end

  # Declares an attribute reader and writer backed by an internally-named instance
  # variable.
  def attr_internal_accessor(*attrs)
    attr_internal_reader(*attrs)
    attr_internal_writer(*attrs)
  end
  alias_method :attr_internal, :attr_internal_accessor

  class << self; attr_accessor :attr_internal_naming_format end
  self.attr_internal_naming_format = "@_%s"

  private
    def attr_internal_ivar_name(attr)
      Module.attr_internal_naming_format % attr
    end

    def attr_internal_define(attr_name, type)
      internal_name = attr_internal_ivar_name(attr_name).sub(/\A@/, "")
      # use native attr_* methods as they are faster on some Ruby implementations
      send("attr_#{type}", internal_name)
      attr_name, internal_name = "#{attr_name}=", "#{internal_name}=" if type == :writer
      alias_method attr_name, internal_name
      remove_method internal_name
    end
end
require "abstract_unit"
require "active_support/core_ext/module/attr_internal"

class AttrInternalTest < ActiveSupport::TestCase
  def setup
    @target = Class.new
    @instance = @target.new
  end

  def test_reader
    assert_nothing_raised { @target.attr_internal_reader :foo }

    assert !@instance.instance_variable_defined?("@_foo")
    assert_raise(NoMethodError) { @instance.foo = 1 }

    @instance.instance_variable_set("@_foo", 1)
    assert_nothing_raised { assert_equal 1, @instance.foo }
  end

  def test_writer
    assert_nothing_raised { @target.attr_internal_writer :foo }

    assert !@instance.instance_variable_defined?("@_foo")
    assert_nothing_raised { assert_equal 1, @instance.foo = 1 }

    assert_equal 1, @instance.instance_variable_get("@_foo")
    assert_raise(NoMethodError) { @instance.foo }
  end

  def test_accessor
    assert_nothing_raised { @target.attr_internal :foo }

    assert !@instance.instance_variable_defined?("@_foo")
    assert_nothing_raised { assert_equal 1, @instance.foo = 1 }

    assert_equal 1, @instance.instance_variable_get("@_foo")
    assert_nothing_raised { assert_equal 1, @instance.foo }
  end

  def test_naming_format
    assert_equal "@_%s", Module.attr_internal_naming_format
    assert_nothing_raised { Module.attr_internal_naming_format = "@abc%sdef" }
    @target.attr_internal :foo

    assert !@instance.instance_variable_defined?("@_foo")
    assert !@instance.instance_variable_defined?("@abcfoodef")
    assert_nothing_raised { @instance.foo = 1 }
    assert !@instance.instance_variable_defined?("@_foo")
    assert @instance.instance_variable_defined?("@abcfoodef")
  ensure
    Module.attr_internal_naming_format = "@_%s"
  end
end
module ActionCable
  module Connection
    module Authorization
      class UnauthorizedError < StandardError; end

      private
        def reject_unauthorized_connection
          logger.error "An unauthorized connection attempt was rejected"
          raise UnauthorizedError
        end
    end
  end
end
require "test_helper"
require "stubs/test_server"

class ActionCable::Connection::AuthorizationTest < ActionCable::TestCase
  class Connection < ActionCable::Connection::Base
    attr_reader :websocket

    def connect
      reject_unauthorized_connection
    end

    def send_async(method, *args)
      send method, *args
    end
  end

  test "unauthorized connection" do
    run_in_eventmachine do
      server = TestServer.new
      server.config.allowed_request_origins = %w( http://rubyonrails.com )

      env = Rack::MockRequest.env_for "/test", "HTTP_CONNECTION" => "upgrade", "HTTP_UPGRADE" => "websocket",
        "HTTP_HOST" => "localhost", "HTTP_ORIGIN" => "http://rubyonrails.com"

      connection = Connection.new(server, env)
      connection.websocket.expects(:close)

      connection.process
    end
  end
end
class Author < ActiveRecord::Base
  has_many :posts
  has_many :serialized_posts
  has_one :post
  has_many :very_special_comments, through: :posts
  has_many :posts_with_comments, -> { includes(:comments) }, class_name: "Post"
  has_many :popular_grouped_posts, -> { includes(:comments).group("type").having("SUM(comments_count) > 1").select("type") }, class_name: "Post"
  has_many :posts_with_comments_sorted_by_comment_id, -> { includes(:comments).order("comments.id") }, class_name: "Post"
  has_many :posts_sorted_by_id_limited, -> { order("posts.id").limit(1) }, class_name: "Post"
  has_many :posts_with_categories, -> { includes(:categories) }, class_name: "Post"
  has_many :posts_with_comments_and_categories, -> { includes(:comments, :categories).order("posts.id") }, class_name: "Post"
  has_many :posts_with_special_categorizations, class_name: "PostWithSpecialCategorization"
  has_one  :post_about_thinking, -> { where("posts.title like '%thinking%'") }, class_name: "Post"
  has_one  :post_about_thinking_with_last_comment, -> { where("posts.title like '%thinking%'").includes(:last_comment) }, class_name: "Post"
  has_many :comments, through: :posts do
    def ratings
      Rating.joins(:comment).merge(self)
    end
  end
  has_many :comments_containing_the_letter_e, through: :posts, source: :comments
  has_many :comments_with_order_and_conditions, -> { order("comments.body").where("comments.body like 'Thank%'") }, through: :posts, source: :comments
  has_many :comments_with_include, -> { includes(:post) }, through: :posts, source: :comments

  has_many :first_posts
  has_many :comments_on_first_posts, -> { order("posts.id desc, comments.id asc") }, through: :first_posts, source: :comments

  has_one :first_post
  has_one :comment_on_first_post, -> { order("posts.id desc, comments.id asc") }, through: :first_post, source: :comments

  has_many :thinking_posts, -> { where(title: "So I was thinking") }, dependent: :delete_all, class_name: "Post"
  has_many :welcome_posts, -> { where(title: "Welcome to the weblog") }, class_name: "Post"

  has_many :welcome_posts_with_one_comment,
           -> { where(title: "Welcome to the weblog").where("comments_count = ?", 1) },
           class_name: "Post"
  has_many :welcome_posts_with_comments,
           -> { where(title: "Welcome to the weblog").where(Post.arel_table[:comments_count].gt(0)) },
           class_name: "Post"

  has_many :comments_desc, -> { order("comments.id DESC") }, through: :posts, source: :comments
  has_many :funky_comments, through: :posts, source: :comments
  has_many :ordered_uniq_comments, -> { distinct.order("comments.id") }, through: :posts, source: :comments
  has_many :ordered_uniq_comments_desc, -> { distinct.order("comments.id DESC") }, through: :posts, source: :comments
  has_many :readonly_comments, -> { readonly }, through: :posts, source: :comments

  has_many :special_posts
  has_many :special_post_comments, through: :special_posts, source: :comments
  has_many :special_posts_with_default_scope, class_name: "SpecialPostWithDefaultScope"

  has_many :sti_posts, class_name: "StiPost"
  has_many :sti_post_comments, through: :sti_posts, source: :comments

  has_many :special_nonexistent_posts, -> { where("posts.body = 'nonexistent'") }, class_name: "SpecialPost"
  has_many :special_nonexistent_post_comments, -> { where("comments.post_id" => 0) }, through: :special_nonexistent_posts, source: :comments
  has_many :nonexistent_comments, through: :posts

  has_many :hello_posts, -> { where "posts.body = 'hello'" }, class_name: "Post"
  has_many :hello_post_comments, through: :hello_posts, source: :comments
  has_many :posts_with_no_comments, -> { where("comments.id" => nil).includes(:comments) }, class_name: "Post"

  has_many :hello_posts_with_hash_conditions, -> { where(body: "hello") }, class_name: "Post"
  has_many :hello_post_comments_with_hash_conditions, through: :hello_posts_with_hash_conditions, source: :comments

  has_many :other_posts,          class_name: "Post"
  has_many :posts_with_callbacks, class_name: "Post", before_add: :log_before_adding,
           after_add: :log_after_adding,
           before_remove: :log_before_removing,
           after_remove: :log_after_removing
  has_many :posts_with_proc_callbacks, class_name: "Post",
           before_add: Proc.new {|o, r| o.post_log << "before_adding#{r.id || '<new>'}"},
           after_add: Proc.new {|o, r| o.post_log << "after_adding#{r.id || '<new>'}"},
           before_remove: Proc.new {|o, r| o.post_log << "before_removing#{r.id}"},
           after_remove: Proc.new {|o, r| o.post_log << "after_removing#{r.id}"}
  has_many :posts_with_multiple_callbacks, class_name: "Post",
           before_add: [:log_before_adding, Proc.new {|o, r| o.post_log << "before_adding_proc#{r.id || '<new>'}"}],
           after_add: [:log_after_adding,  Proc.new {|o, r| o.post_log << "after_adding_proc#{r.id || '<new>'}"}]
  has_many :unchangeable_posts, class_name: "Post", before_add: :raise_exception, after_add: :log_after_adding

  has_many :categorizations
  has_many :categories, through: :categorizations
  has_many :named_categories, through: :categorizations

  has_many :special_categorizations
  has_many :special_categories, through: :special_categorizations, source: :category
  has_one  :special_category,   through: :special_categorizations, source: :category

  has_many :categories_like_general, -> { where(name: "General") }, through: :categorizations, source: :category, class_name: "Category"

  has_many :categorized_posts, through: :categorizations, source: :post
  has_many :unique_categorized_posts, -> { distinct }, through: :categorizations, source: :post

  has_many :nothings, through: :kateggorisatons, class_name: "Category"

  has_many :author_favorites
  has_many :favorite_authors, -> { order("name") }, through: :author_favorites

  has_many :taggings,        through: :posts, source: :taggings
  has_many :taggings_2,      through: :posts, source: :tagging
  has_many :tags,            through: :posts
  has_many :post_categories, through: :posts, source: :categories
  has_many :tagging_tags,    through: :taggings, source: :tag

  has_many :similar_posts, -> { distinct }, through: :tags, source: :tagged_posts
  has_many :distinct_tags, -> { select("DISTINCT tags.*").order("tags.name") }, through: :posts, source: :tags

  has_many :tags_with_primary_key, through: :posts

  has_many :books
  has_many :subscriptions,        through: :books
  has_many :subscribers, -> { order("subscribers.nick") }, through: :subscriptions
  has_many :distinct_subscribers, -> { select("DISTINCT subscribers.*").order("subscribers.nick") }, through: :subscriptions, source: :subscriber

  has_one :essay, primary_key: :name, as: :writer
  has_one :essay_category, through: :essay, source: :category
  has_one :essay_owner, through: :essay, source: :owner

  has_one :essay_2, primary_key: :name, class_name: "Essay", foreign_key: :author_id
  has_one :essay_category_2, through: :essay_2, source: :category

  has_many :essays, primary_key: :name, as: :writer
  has_many :essay_categories, through: :essays, source: :category
  has_many :essay_owners, through: :essays, source: :owner

  has_many :essays_2, primary_key: :name, class_name: "Essay", foreign_key: :author_id
  has_many :essay_categories_2, through: :essays_2, source: :category

  belongs_to :owned_essay, primary_key: :name, class_name: "Essay"
  has_one :owned_essay_category, through: :owned_essay, source: :category

  belongs_to :author_address,       dependent: :destroy
  belongs_to :author_address_extra, dependent: :delete, class_name: "AuthorAddress"

  has_many :category_post_comments, through: :categories, source: :post_comments

  has_many :misc_posts, -> { where(posts: { title: ["misc post by bob", "misc post by mary"] }) }, class_name: "Post"
  has_many :misc_post_first_blue_tags, through: :misc_posts, source: :first_blue_tags

  has_many :misc_post_first_blue_tags_2, -> { where(posts: { title: ["misc post by bob", "misc post by mary"] }) },
           through: :posts, source: :first_blue_tags_2

  has_many :posts_with_default_include, class_name: "PostWithDefaultInclude"
  has_many :comments_on_posts_with_default_include, through: :posts_with_default_include, source: :comments

  has_many :posts_with_signature, ->(record) { where("posts.title LIKE ?", "%by #{record.name.downcase}%") }, class_name: "Post"

  has_many :posts_with_extension, -> { order(:title) }, class_name: "Post" do
    def extension_method; end
  end

  has_many :posts_with_extension_and_instance, ->(record) { order(:title) }, class_name: "Post" do
    def extension_method; end
  end

  attr_accessor :post_log
  after_initialize :set_post_log

  def set_post_log
    @post_log = []
  end

  def label
    "#{id}-#{name}"
  end

  def social
    %w(twitter github)
  end

  validates_presence_of :name

  private
    def log_before_adding(object)
      @post_log << "before_adding#{object.id || '<new>'}"
    end

    def log_after_adding(object)
      @post_log << "after_adding#{object.id}"
    end

    def log_before_removing(object)
      @post_log << "before_removing#{object.id}"
    end

    def log_after_removing(object)
      @post_log << "after_removing#{object.id}"
    end

    def raise_exception(object)
      raise Exception.new("You can't add a post")
    end
end

class AuthorAddress < ActiveRecord::Base
  has_one :author

  def self.destroyed_author_address_ids
    @destroyed_author_address_ids ||= []
  end

  before_destroy do |author_address|
    AuthorAddress.destroyed_author_address_ids << author_address.id
  end
end

class AuthorFavorite < ActiveRecord::Base
  belongs_to :author
  belongs_to :favorite_author, class_name: "Author"
end
class AutoId < ActiveRecord::Base
  self.table_name = "auto_id_tests"
  self.primary_key = "auto_id"
end
require "active_support/inflector/methods"

module ActiveSupport
  # Autoload and eager load conveniences for your library.
  #
  # This module allows you to define autoloads based on
  # Rails conventions (i.e. no need to define the path
  # it is automatically guessed based on the filename)
  # and also define a set of constants that needs to be
  # eager loaded:
  #
  #   module MyLib
  #     extend ActiveSupport::Autoload
  #
  #     autoload :Model
  #
  #     eager_autoload do
  #       autoload :Cache
  #     end
  #   end
  #
  # Then your library can be eager loaded by simply calling:
  #
  #   MyLib.eager_load!
  module Autoload
    def self.extended(base) # :nodoc:
      base.class_eval do
        @_autoloads = {}
        @_under_path = nil
        @_at_path = nil
        @_eager_autoload = false
      end
    end

    def autoload(const_name, path = @_at_path)
      unless path
        full = [name, @_under_path, const_name.to_s].compact.join("::")
        path = Inflector.underscore(full)
      end

      if @_eager_autoload
        @_autoloads[const_name] = path
      end

      super const_name, path
    end

    def autoload_under(path)
      @_under_path, old_path = path, @_under_path
      yield
    ensure
      @_under_path = old_path
    end

    def autoload_at(path)
      @_at_path, old_path = path, @_at_path
      yield
    ensure
      @_at_path = old_path
    end

    def eager_autoload
      old_eager, @_eager_autoload = @_eager_autoload, true
      yield
    ensure
      @_eager_autoload = old_eager
    end

    def eager_load!
      @_autoloads.each_value { |file| require file }
    end

    def autoloads
      @_autoloads
    end
  end
end
require "abstract_unit"

class TestAutoloadModule < ActiveSupport::TestCase
  include ActiveSupport::Testing::Isolation

  module ::Fixtures
    extend ActiveSupport::Autoload

    module Autoload
      extend ActiveSupport::Autoload
    end
  end

  def setup
    @some_class_path = File.expand_path("test/fixtures/autoload/some_class.rb")
    @another_class_path = File.expand_path("test/fixtures/autoload/another_class.rb")
  end

  test "the autoload module works like normal autoload" do
    module ::Fixtures::Autoload
      autoload :SomeClass, "fixtures/autoload/some_class"
    end

    assert_nothing_raised { ::Fixtures::Autoload::SomeClass }
  end

  test "when specifying an :eager constant it still works like normal autoload by default" do
    module ::Fixtures::Autoload
      eager_autoload do
        autoload :SomeClass, "fixtures/autoload/some_class"
      end
    end

    assert !$LOADED_FEATURES.include?(@some_class_path)
    assert_nothing_raised { ::Fixtures::Autoload::SomeClass }
  end

  test "the location of autoloaded constants defaults to :name.underscore" do
    module ::Fixtures::Autoload
      autoload :SomeClass
    end

    assert !$LOADED_FEATURES.include?(@some_class_path)
    assert_nothing_raised { ::Fixtures::Autoload::SomeClass }
  end

  test "the location of :eager autoloaded constants defaults to :name.underscore" do
    module ::Fixtures::Autoload
      eager_autoload do
        autoload :SomeClass
      end
    end

    assert !$LOADED_FEATURES.include?(@some_class_path)
    ::Fixtures::Autoload.eager_load!
    assert $LOADED_FEATURES.include?(@some_class_path)
    assert_nothing_raised { ::Fixtures::Autoload::SomeClass }
  end

  test "a directory for a block of autoloads can be specified" do
    module ::Fixtures
      autoload_under "autoload" do
        autoload :AnotherClass
      end
    end

    assert !$LOADED_FEATURES.include?(@another_class_path)
    assert_nothing_raised { ::Fixtures::AnotherClass }
  end

  test "a path for a block of autoloads can be specified" do
    module ::Fixtures
      autoload_at "fixtures/autoload/another_class" do
        autoload :AnotherClass
      end
    end

    assert !$LOADED_FEATURES.include?(@another_class_path)
    assert_nothing_raised { ::Fixtures::AnotherClass }
  end
end
gem "minitest"

require "minitest"

if Minitest.respond_to?(:run_with_rails_extension)
  unless Minitest.run_with_rails_extension
    Minitest.run_with_autorun = true
    Minitest.autorun
  end
else
  Minitest.autorun
end
module ActiveRecord
  # = Active Record Autosave Association
  #
  # AutosaveAssociation is a module that takes care of automatically saving
  # associated records when their parent is saved. In addition to saving, it
  # also destroys any associated records that were marked for destruction.
  # (See #mark_for_destruction and #marked_for_destruction?).
  #
  # Saving of the parent, its associations, and the destruction of marked
  # associations, all happen inside a transaction. This should never leave the
  # database in an inconsistent state.
  #
  # If validations for any of the associations fail, their error messages will
  # be applied to the parent.
  #
  # Note that it also means that associations marked for destruction won't
  # be destroyed directly. They will however still be marked for destruction.
  #
  # Note that <tt>autosave: false</tt> is not same as not declaring <tt>:autosave</tt>.
  # When the <tt>:autosave</tt> option is not present then new association records are
  # saved but the updated association records are not saved.
  #
  # == Validation
  #
  # Child records are validated unless <tt>:validate</tt> is +false+.
  #
  # == Callbacks
  #
  # Association with autosave option defines several callbacks on your
  # model (before_save, after_create, after_update). Please note that
  # callbacks are executed in the order they were defined in
  # model. You should avoid modifying the association content, before
  # autosave callbacks are executed. Placing your callbacks after
  # associations is usually a good practice.
  #
  # === One-to-one Example
  #
  #   class Post < ActiveRecord::Base
  #     has_one :author, autosave: true
  #   end
  #
  # Saving changes to the parent and its associated model can now be performed
  # automatically _and_ atomically:
  #
  #   post = Post.find(1)
  #   post.title       # => "The current global position of migrating ducks"
  #   post.author.name # => "alloy"
  #
  #   post.title = "On the migration of ducks"
  #   post.author.name = "Eloy Duran"
  #
  #   post.save
  #   post.reload
  #   post.title       # => "On the migration of ducks"
  #   post.author.name # => "Eloy Duran"
  #
  # Destroying an associated model, as part of the parent's save action, is as
  # simple as marking it for destruction:
  #
  #   post.author.mark_for_destruction
  #   post.author.marked_for_destruction? # => true
  #
  # Note that the model is _not_ yet removed from the database:
  #
  #   id = post.author.id
  #   Author.find_by(id: id).nil? # => false
  #
  #   post.save
  #   post.reload.author # => nil
  #
  # Now it _is_ removed from the database:
  #
  #   Author.find_by(id: id).nil? # => true
  #
  # === One-to-many Example
  #
  # When <tt>:autosave</tt> is not declared new children are saved when their parent is saved:
  #
  #   class Post < ActiveRecord::Base
  #     has_many :comments # :autosave option is not declared
  #   end
  #
  #   post = Post.new(title: 'ruby rocks')
  #   post.comments.build(body: 'hello world')
  #   post.save # => saves both post and comment
  #
  #   post = Post.create(title: 'ruby rocks')
  #   post.comments.build(body: 'hello world')
  #   post.save # => saves both post and comment
  #
  #   post = Post.create(title: 'ruby rocks')
  #   post.comments.create(body: 'hello world')
  #   post.save # => saves both post and comment
  #
  # When <tt>:autosave</tt> is true all children are saved, no matter whether they
  # are new records or not:
  #
  #   class Post < ActiveRecord::Base
  #     has_many :comments, autosave: true
  #   end
  #
  #   post = Post.create(title: 'ruby rocks')
  #   post.comments.create(body: 'hello world')
  #   post.comments[0].body = 'hi everyone'
  #   post.comments.build(body: "good morning.")
  #   post.title += "!"
  #   post.save # => saves both post and comments.
  #
  # Destroying one of the associated models as part of the parent's save action
  # is as simple as marking it for destruction:
  #
  #   post.comments # => [#<Comment id: 1, ...>, #<Comment id: 2, ...]>
  #   post.comments[1].mark_for_destruction
  #   post.comments[1].marked_for_destruction? # => true
  #   post.comments.length # => 2
  #
  # Note that the model is _not_ yet removed from the database:
  #
  #   id = post.comments.last.id
  #   Comment.find_by(id: id).nil? # => false
  #
  #   post.save
  #   post.reload.comments.length # => 1
  #
  # Now it _is_ removed from the database:
  #
  #   Comment.find_by(id: id).nil? # => true
  module AutosaveAssociation
    extend ActiveSupport::Concern

    module AssociationBuilderExtension #:nodoc:
      def self.build(model, reflection)
        model.send(:add_autosave_association_callbacks, reflection)
      end

      def self.valid_options
        [ :autosave ]
      end
    end

    included do
      Associations::Builder::Association.extensions << AssociationBuilderExtension
      mattr_accessor :index_nested_attribute_errors, instance_writer: false
      self.index_nested_attribute_errors = false
    end

    module ClassMethods # :nodoc:
      private

        def define_non_cyclic_method(name, &block)
          return if method_defined?(name)
          define_method(name) do |*args|
            result = true; @_already_called ||= {}
            # Loop prevention for validation of associations
            unless @_already_called[name]
              begin
                @_already_called[name]=true
                result = instance_eval(&block)
              ensure
                @_already_called[name]=false
              end
            end

            result
          end
        end

        # Adds validation and save callbacks for the association as specified by
        # the +reflection+.
        #
        # For performance reasons, we don't check whether to validate at runtime.
        # However the validation and callback methods are lazy and those methods
        # get created when they are invoked for the very first time. However,
        # this can change, for instance, when using nested attributes, which is
        # called _after_ the association has been defined. Since we don't want
        # the callbacks to get defined multiple times, there are guards that
        # check if the save or validation methods have already been defined
        # before actually defining them.
        def add_autosave_association_callbacks(reflection)
          save_method = :"autosave_associated_records_for_#{reflection.name}"

          if reflection.collection?
            before_save :before_save_collection_association

            define_non_cyclic_method(save_method) { save_collection_association(reflection) }
            # Doesn't use after_save as that would save associations added in after_create/after_update twice
            after_create save_method
            after_update save_method
          elsif reflection.has_one?
            define_method(save_method) { save_has_one_association(reflection) } unless method_defined?(save_method)
            # Configures two callbacks instead of a single after_save so that
            # the model may rely on their execution order relative to its
            # own callbacks.
            #
            # For example, given that after_creates run before after_saves, if
            # we configured instead an after_save there would be no way to fire
            # a custom after_create callback after the child association gets
            # created.
            after_create save_method
            after_update save_method
          else
            define_non_cyclic_method(save_method) { throw(:abort) if save_belongs_to_association(reflection) == false }
            before_save save_method
          end

          define_autosave_validation_callbacks(reflection)
        end

        def define_autosave_validation_callbacks(reflection)
          validation_method = :"validate_associated_records_for_#{reflection.name}"
          if reflection.validate? && !method_defined?(validation_method)
            if reflection.collection?
              method = :validate_collection_association
            else
              method = :validate_single_association
            end

            define_non_cyclic_method(validation_method) do
              send(method, reflection)
              # TODO: remove the following line as soon as the return value of
              # callbacks is ignored, that is, returning `false` does not
              # display a deprecation warning or halts the callback chain.
              true
            end
            validate validation_method
            after_validation :_ensure_no_duplicate_errors
          end
        end
    end

    # Reloads the attributes of the object as usual and clears <tt>marked_for_destruction</tt> flag.
    def reload(options = nil)
      @marked_for_destruction = false
      @destroyed_by_association = nil
      super
    end

    # Marks this record to be destroyed as part of the parent's save transaction.
    # This does _not_ actually destroy the record instantly, rather child record will be destroyed
    # when <tt>parent.save</tt> is called.
    #
    # Only useful if the <tt>:autosave</tt> option on the parent is enabled for this associated model.
    def mark_for_destruction
      @marked_for_destruction = true
    end

    # Returns whether or not this record will be destroyed as part of the parent's save transaction.
    #
    # Only useful if the <tt>:autosave</tt> option on the parent is enabled for this associated model.
    def marked_for_destruction?
      @marked_for_destruction
    end

    # Records the association that is being destroyed and destroying this
    # record in the process.
    def destroyed_by_association=(reflection)
      @destroyed_by_association = reflection
    end

    # Returns the association for the parent being destroyed.
    #
    # Used to avoid updating the counter cache unnecessarily.
    def destroyed_by_association
      @destroyed_by_association
    end

    # Returns whether or not this record has been changed in any way (including whether
    # any of its nested autosave associations are likewise changed)
    def changed_for_autosave?
      new_record? || changed? || marked_for_destruction? || nested_records_changed_for_autosave?
    end

    private

      # Returns the record for an association collection that should be validated
      # or saved. If +autosave+ is +false+ only new records will be returned,
      # unless the parent is/was a new record itself.
      def associated_records_to_validate_or_save(association, new_record, autosave)
        if new_record
          association && association.target
        elsif autosave
          association.target.find_all(&:changed_for_autosave?)
        else
          association.target.find_all(&:new_record?)
        end
      end

      # go through nested autosave associations that are loaded in memory (without loading
      # any new ones), and return true if is changed for autosave
      def nested_records_changed_for_autosave?
        @_nested_records_changed_for_autosave_already_called ||= false
        return false if @_nested_records_changed_for_autosave_already_called
        begin
          @_nested_records_changed_for_autosave_already_called = true
          self.class._reflections.values.any? do |reflection|
            if reflection.options[:autosave]
              association = association_instance_get(reflection.name)
              association && Array.wrap(association.target).any?(&:changed_for_autosave?)
            end
          end
        ensure
          @_nested_records_changed_for_autosave_already_called = false
        end
      end

      # Validate the association if <tt>:validate</tt> or <tt>:autosave</tt> is
      # turned on for the association.
      def validate_single_association(reflection)
        association = association_instance_get(reflection.name)
        record      = association && association.reader
        association_valid?(reflection, record) if record
      end

      # Validate the associated records if <tt>:validate</tt> or
      # <tt>:autosave</tt> is turned on for the association specified by
      # +reflection+.
      def validate_collection_association(reflection)
        if association = association_instance_get(reflection.name)
          if records = associated_records_to_validate_or_save(association, new_record?, reflection.options[:autosave])
            records.each_with_index { |record, index| association_valid?(reflection, record, index) }
          end
        end
      end

      # Returns whether or not the association is valid and applies any errors to
      # the parent, <tt>self</tt>, if it wasn't. Skips any <tt>:autosave</tt>
      # enabled records if they're marked_for_destruction? or destroyed.
      def association_valid?(reflection, record, index=nil)
        return true if record.destroyed? || (reflection.options[:autosave] && record.marked_for_destruction?)

        validation_context = self.validation_context unless [:create, :update].include?(self.validation_context)
        unless valid = record.valid?(validation_context)
          if reflection.options[:autosave]
            indexed_attribute = !index.nil? && (reflection.options[:index_errors] || ActiveRecord::Base.index_nested_attribute_errors)

            record.errors.each do |attribute, message|
              if indexed_attribute
                attribute = "#{reflection.name}[#{index}].#{attribute}"
              else
                attribute = "#{reflection.name}.#{attribute}"
              end
              errors[attribute] << message
              errors[attribute].uniq!
            end

            record.errors.details.each_key do |attribute|
              if indexed_attribute
                reflection_attribute = "#{reflection.name}[#{index}].#{attribute}"
              else
                reflection_attribute = "#{reflection.name}.#{attribute}"
              end

              record.errors.details[attribute].each do |error|
                errors.details[reflection_attribute] << error
                errors.details[reflection_attribute].uniq!
              end
            end
          else
            errors.add(reflection.name)
          end
        end
        valid
      end

      # Is used as a before_save callback to check while saving a collection
      # association whether or not the parent was a new record before saving.
      def before_save_collection_association
        @new_record_before_save = new_record?
        true
      end

      # Saves any new associated records, or all loaded autosave associations if
      # <tt>:autosave</tt> is enabled on the association.
      #
      # In addition, it destroys all children that were marked for destruction
      # with #mark_for_destruction.
      #
      # This all happens inside a transaction, _if_ the Transactions module is included into
      # ActiveRecord::Base after the AutosaveAssociation module, which it does by default.
      def save_collection_association(reflection)
        if association = association_instance_get(reflection.name)
          autosave = reflection.options[:autosave]

          if records = associated_records_to_validate_or_save(association, @new_record_before_save, autosave)
            if autosave
              records_to_destroy = records.select(&:marked_for_destruction?)
              records_to_destroy.each { |record| association.destroy(record) }
              records -= records_to_destroy
            end

            records.each do |record|
              next if record.destroyed?

              saved = true

              if autosave != false && (@new_record_before_save || record.new_record?)
                if autosave
                  saved = association.insert_record(record, false)
                else
                  association.insert_record(record) unless reflection.nested?
                end
              elsif autosave
                saved = record.save(validate: false)
              end

              raise ActiveRecord::Rollback unless saved
            end
          end

          # reconstruct the scope now that we know the owner's id
          association.reset_scope if association.respond_to?(:reset_scope)
        end
      end

      # Saves the associated record if it's new or <tt>:autosave</tt> is enabled
      # on the association.
      #
      # In addition, it will destroy the association if it was marked for
      # destruction with #mark_for_destruction.
      #
      # This all happens inside a transaction, _if_ the Transactions module is included into
      # ActiveRecord::Base after the AutosaveAssociation module, which it does by default.
      def save_has_one_association(reflection)
        association = association_instance_get(reflection.name)
        record      = association && association.load_target

        if record && !record.destroyed?
          autosave = reflection.options[:autosave]

          if autosave && record.marked_for_destruction?
            record.destroy
          elsif autosave != false
            key = reflection.options[:primary_key] ? send(reflection.options[:primary_key]) : id

            if (autosave && record.changed_for_autosave?) || new_record? || record_changed?(reflection, record, key)
              unless reflection.through_reflection
                record[reflection.foreign_key] = key
              end

              saved = record.save(validate: !autosave)
              raise ActiveRecord::Rollback if !saved && autosave
              saved
            end
          end
        end
      end

      # If the record is new or it has changed, returns true.
      def record_changed?(reflection, record, key)
        record.new_record? ||
          (record.has_attribute?(reflection.foreign_key) && record[reflection.foreign_key] != key) ||
          record.attribute_changed?(reflection.foreign_key)
      end

      # Saves the associated record if it's new or <tt>:autosave</tt> is enabled.
      #
      # In addition, it will destroy the association if it was marked for destruction.
      def save_belongs_to_association(reflection)
        association = association_instance_get(reflection.name)
        record      = association && association.load_target
        if record && !record.destroyed?
          autosave = reflection.options[:autosave]

          if autosave && record.marked_for_destruction?
            self[reflection.foreign_key] = nil
            record.destroy
          elsif autosave != false
            saved = record.save(validate: !autosave) if record.new_record? || (autosave && record.changed_for_autosave?)

            if association.updated?
              association_id = record.send(reflection.options[:primary_key] || :id)
              self[reflection.foreign_key] = association_id
              association.loaded!
            end

            saved if autosave
          end
        end
      end

      def _ensure_no_duplicate_errors
        errors.messages.each_key do |attribute|
          errors[attribute].uniq!
        end
      end
  end
end
require "cases/helper"
require "models/bird"
require "models/comment"
require "models/company"
require "models/customer"
require "models/developer"
require "models/computer"
require "models/invoice"
require "models/line_item"
require "models/order"
require "models/parrot"
require "models/person"
require "models/pirate"
require "models/post"
require "models/reader"
require "models/ship"
require "models/ship_part"
require "models/tag"
require "models/tagging"
require "models/treasure"
require "models/eye"
require "models/electron"
require "models/molecule"
require "models/member"
require "models/member_detail"
require "models/organization"
require "models/guitar"
require "models/tuning_peg"

class TestAutosaveAssociationsInGeneral < ActiveRecord::TestCase
  def test_autosave_validation
    person = Class.new(ActiveRecord::Base) {
      self.table_name = "people"
      validate :should_be_cool, on: :create
      def self.name; "Person"; end

      private

      def should_be_cool
        unless self.first_name == "cool"
          errors.add :first_name, "not cool"
        end
      end
    }
    reference = Class.new(ActiveRecord::Base) {
      self.table_name = "references"
      def self.name; "Reference"; end
      belongs_to :person, autosave: true, anonymous_class: person
    }

    u = person.create!(first_name: "cool")
    u.update_attributes!(first_name: "nah") # still valid because validation only applies on 'create'
    assert reference.create!(person: u).persisted?
  end

  def test_should_not_add_the_same_callbacks_multiple_times_for_has_one
    assert_no_difference_when_adding_callbacks_twice_for Pirate, :ship
  end

  def test_should_not_add_the_same_callbacks_multiple_times_for_belongs_to
    assert_no_difference_when_adding_callbacks_twice_for Ship, :pirate
  end

  def test_should_not_add_the_same_callbacks_multiple_times_for_has_many
    assert_no_difference_when_adding_callbacks_twice_for Pirate, :birds
  end

  def test_should_not_add_the_same_callbacks_multiple_times_for_has_and_belongs_to_many
    assert_no_difference_when_adding_callbacks_twice_for Pirate, :parrots
  end

  def test_cyclic_autosaves_do_not_add_multiple_validations
    ship = ShipWithoutNestedAttributes.new
    ship.prisoners.build

    assert_not ship.valid?
    assert_equal 1, ship.errors[:name].length
  end

  private

    def assert_no_difference_when_adding_callbacks_twice_for(model, association_name)
      reflection = model.reflect_on_association(association_name)
      assert_no_difference "callbacks_for_model(#{model.name}).length" do
        model.send(:add_autosave_association_callbacks, reflection)
      end
    end

    def callbacks_for_model(model)
      model.instance_variables.grep(/_callbacks$/).flat_map do |ivar|
        model.instance_variable_get(ivar)
      end
    end
end

class TestDefaultAutosaveAssociationOnAHasOneAssociation < ActiveRecord::TestCase
  fixtures :companies, :accounts

  def test_should_save_parent_but_not_invalid_child
    firm = Firm.new(name: "GlobalMegaCorp")
    assert firm.valid?

    firm.build_account_using_primary_key
    assert !firm.build_account_using_primary_key.valid?

    assert firm.save
    assert !firm.account_using_primary_key.persisted?
  end

  def test_save_fails_for_invalid_has_one
    firm = Firm.first
    assert firm.valid?

    firm.build_account

    assert !firm.account.valid?
    assert !firm.valid?
    assert !firm.save
    assert_equal ["is invalid"], firm.errors["account"]
  end

  def test_save_succeeds_for_invalid_has_one_with_validate_false
    firm = Firm.first
    assert firm.valid?

    firm.build_unvalidated_account

    assert !firm.unvalidated_account.valid?
    assert firm.valid?
    assert firm.save
  end

  def test_build_before_child_saved
    firm = Firm.find(1)

    account = firm.build_account("credit_limit" => 1000)
    assert_equal account, firm.account
    assert !account.persisted?
    assert firm.save
    assert_equal account, firm.account
    assert account.persisted?
  end

  def test_build_before_either_saved
    firm = Firm.new("name" => "GlobalMegaCorp")

    firm.account = account = Account.new("credit_limit" => 1000)
    assert_equal account, firm.account
    assert !account.persisted?
    assert firm.save
    assert_equal account, firm.account
    assert account.persisted?
  end

  def test_assignment_before_parent_saved
    firm = Firm.new("name" => "GlobalMegaCorp")
    firm.account = a = Account.find(1)
    assert !firm.persisted?
    assert_equal a, firm.account
    assert firm.save
    assert_equal a, firm.account
    firm.association(:account).reload
    assert_equal a, firm.account
  end

  def test_assignment_before_either_saved
    firm = Firm.new("name" => "GlobalMegaCorp")
    firm.account = a = Account.new("credit_limit" => 1000)
    assert !firm.persisted?
    assert !a.persisted?
    assert_equal a, firm.account
    assert firm.save
    assert firm.persisted?
    assert a.persisted?
    assert_equal a, firm.account
    firm.association(:account).reload
    assert_equal a, firm.account
  end

  def test_not_resaved_when_unchanged
    firm = Firm.all.merge!(includes: :account).first
    firm.name += "-changed"
    assert_queries(1) { firm.save! }

    firm = Firm.first
    firm.account = Account.first
    assert_queries(Firm.partial_writes? ? 0 : 1) { firm.save! }

    firm = Firm.first.dup
    firm.account = Account.first
    assert_queries(2) { firm.save! }

    firm = Firm.first.dup
    firm.account = Account.first.dup
    assert_queries(2) { firm.save! }
  end

  def test_callbacks_firing_order_on_create
    eye = Eye.create(iris_attributes: {color: "honey"})
    assert_equal [true, false], eye.after_create_callbacks_stack
  end

  def test_callbacks_firing_order_on_update
    eye = Eye.create(iris_attributes: {color: "honey"})
    eye.update(iris_attributes: {color: "green"})
    assert_equal [true, false], eye.after_update_callbacks_stack
  end

  def test_callbacks_firing_order_on_save
    eye = Eye.create(iris_attributes: {color: "honey"})
    assert_equal [false, false], eye.after_save_callbacks_stack

    eye.update(iris_attributes: {color: "blue"})
    assert_equal [false, false, false, false], eye.after_save_callbacks_stack
  end
end

class TestDefaultAutosaveAssociationOnABelongsToAssociation < ActiveRecord::TestCase
  fixtures :companies, :posts, :tags, :taggings

  def test_should_save_parent_but_not_invalid_child
    client = Client.new(name: "Joe (the Plumber)")
    assert client.valid?

    client.build_firm
    assert !client.firm.valid?

    assert client.save
    assert !client.firm.persisted?
  end

  def test_save_fails_for_invalid_belongs_to
    # Oracle saves empty string as NULL therefore :message changed to one space
    assert log = AuditLog.create(developer_id: 0, message: " ")

    log.developer = Developer.new
    assert !log.developer.valid?
    assert !log.valid?
    assert !log.save
    assert_equal ["is invalid"], log.errors["developer"]
  end

  def test_save_succeeds_for_invalid_belongs_to_with_validate_false
    # Oracle saves empty string as NULL therefore :message changed to one space
    assert log = AuditLog.create(developer_id: 0, message: " ")

    log.unvalidated_developer = Developer.new
    assert !log.unvalidated_developer.valid?
    assert log.valid?
    assert log.save
  end

  def test_assignment_before_parent_saved
    client = Client.first
    apple = Firm.new("name" => "Apple")
    client.firm = apple
    assert_equal apple, client.firm
    assert !apple.persisted?
    assert client.save
    assert apple.save
    assert apple.persisted?
    assert_equal apple, client.firm
    client.association(:firm).reload
    assert_equal apple, client.firm
  end

  def test_assignment_before_either_saved
    final_cut = Client.new("name" => "Final Cut")
    apple = Firm.new("name" => "Apple")
    final_cut.firm = apple
    assert !final_cut.persisted?
    assert !apple.persisted?
    assert final_cut.save
    assert final_cut.persisted?
    assert apple.persisted?
    assert_equal apple, final_cut.firm
    final_cut.association(:firm).reload
    assert_equal apple, final_cut.firm
  end

  def test_store_two_association_with_one_save
    num_orders = Order.count
    num_customers = Customer.count
    order = Order.new

    customer1 = order.billing = Customer.new
    customer2 = order.shipping = Customer.new
    assert order.save
    assert_equal customer1, order.billing
    assert_equal customer2, order.shipping

    order.reload

    assert_equal customer1, order.billing
    assert_equal customer2, order.shipping

    assert_equal num_orders + 1, Order.count
    assert_equal num_customers + 2, Customer.count
  end

  def test_store_association_in_two_relations_with_one_save
    num_orders = Order.count
    num_customers = Customer.count
    order = Order.new

    customer = order.billing = order.shipping = Customer.new
    assert order.save
    assert_equal customer, order.billing
    assert_equal customer, order.shipping

    order.reload

    assert_equal customer, order.billing
    assert_equal customer, order.shipping

    assert_equal num_orders + 1, Order.count
    assert_equal num_customers + 1, Customer.count
  end

  def test_store_association_in_two_relations_with_one_save_in_existing_object
    num_orders = Order.count
    num_customers = Customer.count
    order = Order.create

    customer = order.billing = order.shipping = Customer.new
    assert order.save
    assert_equal customer, order.billing
    assert_equal customer, order.shipping

    order.reload

    assert_equal customer, order.billing
    assert_equal customer, order.shipping

    assert_equal num_orders + 1, Order.count
    assert_equal num_customers + 1, Customer.count
  end

  def test_store_association_in_two_relations_with_one_save_in_existing_object_with_values
    num_orders = Order.count
    num_customers = Customer.count
    order = Order.create

    customer = order.billing = order.shipping = Customer.new
    assert order.save
    assert_equal customer, order.billing
    assert_equal customer, order.shipping

    order.reload

    customer = order.billing = order.shipping = Customer.new

    assert order.save
    order.reload

    assert_equal customer, order.billing
    assert_equal customer, order.shipping

    assert_equal num_orders + 1, Order.count
    assert_equal num_customers + 2, Customer.count
  end

  def test_store_association_with_a_polymorphic_relationship
    num_tagging = Tagging.count
    tags(:misc).create_tagging(taggable: posts(:thinking))
    assert_equal num_tagging + 1, Tagging.count
  end

  def test_build_and_then_save_parent_should_not_reload_target
    client = Client.first
    apple = client.build_firm(name: "Apple")
    client.save!
    assert_no_queries { assert_equal apple, client.firm }
  end

  def test_validation_does_not_validate_stale_association_target
    valid_developer   = Developer.create!(name: "Dude", salary: 50_000)
    invalid_developer = Developer.new()

    auditlog = AuditLog.new(message: "foo")
    auditlog.developer    = invalid_developer
    auditlog.developer_id = valid_developer.id

    assert auditlog.valid?
  end
end

class TestDefaultAutosaveAssociationOnAHasManyAssociationWithAcceptsNestedAttributes < ActiveRecord::TestCase
  def test_invalid_adding_with_nested_attributes
    molecule = Molecule.new
    valid_electron = Electron.new(name: "electron")
    invalid_electron = Electron.new

    molecule.electrons = [valid_electron, invalid_electron]
    molecule.save

    assert_not invalid_electron.valid?
    assert valid_electron.valid?
    assert_not molecule.persisted?, "Molecule should not be persisted when its electrons are invalid"
  end

  def test_errors_should_be_indexed_when_passed_as_array
    guitar = Guitar.new
    tuning_peg_valid = TuningPeg.new
    tuning_peg_valid.pitch = 440.0
    tuning_peg_invalid = TuningPeg.new

    guitar.tuning_pegs = [tuning_peg_valid, tuning_peg_invalid]

    assert_not tuning_peg_invalid.valid?
    assert tuning_peg_valid.valid?
    assert_not guitar.valid?
    assert_equal ["is not a number"], guitar.errors["tuning_pegs[1].pitch"]
    assert_not_equal ["is not a number"], guitar.errors["tuning_pegs.pitch"]
  end

  def test_errors_should_be_indexed_when_global_flag_is_set
    old_attribute_config = ActiveRecord::Base.index_nested_attribute_errors
    ActiveRecord::Base.index_nested_attribute_errors = true

    molecule = Molecule.new
    valid_electron = Electron.new(name: "electron")
    invalid_electron = Electron.new

    molecule.electrons = [valid_electron, invalid_electron]

    assert_not invalid_electron.valid?
    assert valid_electron.valid?
    assert_not molecule.valid?
    assert_equal ["can't be blank"], molecule.errors["electrons[1].name"]
    assert_not_equal ["can't be blank"], molecule.errors["electrons.name"]
  ensure
    ActiveRecord::Base.index_nested_attribute_errors = old_attribute_config
  end

  def test_errors_details_should_be_set
    molecule = Molecule.new
    valid_electron = Electron.new(name: "electron")
    invalid_electron = Electron.new

    molecule.electrons = [valid_electron, invalid_electron]

    assert_not invalid_electron.valid?
    assert valid_electron.valid?
    assert_not molecule.valid?
    assert_equal [{error: :blank}], molecule.errors.details["electrons.name"]
  end

  def test_errors_details_should_be_indexed_when_passed_as_array
    guitar = Guitar.new
    tuning_peg_valid = TuningPeg.new
    tuning_peg_valid.pitch = 440.0
    tuning_peg_invalid = TuningPeg.new

    guitar.tuning_pegs = [tuning_peg_valid, tuning_peg_invalid]

    assert_not tuning_peg_invalid.valid?
    assert tuning_peg_valid.valid?
    assert_not guitar.valid?
    assert_equal [{error: :not_a_number, value: nil}] , guitar.errors.details["tuning_pegs[1].pitch"]
    assert_equal [], guitar.errors.details["tuning_pegs.pitch"]
  end

  def test_errors_details_should_be_indexed_when_global_flag_is_set
    old_attribute_config = ActiveRecord::Base.index_nested_attribute_errors
    ActiveRecord::Base.index_nested_attribute_errors = true

    molecule = Molecule.new
    valid_electron = Electron.new(name: "electron")
    invalid_electron = Electron.new

    molecule.electrons = [valid_electron, invalid_electron]

    assert_not invalid_electron.valid?
    assert valid_electron.valid?
    assert_not molecule.valid?
    assert_equal [{error: :blank}], molecule.errors.details["electrons[1].name"]
    assert_equal [], molecule.errors.details["electrons.name"]
  ensure
    ActiveRecord::Base.index_nested_attribute_errors = old_attribute_config
  end

  def test_valid_adding_with_nested_attributes
    molecule = Molecule.new
    valid_electron = Electron.new(name: "electron")

    molecule.electrons = [valid_electron]
    molecule.save

    assert valid_electron.valid?
    assert molecule.persisted?
    assert_equal 1, molecule.electrons.count
  end
end

class TestDefaultAutosaveAssociationOnAHasManyAssociation < ActiveRecord::TestCase
  fixtures :companies, :people

  def test_invalid_adding
    firm = Firm.find(1)
    assert !(firm.clients_of_firm << c = Client.new)
    assert !c.persisted?
    assert !firm.valid?
    assert !firm.save
    assert !c.persisted?
  end

  def test_invalid_adding_before_save
    new_firm = Firm.new("name" => "A New Firm, Inc")
    new_firm.clients_of_firm.concat([c = Client.new, Client.new("name" => "Apple")])
    assert !c.persisted?
    assert !c.valid?
    assert !new_firm.valid?
    assert !new_firm.save
    assert !c.persisted?
    assert !new_firm.persisted?
  end

  def test_invalid_adding_with_validate_false
    firm = Firm.first
    client = Client.new
    firm.unvalidated_clients_of_firm << client

    assert firm.valid?
    assert !client.valid?
    assert firm.save
    assert !client.persisted?
  end

  def test_valid_adding_with_validate_false
    no_of_clients = Client.count

    firm = Firm.first
    client = Client.new("name" => "Apple")

    assert firm.valid?
    assert client.valid?
    assert !client.persisted?

    firm.unvalidated_clients_of_firm << client

    assert firm.save
    assert client.persisted?
    assert_equal no_of_clients + 1, Client.count
  end

  def test_invalid_build
    new_client = companies(:first_firm).clients_of_firm.build
    assert !new_client.persisted?
    assert !new_client.valid?
    assert_equal new_client, companies(:first_firm).clients_of_firm.last
    assert !companies(:first_firm).save
    assert !new_client.persisted?
    assert_equal 2, companies(:first_firm).clients_of_firm.reload.size
  end

  def test_adding_before_save
    no_of_firms = Firm.count
    no_of_clients = Client.count

    new_firm = Firm.new("name" => "A New Firm, Inc")
    c = Client.new("name" => "Apple")

    new_firm.clients_of_firm.push Client.new("name" => "Natural Company")
    assert_equal 1, new_firm.clients_of_firm.size
    new_firm.clients_of_firm << c
    assert_equal 2, new_firm.clients_of_firm.size

    assert_equal no_of_firms, Firm.count      # Firm was not saved to database.
    assert_equal no_of_clients, Client.count  # Clients were not saved to database.
    assert new_firm.save
    assert new_firm.persisted?
    assert c.persisted?
    assert_equal new_firm, c.firm
    assert_equal no_of_firms + 1, Firm.count      # Firm was saved to database.
    assert_equal no_of_clients + 2, Client.count  # Clients were saved to database.

    assert_equal 2, new_firm.clients_of_firm.size
    assert_equal 2, new_firm.clients_of_firm.reload.size
  end

  def test_assign_ids
    firm = Firm.new("name" => "Apple")
    firm.client_ids = [companies(:first_client).id, companies(:second_client).id]
    firm.save
    firm.reload
    assert_equal 2, firm.clients.length
    assert firm.clients.include?(companies(:second_client))
  end

  def test_assign_ids_for_through_a_belongs_to
    post = Post.new(title: "Assigning IDs works!", body: "You heard it here first, folks!")
    post.person_ids = [people(:david).id, people(:michael).id]
    post.save
    post.reload
    assert_equal 2, post.people.length
    assert post.people.include?(people(:david))
  end

  def test_build_before_save
    company = companies(:first_firm)
    new_client = assert_no_queries(ignore_none: false) { company.clients_of_firm.build("name" => "Another Client") }
    assert !company.clients_of_firm.loaded?

    company.name += "-changed"
    assert_queries(2) { assert company.save }
    assert new_client.persisted?
    assert_equal 3, company.clients_of_firm.reload.size
  end

  def test_build_many_before_save
    company = companies(:first_firm)
    assert_no_queries(ignore_none: false) { company.clients_of_firm.build([{"name" => "Another Client"}, {"name" => "Another Client II"}]) }

    company.name += "-changed"
    assert_queries(3) { assert company.save }
    assert_equal 4, company.clients_of_firm.reload.size
  end

  def test_build_via_block_before_save
    company = companies(:first_firm)
    new_client = assert_no_queries(ignore_none: false) { company.clients_of_firm.build {|client| client.name = "Another Client" } }
    assert !company.clients_of_firm.loaded?

    company.name += "-changed"
    assert_queries(2) { assert company.save }
    assert new_client.persisted?
    assert_equal 3, company.clients_of_firm.reload.size
  end

  def test_build_many_via_block_before_save
    company = companies(:first_firm)
    assert_no_queries(ignore_none: false) do
      company.clients_of_firm.build([{"name" => "Another Client"}, {"name" => "Another Client II"}]) do |client|
        client.name = "changed"
      end
    end

    company.name += "-changed"
    assert_queries(3) { assert company.save }
    assert_equal 4, company.clients_of_firm.reload.size
  end

  def test_replace_on_new_object
    firm = Firm.new("name" => "New Firm")
    firm.clients = [companies(:second_client), Client.new("name" => "New Client")]
    assert firm.save
    firm.reload
    assert_equal 2, firm.clients.length
    assert firm.clients.include?(Client.find_by_name("New Client"))
  end
end

class TestDefaultAutosaveAssociationOnNewRecord < ActiveRecord::TestCase
  def test_autosave_new_record_on_belongs_to_can_be_disabled_per_relationship
    new_account = Account.new("credit_limit" => 1000)
    new_firm = Firm.new("name" => "some firm")

    assert !new_firm.persisted?
    new_account.firm = new_firm
    new_account.save!

    assert new_firm.persisted?

    new_account = Account.new("credit_limit" => 1000)
    new_autosaved_firm = Firm.new("name" => "some firm")

    assert !new_autosaved_firm.persisted?
    new_account.unautosaved_firm = new_autosaved_firm
    new_account.save!

    assert !new_autosaved_firm.persisted?
  end

  def test_autosave_new_record_on_has_one_can_be_disabled_per_relationship
    firm = Firm.new("name" => "some firm")
    account = Account.new("credit_limit" => 1000)

    assert !account.persisted?
    firm.account = account
    firm.save!

    assert account.persisted?

    firm = Firm.new("name" => "some firm")
    account = Account.new("credit_limit" => 1000)

    firm.unautosaved_account = account

    assert !account.persisted?
    firm.unautosaved_account = account
    firm.save!

    assert !account.persisted?
  end

  def test_autosave_new_record_on_has_many_can_be_disabled_per_relationship
    firm = Firm.new("name" => "some firm")
    account = Account.new("credit_limit" => 1000)

    assert !account.persisted?
    firm.accounts << account

    firm.save!
    assert account.persisted?

    firm = Firm.new("name" => "some firm")
    account = Account.new("credit_limit" => 1000)

    assert !account.persisted?
    firm.unautosaved_accounts << account

    firm.save!
    assert !account.persisted?
  end

  def test_autosave_new_record_with_after_create_callback
    post = PostWithAfterCreateCallback.new(title: "Captain Murphy", body: "is back")
    post.comments.build(body: "foo")
    post.save!

    assert_not_nil post.author_id
  end
end

class TestDestroyAsPartOfAutosaveAssociation < ActiveRecord::TestCase
  self.use_transactional_tests = false

  setup do
    @pirate = Pirate.create(catchphrase: "Don' botharrr talkin' like one, savvy?")
    @ship = @pirate.create_ship(name: "Nights Dirty Lightning")
  end

  teardown do
    # We are running without transactional tests and need to cleanup.
    Bird.delete_all
    Parrot.delete_all
    @ship.delete
    @pirate.delete
  end

  # reload
  def test_a_marked_for_destruction_record_should_not_be_be_marked_after_reload
    @pirate.mark_for_destruction
    @pirate.ship.mark_for_destruction

    assert !@pirate.reload.marked_for_destruction?
    assert !@pirate.ship.reload.marked_for_destruction?
  end

  # has_one
  def test_should_destroy_a_child_association_as_part_of_the_save_transaction_if_it_was_marked_for_destruction
    assert !@pirate.ship.marked_for_destruction?

    @pirate.ship.mark_for_destruction
    id = @pirate.ship.id

    assert @pirate.ship.marked_for_destruction?
    assert Ship.find_by_id(id)

    @pirate.save
    assert_nil @pirate.reload.ship
    assert_nil Ship.find_by_id(id)
  end

  def test_should_skip_validation_on_a_child_association_if_marked_for_destruction
    @pirate.ship.name = ""
    assert !@pirate.valid?

    @pirate.ship.mark_for_destruction
    @pirate.ship.expects(:valid?).never
    assert_difference("Ship.count", -1) { @pirate.save! }
  end

  def test_a_child_marked_for_destruction_should_not_be_destroyed_twice
    @pirate.ship.mark_for_destruction
    assert @pirate.save
    class << @pirate.ship
      def destroy; raise "Should not be called" end
    end
    assert @pirate.save
  end

  def test_should_rollback_destructions_if_an_exception_occurred_while_saving_a_child
    # Stub the save method of the @pirate.ship instance to destroy and then raise an exception
    class << @pirate.ship
      def save(*args)
        super
        destroy
        raise "Oh noes!"
      end
    end

    @ship.pirate.catchphrase = "Changed Catchphrase"

    assert_raise(RuntimeError) { assert !@pirate.save }
    assert_not_nil @pirate.reload.ship
  end

  def test_should_save_changed_has_one_changed_object_if_child_is_saved
    @pirate.ship.name = "NewName"
    assert @pirate.save
    assert_equal "NewName", @pirate.ship.reload.name
  end

  def test_should_not_save_changed_has_one_unchanged_object_if_child_is_saved
    @pirate.ship.expects(:save).never
    assert @pirate.save
  end

  # belongs_to
  def test_should_destroy_a_parent_association_as_part_of_the_save_transaction_if_it_was_marked_for_destruction
    assert !@ship.pirate.marked_for_destruction?

    @ship.pirate.mark_for_destruction
    id = @ship.pirate.id

    assert @ship.pirate.marked_for_destruction?
    assert Pirate.find_by_id(id)

    @ship.save
    assert_nil @ship.reload.pirate
    assert_nil Pirate.find_by_id(id)
  end

  def test_should_skip_validation_on_a_parent_association_if_marked_for_destruction
    @ship.pirate.catchphrase = ""
    assert !@ship.valid?

    @ship.pirate.mark_for_destruction
    @ship.pirate.expects(:valid?).never
    assert_difference("Pirate.count", -1) { @ship.save! }
  end

  def test_a_parent_marked_for_destruction_should_not_be_destroyed_twice
    @ship.pirate.mark_for_destruction
    assert @ship.save
    class << @ship.pirate
      def destroy; raise "Should not be called" end
    end
    assert @ship.save
  end

  def test_should_rollback_destructions_if_an_exception_occurred_while_saving_a_parent
    # Stub the save method of the @ship.pirate instance to destroy and then raise an exception
    class << @ship.pirate
      def save(*args)
        super
        destroy
        raise "Oh noes!"
      end
    end

    @ship.pirate.catchphrase = "Changed Catchphrase"

    assert_raise(RuntimeError) { assert !@ship.save }
    assert_not_nil @ship.reload.pirate
  end

  def test_should_save_changed_child_objects_if_parent_is_saved
    @pirate = @ship.create_pirate(catchphrase: "Don' botharrr talkin' like one, savvy?")
    @parrot = @pirate.parrots.create!(name: "Posideons Killer")
    @parrot.name = "NewName"
    @ship.save

    assert_equal "NewName", @parrot.reload.name
  end

  def test_should_destroy_has_many_as_part_of_the_save_transaction_if_they_were_marked_for_destruction
    2.times { |i| @pirate.birds.create!(name: "birds_#{i}") }

    assert !@pirate.birds.any?(&:marked_for_destruction?)

    @pirate.birds.each(&:mark_for_destruction)
    klass = @pirate.birds.first.class
    ids = @pirate.birds.map(&:id)

    assert @pirate.birds.all?(&:marked_for_destruction?)
    ids.each { |id| assert klass.find_by_id(id) }

    @pirate.save
    assert @pirate.reload.birds.empty?
    ids.each { |id| assert_nil klass.find_by_id(id) }
  end

  def test_should_not_resave_destroyed_association
    @pirate.birds.create!(name: :parrot)
    @pirate.birds.first.destroy
    @pirate.save!
    assert @pirate.reload.birds.empty?
  end

  def test_should_skip_validation_on_has_many_if_marked_for_destruction
    2.times { |i| @pirate.birds.create!(name: "birds_#{i}") }

    @pirate.birds.each { |bird| bird.name = "" }
    assert !@pirate.valid?

    @pirate.birds.each do |bird|
      bird.mark_for_destruction
      bird.expects(:valid?).never
    end
    assert_difference("Bird.count", -2) { @pirate.save! }
  end

  def test_should_skip_validation_on_has_many_if_destroyed
    @pirate.birds.create!(name: "birds_1")

    @pirate.birds.each { |bird| bird.name = "" }
    assert !@pirate.valid?

    @pirate.birds.each(&:destroy)
    assert @pirate.valid?
  end

  def test_a_child_marked_for_destruction_should_not_be_destroyed_twice_while_saving_has_many
    @pirate.birds.create!(name: "birds_1")

    @pirate.birds.each(&:mark_for_destruction)
    assert @pirate.save

    @pirate.birds.each { |bird| bird.expects(:destroy).never }
    assert @pirate.save
  end

  def test_should_rollback_destructions_if_an_exception_occurred_while_saving_has_many
    2.times { |i| @pirate.birds.create!(name: "birds_#{i}") }
    before = @pirate.birds.map { |c| c.mark_for_destruction ; c }

    # Stub the destroy method of the second child to raise an exception
    class << before.last
      def destroy(*args)
        super
        raise "Oh noes!"
      end
    end

    assert_raise(RuntimeError) { assert !@pirate.save }
    assert_equal before, @pirate.reload.birds
  end

  def test_when_new_record_a_child_marked_for_destruction_should_not_affect_other_records_from_saving
    @pirate = @ship.build_pirate(catchphrase: "Arr' now I shall keep me eye on you matey!") # new record

    3.times { |i| @pirate.birds.build(name: "birds_#{i}") }
    @pirate.birds[1].mark_for_destruction
    @pirate.save!

    assert_equal 2, @pirate.birds.reload.length
  end

  def test_should_save_new_record_that_has_same_value_as_existing_record_marked_for_destruction_on_field_that_has_unique_index
    Bird.connection.add_index :birds, :name, unique: true

    3.times { |i| @pirate.birds.create(name: "unique_birds_#{i}") }

    @pirate.birds[0].mark_for_destruction
    @pirate.birds.build(name: @pirate.birds[0].name)
    @pirate.save!

    assert_equal 3, @pirate.birds.reload.length
  ensure
    Bird.connection.remove_index :birds, column: :name
  end

  # Add and remove callbacks tests for association collections.
  %w{ method proc }.each do |callback_type|
    define_method("test_should_run_add_callback_#{callback_type}s_for_has_many") do
      association_name_with_callbacks = "birds_with_#{callback_type}_callbacks"

      pirate = Pirate.new(catchphrase: "Arr")
      pirate.send(association_name_with_callbacks).build(name: "Crowe the One-Eyed")

      expected = [
        "before_adding_#{callback_type}_bird_<new>",
        "after_adding_#{callback_type}_bird_<new>"
      ]

      assert_equal expected, pirate.ship_log
    end

    define_method("test_should_run_remove_callback_#{callback_type}s_for_has_many") do
      association_name_with_callbacks = "birds_with_#{callback_type}_callbacks"

      @pirate.send(association_name_with_callbacks).create!(name: "Crowe the One-Eyed")
      @pirate.send(association_name_with_callbacks).each(&:mark_for_destruction)
      child_id = @pirate.send(association_name_with_callbacks).first.id

      @pirate.ship_log.clear
      @pirate.save

      expected = [
        "before_removing_#{callback_type}_bird_#{child_id}",
        "after_removing_#{callback_type}_bird_#{child_id}"
      ]

      assert_equal expected, @pirate.ship_log
    end
  end

  def test_should_destroy_habtm_as_part_of_the_save_transaction_if_they_were_marked_for_destruction
    2.times { |i| @pirate.parrots.create!(name: "parrots_#{i}") }

    assert !@pirate.parrots.any?(&:marked_for_destruction?)
    @pirate.parrots.each(&:mark_for_destruction)

    assert_no_difference "Parrot.count" do
      @pirate.save
    end

    assert @pirate.reload.parrots.empty?

    join_records = Pirate.connection.select_all("SELECT * FROM parrots_pirates WHERE pirate_id = #{@pirate.id}")
    assert join_records.empty?
  end

  def test_should_skip_validation_on_habtm_if_marked_for_destruction
    2.times { |i| @pirate.parrots.create!(name: "parrots_#{i}") }

    @pirate.parrots.each { |parrot| parrot.name = "" }
    assert !@pirate.valid?

    @pirate.parrots.each do |parrot|
      parrot.mark_for_destruction
      parrot.expects(:valid?).never
    end

    @pirate.save!
    assert @pirate.reload.parrots.empty?
  end

  def test_should_skip_validation_on_habtm_if_destroyed
    @pirate.parrots.create!(name: "parrots_1")

    @pirate.parrots.each { |parrot| parrot.name = "" }
    assert !@pirate.valid?

    @pirate.parrots.each(&:destroy)
    assert @pirate.valid?
  end

  def test_a_child_marked_for_destruction_should_not_be_destroyed_twice_while_saving_habtm
    @pirate.parrots.create!(name: "parrots_1")

    @pirate.parrots.each(&:mark_for_destruction)
    assert @pirate.save

    Pirate.transaction do
      assert_queries(0) do
        assert @pirate.save
      end
    end
  end

  def test_should_rollback_destructions_if_an_exception_occurred_while_saving_habtm
    2.times { |i| @pirate.parrots.create!(name: "parrots_#{i}") }
    before = @pirate.parrots.map { |c| c.mark_for_destruction ; c }

    class << @pirate.association(:parrots)
      def destroy(*args)
        super
        raise "Oh noes!"
      end
    end

    assert_raise(RuntimeError) { assert !@pirate.save }
    assert_equal before, @pirate.reload.parrots
  end

  # Add and remove callbacks tests for association collections.
  %w{ method proc }.each do |callback_type|
    define_method("test_should_run_add_callback_#{callback_type}s_for_habtm") do
      association_name_with_callbacks = "parrots_with_#{callback_type}_callbacks"

      pirate = Pirate.new(catchphrase: "Arr")
      pirate.send(association_name_with_callbacks).build(name: "Crowe the One-Eyed")

      expected = [
        "before_adding_#{callback_type}_parrot_<new>",
        "after_adding_#{callback_type}_parrot_<new>"
      ]

      assert_equal expected, pirate.ship_log
    end

    define_method("test_should_run_remove_callback_#{callback_type}s_for_habtm") do
      association_name_with_callbacks = "parrots_with_#{callback_type}_callbacks"

      @pirate.send(association_name_with_callbacks).create!(name: "Crowe the One-Eyed")
      @pirate.send(association_name_with_callbacks).each(&:mark_for_destruction)
      child_id = @pirate.send(association_name_with_callbacks).first.id

      @pirate.ship_log.clear
      @pirate.save

      expected = [
        "before_removing_#{callback_type}_parrot_#{child_id}",
        "after_removing_#{callback_type}_parrot_#{child_id}"
      ]

      assert_equal expected, @pirate.ship_log
    end
  end
end

class TestAutosaveAssociationOnAHasOneAssociation < ActiveRecord::TestCase
  self.use_transactional_tests = false unless supports_savepoints?

  def setup
    super
    @pirate = Pirate.create(catchphrase: "Don' botharrr talkin' like one, savvy?")
    @ship = @pirate.create_ship(name: "Nights Dirty Lightning")
  end

  def test_should_still_work_without_an_associated_model
    @ship.destroy
    @pirate.reload.catchphrase = "Arr"
    @pirate.save
    assert_equal "Arr", @pirate.reload.catchphrase
  end

  def test_should_automatically_save_the_associated_model
    @pirate.ship.name = "The Vile Insanity"
    @pirate.save
    assert_equal "The Vile Insanity", @pirate.reload.ship.name
  end

  def test_changed_for_autosave_should_handle_cycles
    @ship.pirate = @pirate
    assert_queries(0) { @ship.save! }

    @parrot = @pirate.parrots.create(name: "some_name")
    @parrot.name="changed_name"
    assert_queries(1) { @ship.save! }
    assert_queries(0) { @ship.save! }
  end

  def test_should_automatically_save_bang_the_associated_model
    @pirate.ship.name = "The Vile Insanity"
    @pirate.save!
    assert_equal "The Vile Insanity", @pirate.reload.ship.name
  end

  def test_should_automatically_validate_the_associated_model
    @pirate.ship.name = ""
    assert @pirate.invalid?
    assert @pirate.errors[:"ship.name"].any?
  end

  def test_should_merge_errors_on_the_associated_models_onto_the_parent_even_if_it_is_not_valid
    @pirate.ship.name   = nil
    @pirate.catchphrase = nil
    assert @pirate.invalid?
    assert @pirate.errors[:"ship.name"].any?
    assert @pirate.errors[:catchphrase].any?
  end

  def test_should_not_ignore_different_error_messages_on_the_same_attribute
    old_validators = Ship._validators.deep_dup
    old_callbacks = Ship._validate_callbacks.deep_dup
    Ship.validates_format_of :name, with: /\w/
    @pirate.ship.name   = ""
    @pirate.catchphrase = nil
    assert @pirate.invalid?
    assert_equal ["can't be blank", "is invalid"], @pirate.errors[:"ship.name"]
  ensure
    Ship._validators = old_validators if old_validators
    Ship._validate_callbacks = old_callbacks if old_callbacks
  end

  def test_should_still_allow_to_bypass_validations_on_the_associated_model
    @pirate.catchphrase = ""
    @pirate.ship.name = ""
    @pirate.save(validate: false)
    # Oracle saves empty string as NULL
    if current_adapter?(:OracleAdapter)
      assert_equal [nil, nil], [@pirate.reload.catchphrase, @pirate.ship.name]
    else
      assert_equal ["", ""], [@pirate.reload.catchphrase, @pirate.ship.name]
    end
  end

  def test_should_allow_to_bypass_validations_on_associated_models_at_any_depth
    2.times { |i| @pirate.ship.parts.create!(name: "part #{i}") }

    @pirate.catchphrase = ""
    @pirate.ship.name = ""
    @pirate.ship.parts.each { |part| part.name = "" }
    @pirate.save(validate: false)

    values = [@pirate.reload.catchphrase, @pirate.ship.name, *@pirate.ship.parts.map(&:name)]
    # Oracle saves empty string as NULL
    if current_adapter?(:OracleAdapter)
      assert_equal [nil, nil, nil, nil], values
    else
      assert_equal ["", "", "", ""], values
    end
  end

  def test_should_still_raise_an_ActiveRecordRecord_Invalid_exception_if_we_want_that
    @pirate.ship.name = ""
    assert_raise(ActiveRecord::RecordInvalid) do
      @pirate.save!
    end
  end

  def test_should_not_save_and_return_false_if_a_callback_cancelled_saving
    pirate = Pirate.new(catchphrase: "Arr")
    ship = pirate.build_ship(name: "The Vile Insanity")
    ship.cancel_save_from_callback = true

    assert_no_difference "Pirate.count" do
      assert_no_difference "Ship.count" do
        assert !pirate.save
      end
    end
  end

  def test_should_rollback_any_changes_if_an_exception_occurred_while_saving
    before = [@pirate.catchphrase, @pirate.ship.name]

    @pirate.catchphrase = "Arr"
    @pirate.ship.name = "The Vile Insanity"

    # Stub the save method of the @pirate.ship instance to raise an exception
    class << @pirate.ship
      def save(*args)
        super
        raise "Oh noes!"
      end
    end

    assert_raise(RuntimeError) { assert !@pirate.save }
    assert_equal before, [@pirate.reload.catchphrase, @pirate.ship.name]
  end

  def test_should_not_load_the_associated_model
    assert_queries(1) { @pirate.catchphrase = "Arr"; @pirate.save! }
  end

  def test_mark_for_destruction_is_ignored_without_autosave_true
    ship = ShipWithoutNestedAttributes.new(name: "The Black Flag")
    ship.parts.build.mark_for_destruction

    assert_not ship.valid?
  end
end

class TestAutosaveAssociationOnAHasOneThroughAssociation < ActiveRecord::TestCase
  self.use_transactional_tests = false unless supports_savepoints?

  def setup
    super
    organization = Organization.create
    @member = Member.create
    MemberDetail.create(organization: organization, member: @member)
  end

  def test_should_not_has_one_through_model
    class << @member.organization
      def save(*args)
        super
        raise "Oh noes!"
      end
    end
    assert_nothing_raised { @member.save }
  end
end

class TestAutosaveAssociationOnABelongsToAssociation < ActiveRecord::TestCase
  self.use_transactional_tests = false unless supports_savepoints?

  def setup
    super
    @ship = Ship.create(name: "Nights Dirty Lightning")
    @pirate = @ship.create_pirate(catchphrase: "Don' botharrr talkin' like one, savvy?")
  end

  def test_should_still_work_without_an_associated_model
    @pirate.destroy
    @ship.reload.name = "The Vile Insanity"
    @ship.save
    assert_equal "The Vile Insanity", @ship.reload.name
  end

  def test_should_automatically_save_the_associated_model
    @ship.pirate.catchphrase = "Arr"
    @ship.save
    assert_equal "Arr", @ship.reload.pirate.catchphrase
  end

  def test_should_automatically_save_bang_the_associated_model
    @ship.pirate.catchphrase = "Arr"
    @ship.save!
    assert_equal "Arr", @ship.reload.pirate.catchphrase
  end

  def test_should_automatically_validate_the_associated_model
    @ship.pirate.catchphrase = ""
    assert @ship.invalid?
    assert @ship.errors[:"pirate.catchphrase"].any?
  end

  def test_should_merge_errors_on_the_associated_model_onto_the_parent_even_if_it_is_not_valid
    @ship.name = nil
    @ship.pirate.catchphrase = nil
    assert @ship.invalid?
    assert @ship.errors[:name].any?
    assert @ship.errors[:"pirate.catchphrase"].any?
  end

  def test_should_still_allow_to_bypass_validations_on_the_associated_model
    @ship.pirate.catchphrase = ""
    @ship.name = ""
    @ship.save(validate: false)
    # Oracle saves empty string as NULL
    if current_adapter?(:OracleAdapter)
      assert_equal [nil, nil], [@ship.reload.name, @ship.pirate.catchphrase]
    else
      assert_equal ["", ""], [@ship.reload.name, @ship.pirate.catchphrase]
    end
  end

  def test_should_still_raise_an_ActiveRecordRecord_Invalid_exception_if_we_want_that
    @ship.pirate.catchphrase = ""
    assert_raise(ActiveRecord::RecordInvalid) do
      @ship.save!
    end
  end

  def test_should_not_save_and_return_false_if_a_callback_cancelled_saving
    ship = Ship.new(name: "The Vile Insanity")
    pirate = ship.build_pirate(catchphrase: "Arr")
    pirate.cancel_save_from_callback = true

    assert_no_difference "Ship.count" do
      assert_no_difference "Pirate.count" do
        assert !ship.save
      end
    end
  end

  def test_should_rollback_any_changes_if_an_exception_occurred_while_saving
    before = [@ship.pirate.catchphrase, @ship.name]

    @ship.pirate.catchphrase = "Arr"
    @ship.name = "The Vile Insanity"

    # Stub the save method of the @ship.pirate instance to raise an exception
    class << @ship.pirate
      def save(*args)
        super
        raise "Oh noes!"
      end
    end

    assert_raise(RuntimeError) { assert !@ship.save }
    assert_equal before, [@ship.pirate.reload.catchphrase, @ship.reload.name]
  end

  def test_should_not_load_the_associated_model
    assert_queries(1) { @ship.name = "The Vile Insanity"; @ship.save! }
  end
end

module AutosaveAssociationOnACollectionAssociationTests
  def test_should_automatically_save_the_associated_models
    new_names = ["Grace OMalley", "Privateers Greed"]
    @pirate.send(@association_name).each_with_index { |child, i| child.name = new_names[i] }

    @pirate.save
    assert_equal new_names, @pirate.reload.send(@association_name).map(&:name)
  end

  def test_should_automatically_save_bang_the_associated_models
    new_names = ["Grace OMalley", "Privateers Greed"]
    @pirate.send(@association_name).each_with_index { |child, i| child.name = new_names[i] }

    @pirate.save!
    assert_equal new_names, @pirate.reload.send(@association_name).map(&:name)
  end

  def test_should_update_children_when_autosave_is_true_and_parent_is_new_but_child_is_not
    parrot = Parrot.create!(name: "Polly")
    parrot.name = "Squawky"
    pirate = Pirate.new(parrots: [parrot], catchphrase: "Arrrr")

    pirate.save!

    assert_equal "Squawky", parrot.reload.name
  end

  def test_should_automatically_validate_the_associated_models
    @pirate.send(@association_name).each { |child| child.name = "" }

    assert !@pirate.valid?
    assert_equal ["can't be blank"], @pirate.errors["#{@association_name}.name"]
    assert @pirate.errors[@association_name].empty?
  end

  def test_should_not_use_default_invalid_error_on_associated_models
    @pirate.send(@association_name).build(name: "")

    assert !@pirate.valid?
    assert_equal ["can't be blank"], @pirate.errors["#{@association_name}.name"]
    assert @pirate.errors[@association_name].empty?
  end

  def test_should_default_invalid_error_from_i18n
    I18n.backend.store_translations(:en, activerecord: {errors: { models:
      { @associated_model_name.to_s.to_sym => { blank: "cannot be blank" } }
    }})

    @pirate.send(@association_name).build(name: "")

    assert !@pirate.valid?
    assert_equal ["cannot be blank"], @pirate.errors["#{@association_name}.name"]
    assert_equal ["#{@association_name.to_s.humanize} name cannot be blank"], @pirate.errors.full_messages
    assert @pirate.errors[@association_name].empty?
  ensure
    I18n.backend = I18n::Backend::Simple.new
  end

  def test_should_merge_errors_on_the_associated_models_onto_the_parent_even_if_it_is_not_valid
    @pirate.send(@association_name).each { |child| child.name = "" }
    @pirate.catchphrase = nil

    assert !@pirate.valid?
    assert_equal ["can't be blank"], @pirate.errors["#{@association_name}.name"]
    assert @pirate.errors[:catchphrase].any?
  end

  def test_should_allow_to_bypass_validations_on_the_associated_models_on_update
    @pirate.catchphrase = ""
    @pirate.send(@association_name).each { |child| child.name = "" }

    assert @pirate.save(validate: false)
    # Oracle saves empty string as NULL
    if current_adapter?(:OracleAdapter)
      assert_equal [nil, nil, nil], [
        @pirate.reload.catchphrase,
        @pirate.send(@association_name).first.name,
        @pirate.send(@association_name).last.name
      ]
    else
      assert_equal ["", "", ""], [
        @pirate.reload.catchphrase,
        @pirate.send(@association_name).first.name,
        @pirate.send(@association_name).last.name
      ]
    end
  end

  def test_should_validation_the_associated_models_on_create
    assert_no_difference("#{ @association_name == :birds ? 'Bird' : 'Parrot' }.count") do
      2.times { @pirate.send(@association_name).build }
      @pirate.save
    end
  end

  def test_should_allow_to_bypass_validations_on_the_associated_models_on_create
    assert_difference("#{ @association_name == :birds ? 'Bird' : 'Parrot' }.count", 2) do
      2.times { @pirate.send(@association_name).build }
      @pirate.save(validate: false)
    end
  end

  def test_should_not_save_and_return_false_if_a_callback_cancelled_saving_in_either_create_or_update
    @pirate.catchphrase = "Changed"
    @child_1.name = "Changed"
    @child_1.cancel_save_from_callback = true

    assert !@pirate.save
    assert_equal "Don' botharrr talkin' like one, savvy?", @pirate.reload.catchphrase
    assert_equal "Posideons Killer", @child_1.reload.name

    new_pirate = Pirate.new(catchphrase: "Arr")
    new_child = new_pirate.send(@association_name).build(name: "Grace OMalley")
    new_child.cancel_save_from_callback = true

    assert_no_difference "Pirate.count" do
      assert_no_difference "#{new_child.class.name}.count" do
        assert !new_pirate.save
      end
    end
  end

  def test_should_rollback_any_changes_if_an_exception_occurred_while_saving
    before = [@pirate.catchphrase, *@pirate.send(@association_name).map(&:name)]
    new_names = ["Grace OMalley", "Privateers Greed"]

    @pirate.catchphrase = "Arr"
    @pirate.send(@association_name).each_with_index { |child, i| child.name = new_names[i] }

    # Stub the save method of the first child instance to raise an exception
    class << @pirate.send(@association_name).first
      def save(*args)
        super
        raise "Oh noes!"
      end
    end

    assert_raise(RuntimeError) { assert !@pirate.save }
    assert_equal before, [@pirate.reload.catchphrase, *@pirate.send(@association_name).map(&:name)]
  end

  def test_should_still_raise_an_ActiveRecordRecord_Invalid_exception_if_we_want_that
    @pirate.send(@association_name).each { |child| child.name = "" }
    assert_raise(ActiveRecord::RecordInvalid) do
      @pirate.save!
    end
  end

  def test_should_not_load_the_associated_models_if_they_were_not_loaded_yet
    assert_queries(1) { @pirate.catchphrase = "Arr"; @pirate.save! }

    @pirate.send(@association_name).load_target

    assert_queries(3) do
      @pirate.catchphrase = "Yarr"
      new_names = ["Grace OMalley", "Privateers Greed"]
      @pirate.send(@association_name).each_with_index { |child, i| child.name = new_names[i] }
      @pirate.save!
    end
  end
end

class TestAutosaveAssociationOnAHasManyAssociation < ActiveRecord::TestCase
  self.use_transactional_tests = false unless supports_savepoints?

  def setup
    super
    @association_name = :birds
    @associated_model_name = :bird

    @pirate = Pirate.create(catchphrase: "Don' botharrr talkin' like one, savvy?")
    @child_1 = @pirate.birds.create(name: "Posideons Killer")
    @child_2 = @pirate.birds.create(name: "Killer bandita Dionne")
  end

  include AutosaveAssociationOnACollectionAssociationTests
end

class TestAutosaveAssociationOnAHasAndBelongsToManyAssociation < ActiveRecord::TestCase
  self.use_transactional_tests = false unless supports_savepoints?

  def setup
    super
    @association_name = :autosaved_parrots
    @associated_model_name = :parrot
    @habtm = true

    @pirate = Pirate.create(catchphrase: "Don' botharrr talkin' like one, savvy?")
    @child_1 = @pirate.parrots.create(name: "Posideons Killer")
    @child_2 = @pirate.parrots.create(name: "Killer bandita Dionne")
  end

  include AutosaveAssociationOnACollectionAssociationTests
end

class TestAutosaveAssociationOnAHasAndBelongsToManyAssociationWithAcceptsNestedAttributes < ActiveRecord::TestCase
  self.use_transactional_tests = false unless supports_savepoints?

  def setup
    super
    @association_name = :parrots
    @associated_model_name = :parrot
    @habtm = true

    @pirate = Pirate.create(catchphrase: "Don' botharrr talkin' like one, savvy?")
    @child_1 = @pirate.parrots.create(name: "Posideons Killer")
    @child_2 = @pirate.parrots.create(name: "Killer bandita Dionne")
  end

  include AutosaveAssociationOnACollectionAssociationTests
end

class TestAutosaveAssociationValidationsOnAHasManyAssociation < ActiveRecord::TestCase
  self.use_transactional_tests = false unless supports_savepoints?

  def setup
    super
    @pirate = Pirate.create(catchphrase: "Don' botharrr talkin' like one, savvy?")
    @pirate.birds.create(name: "cookoo")
  end

  test "should automatically validate associations" do
    assert @pirate.valid?
    @pirate.birds.each { |bird| bird.name = "" }

    assert !@pirate.valid?
  end
end

class TestAutosaveAssociationValidationsOnAHasOneAssociation < ActiveRecord::TestCase
  self.use_transactional_tests = false unless supports_savepoints?

  def setup
    super
    @pirate = Pirate.create(catchphrase: "Don' botharrr talkin' like one, savvy?")
    @pirate.create_ship(name: "titanic")
    super
  end

  test "should automatically validate associations with :validate => true" do
    assert @pirate.valid?
    @pirate.ship.name = ""
    assert !@pirate.valid?
  end

  test "should not automatically add validate associations without :validate => true" do
    assert @pirate.valid?
    @pirate.non_validated_ship.name = ""
    assert @pirate.valid?
  end
end

class TestAutosaveAssociationValidationsOnABelongsToAssociation < ActiveRecord::TestCase
  self.use_transactional_tests = false unless supports_savepoints?

  def setup
    super
    @pirate = Pirate.create(catchphrase: "Don' botharrr talkin' like one, savvy?")
  end

  test "should automatically validate associations with :validate => true" do
    assert @pirate.valid?
    @pirate.parrot = Parrot.new(name: "")
    assert !@pirate.valid?
  end

  test "should not automatically validate associations without :validate => true" do
    assert @pirate.valid?
    @pirate.non_validated_parrot = Parrot.new(name: "")
    assert @pirate.valid?
  end
end

class TestAutosaveAssociationValidationsOnAHABTMAssociation < ActiveRecord::TestCase
  self.use_transactional_tests = false unless supports_savepoints?

  def setup
    super
    @pirate = Pirate.create(catchphrase: "Don' botharrr talkin' like one, savvy?")
  end

  test "should automatically validate associations with :validate => true" do
    assert @pirate.valid?
    @pirate.parrots = [ Parrot.new(name: "popuga") ]
    @pirate.parrots.each { |parrot| parrot.name = "" }
    assert !@pirate.valid?
  end

  test "should not automatically validate associations without :validate => true" do
    assert @pirate.valid?
    @pirate.non_validated_parrots = [ Parrot.new(name: "popuga") ]
    @pirate.non_validated_parrots.each { |parrot| parrot.name = "" }
    assert @pirate.valid?
  end
end

class TestAutosaveAssociationValidationMethodsGeneration < ActiveRecord::TestCase
  self.use_transactional_tests = false unless supports_savepoints?

  def setup
    super
    @pirate = Pirate.new
  end

  test "should generate validation methods for has_many associations" do
    assert_respond_to @pirate, :validate_associated_records_for_birds
  end

  test "should generate validation methods for has_one associations with :validate => true" do
    assert_respond_to @pirate, :validate_associated_records_for_ship
  end

  test "should not generate validation methods for has_one associations without :validate => true" do
    assert !@pirate.respond_to?(:validate_associated_records_for_non_validated_ship)
  end

  test "should generate validation methods for belongs_to associations with :validate => true" do
    assert_respond_to @pirate, :validate_associated_records_for_parrot
  end

  test "should not generate validation methods for belongs_to associations without :validate => true" do
    assert !@pirate.respond_to?(:validate_associated_records_for_non_validated_parrot)
  end

  test "should generate validation methods for HABTM associations with :validate => true" do
    assert_respond_to @pirate, :validate_associated_records_for_parrots
  end
end

class TestAutosaveAssociationWithTouch < ActiveRecord::TestCase
  def test_autosave_with_touch_should_not_raise_system_stack_error
    invoice = Invoice.create
    assert_nothing_raised { invoice.line_items.create(amount: 10) }
  end
end
require "backburner"

module ActiveJob
  module QueueAdapters
    # == Backburner adapter for Active Job
    #
    # Backburner is a beanstalkd-powered job queue that can handle a very
    # high volume of jobs. You create background jobs and place them on
    # multiple work queues to be processed later. Read more about
    # Backburner {here}[https://github.com/nesquena/backburner].
    #
    # To use Backburner set the queue_adapter config to +:backburner+.
    #
    #   Rails.application.config.active_job.queue_adapter = :backburner
    class BackburnerAdapter
      def enqueue(job) #:nodoc:
        Backburner::Worker.enqueue JobWrapper, [ job.serialize ], queue: job.queue_name
      end

      def enqueue_at(job, timestamp) #:nodoc:
        delay = timestamp - Time.current.to_f
        Backburner::Worker.enqueue JobWrapper, [ job.serialize ], queue: job.queue_name, delay: delay
      end

      class JobWrapper #:nodoc:
        class << self
          def perform(job_data)
            Base.execute job_data
          end
        end
      end
    end
  end
end
require "support/backburner/inline"

ActiveJob::Base.queue_adapter = :backburner
module ActiveSupport
  # Backtraces often include many lines that are not relevant for the context
  # under review. This makes it hard to find the signal amongst the backtrace
  # noise, and adds debugging time. With a BacktraceCleaner, filters and
  # silencers are used to remove the noisy lines, so that only the most relevant
  # lines remain.
  #
  # Filters are used to modify lines of data, while silencers are used to remove
  # lines entirely. The typical filter use case is to remove lengthy path
  # information from the start of each line, and view file paths relevant to the
  # app directory instead of the file system root. The typical silencer use case
  # is to exclude the output of a noisy library from the backtrace, so that you
  # can focus on the rest.
  #
  #   bc = BacktraceCleaner.new
  #   bc.add_filter   { |line| line.gsub(Rails.root.to_s, '') } # strip the Rails.root prefix
  #   bc.add_silencer { |line| line =~ /mongrel|rubygems/ } # skip any lines from mongrel or rubygems
  #   bc.clean(exception.backtrace) # perform the cleanup
  #
  # To reconfigure an existing BacktraceCleaner (like the default one in Rails)
  # and show as much data as possible, you can always call
  # <tt>BacktraceCleaner#remove_silencers!</tt>, which will restore the
  # backtrace to a pristine state. If you need to reconfigure an existing
  # BacktraceCleaner so that it does not filter or modify the paths of any lines
  # of the backtrace, you can call <tt>BacktraceCleaner#remove_filters!</tt>
  # These two methods will give you a completely untouched backtrace.
  #
  # Inspired by the Quiet Backtrace gem by thoughtbot.
  class BacktraceCleaner
    def initialize
      @filters, @silencers = [], []
    end

    # Returns the backtrace after all filters and silencers have been run
    # against it. Filters run first, then silencers.
    def clean(backtrace, kind = :silent)
      filtered = filter_backtrace(backtrace)

      case kind
      when :silent
        silence(filtered)
      when :noise
        noise(filtered)
      else
        filtered
      end
    end
    alias :filter :clean

    # Adds a filter from the block provided. Each line in the backtrace will be
    # mapped against this filter.
    #
    #   # Will turn "/my/rails/root/app/models/person.rb" into "/app/models/person.rb"
    #   backtrace_cleaner.add_filter { |line| line.gsub(Rails.root, '') }
    def add_filter(&block)
      @filters << block
    end

    # Adds a silencer from the block provided. If the silencer returns +true+
    # for a given line, it will be excluded from the clean backtrace.
    #
    #   # Will reject all lines that include the word "mongrel", like "/gems/mongrel/server.rb" or "/app/my_mongrel_server/rb"
    #   backtrace_cleaner.add_silencer { |line| line =~ /mongrel/ }
    def add_silencer(&block)
      @silencers << block
    end

    # Removes all silencers, but leaves in the filters. Useful if your
    # context of debugging suddenly expands as you suspect a bug in one of
    # the libraries you use.
    def remove_silencers!
      @silencers = []
    end

    # Removes all filters, but leaves in the silencers. Useful if you suddenly
    # need to see entire filepaths in the backtrace that you had already
    # filtered out.
    def remove_filters!
      @filters = []
    end

    private
      def filter_backtrace(backtrace)
        @filters.each do |f|
          backtrace = backtrace.map { |line| f.call(line) }
        end

        backtrace
      end

      def silence(backtrace)
        @silencers.each do |s|
          backtrace = backtrace.reject { |line| s.call(line) }
        end

        backtrace
      end

      def noise(backtrace)
        backtrace - silence(backtrace)
      end
  end
end
require "abstract_unit"
require "rails/backtrace_cleaner"

class BacktraceCleanerTest < ActiveSupport::TestCase
  def setup
    @cleaner = Rails::BacktraceCleaner.new
  end

  test "should format installed gems correctly" do
    backtrace = [ "#{Gem.path[0]}/gems/nosuchgem-1.2.3/lib/foo.rb" ]
    result = @cleaner.clean(backtrace, :all)
    assert_equal "nosuchgem (1.2.3) lib/foo.rb", result[0]
  end

  test "should format installed gems not in Gem.default_dir correctly" do
    target_dir = Gem.path.detect { |p| p != Gem.default_dir }
    # skip this test if default_dir is the only directory on Gem.path
    if @target_dir
      backtrace = [ "#{target_dir}/gems/nosuchgem-1.2.3/lib/foo.rb" ]
      result = @cleaner.clean(backtrace, :all)
      assert_equal "nosuchgem (1.2.3) lib/foo.rb", result[0]
    end
  end

  test "should consider traces from irb lines as User code" do
    backtrace = [ "from (irb):1",
                  "from /Path/to/rails/railties/lib/rails/commands/console.rb:77:in `start'",
                  "from bin/rails:4:in `<main>'" ]
    result = @cleaner.clean(backtrace, :all)
    assert_equal "from (irb):1", result[0]
  end
end
# Be sure to restart your server when you modify this file.

# You can add backtrace silencers for libraries that you're using but don't wish to see in your backtraces.
# Rails.backtrace_cleaner.add_silencer { |line| line =~ /my_noisy_library/ }

# You can also remove all the silencers if you're trying to debug a problem that might stem from framework code.
# Rails.backtrace_cleaner.remove_silencers!
require "abstract_unit"

module BareMetalTest
  class BareController < ActionController::Metal
    def index
      self.response_body = "Hello world"
    end
  end

  class BareTest < ActiveSupport::TestCase
    test "response body is a Rack-compatible response" do
      status, headers, body = BareController.action(:index).call(Rack::MockRequest.env_for("/"))
      assert_equal 200, status
      string = ""

      body.each do |part|
        assert part.is_a?(String), "Each part of the body must be a String"
        string << part
      end

      assert_kind_of Hash, headers, "Headers must be a Hash"
      assert headers["Content-Type"], "Content-Type must exist"

      assert_equal "Hello world", string
    end

    test "response_body value is wrapped in an array when the value is a String" do
      controller = BareController.new
      controller.set_request!(ActionDispatch::Request.empty)
      controller.set_response!(BareController.make_response!(controller.request))
      controller.index
      assert_equal ["Hello world"], controller.response_body
    end

    test "connect a request to controller instance without dispatch" do
      env = {}
      controller = BareController.new
      controller.set_request! ActionDispatch::Request.new(env)
      assert controller.request
    end
  end

  class BareEmptyController < ActionController::Metal
    def index
      self.response_body = nil
    end
  end

  class BareEmptyTest < ActiveSupport::TestCase
    test "response body is nil" do
      controller = BareEmptyController.new
      controller.set_request!(ActionDispatch::Request.empty)
      controller.set_response!(BareController.make_response!(controller.request))
      controller.index
      assert_equal nil, controller.response_body
    end
  end

  class HeadController < ActionController::Metal
    include ActionController::Head

    def index
      head :not_found
    end

    def continue
      self.content_type = "text/html"
      head 100
    end

    def switching_protocols
      self.content_type = "text/html"
      head 101
    end

    def processing
      self.content_type = "text/html"
      head 102
    end

    def no_content
      self.content_type = "text/html"
      head 204
    end

    def reset_content
      self.content_type = "text/html"
      head 205
    end

    def not_modified
      self.content_type = "text/html"
      head 304
    end
  end

  class HeadTest < ActiveSupport::TestCase
    test "head works on its own" do
      status = HeadController.action(:index).call(Rack::MockRequest.env_for("/")).first
      assert_equal 404, status
    end

    test "head :continue (100) does not return a content-type header" do
      headers = HeadController.action(:continue).call(Rack::MockRequest.env_for("/")).second
      assert_nil headers["Content-Type"]
      assert_nil headers["Content-Length"]
    end

    test "head :switching_protocols (101) does not return a content-type header" do
      headers = HeadController.action(:switching_protocols).call(Rack::MockRequest.env_for("/")).second
      assert_nil headers["Content-Type"]
      assert_nil headers["Content-Length"]
    end

    test "head :processing (102) does not return a content-type header" do
      headers = HeadController.action(:processing).call(Rack::MockRequest.env_for("/")).second
      assert_nil headers["Content-Type"]
      assert_nil headers["Content-Length"]
    end

    test "head :no_content (204) does not return a content-type header" do
      headers = HeadController.action(:no_content).call(Rack::MockRequest.env_for("/")).second
      assert_nil headers["Content-Type"]
      assert_nil headers["Content-Length"]
    end

    test "head :reset_content (205) does not return a content-type header" do
      headers = HeadController.action(:reset_content).call(Rack::MockRequest.env_for("/")).second
      assert_nil headers["Content-Type"]
      assert_nil headers["Content-Length"]
    end

    test "head :not_modified (304) does not return a content-type header" do
      headers = HeadController.action(:not_modified).call(Rack::MockRequest.env_for("/")).second
      assert_nil headers["Content-Type"]
      assert_nil headers["Content-Length"]
    end

    test "head :no_content (204) does not return any content" do
      content = body(HeadController.action(:no_content).call(Rack::MockRequest.env_for("/")))
      assert_empty content
    end

    test "head :reset_content (205) does not return any content" do
      content = body(HeadController.action(:reset_content).call(Rack::MockRequest.env_for("/")))
      assert_empty content
    end

    test "head :not_modified (304) does not return any content" do
      content = body(HeadController.action(:not_modified).call(Rack::MockRequest.env_for("/")))
      assert_empty content
    end

    test "head :continue (100) does not return any content" do
      content = body(HeadController.action(:continue).call(Rack::MockRequest.env_for("/")))
      assert_empty content
    end

    test "head :switching_protocols (101) does not return any content" do
      content = body(HeadController.action(:switching_protocols).call(Rack::MockRequest.env_for("/")))
      assert_empty content
    end

    test "head :processing (102) does not return any content" do
      content = body(HeadController.action(:processing).call(Rack::MockRequest.env_for("/")))
      assert_empty content
    end

    def body(rack_response)
      buf = []
      rack_response[2].each { |x| buf << x }
      buf.join
    end
  end

  class BareControllerTest < ActionController::TestCase
    test "GET index" do
      get :index
      assert_equal "Hello world", @response.body
    end
  end
end
module ActiveRecord
  class PredicateBuilder
    class BaseHandler # :nodoc:
      def initialize(predicate_builder)
        @predicate_builder = predicate_builder
      end

      def call(attribute, value)
        predicate_builder.build(attribute, value.id)
      end

      protected

        attr_reader :predicate_builder
    end
  end
end
class BaseMailer < ActionMailer::Base
  self.mailer_name = "base_mailer"

  default to: "system@test.lindsaar.net",
          from: "jose@test.plataformatec.com",
          reply_to: "mikel@test.lindsaar.net"

  def welcome(hash = {})
    headers["X-SPAM"] = "Not SPAM"
    mail({subject: "The first email on new API!"}.merge!(hash))
  end

  def welcome_with_headers(hash = {})
    headers hash
    mail
  end

  def welcome_from_another_path(path)
    mail(template_name: "welcome", template_path: path)
  end

  def html_only(hash = {})
    mail(hash)
  end

  def plain_text_only(hash = {})
    mail(hash)
  end

  def inline_attachment
    attachments.inline["logo.png"] = "\312\213\254\232"
    mail
  end

  def attachment_with_content(hash = {})
    attachments["invoice.pdf"] = "This is test File content"
    mail(hash)
  end

  def attachment_with_hash
    attachments["invoice.jpg"] = { data: ::Base64.encode64("\312\213\254\232)b"),
                                   mime_type: "image/x-jpg",
                                   transfer_encoding: "base64" }
    mail
  end

  def attachment_with_hash_default_encoding
    attachments["invoice.jpg"] = { data: "\312\213\254\232)b",
                                   mime_type: "image/x-jpg" }
    mail
  end

  def implicit_multipart(hash = {})
    attachments["invoice.pdf"] = "This is test File content" if hash.delete(:attachments)
    mail(hash)
  end

  def implicit_with_locale(hash = {})
    mail(hash)
  end

  def explicit_multipart(hash = {})
    attachments["invoice.pdf"] = "This is test File content" if hash.delete(:attachments)
    mail(hash) do |format|
      format.text { render text: "TEXT Explicit Multipart" }
      format.html { render text: "HTML Explicit Multipart" }
    end
  end

  def explicit_multipart_templates(hash = {})
    mail(hash) do |format|
      format.html
      format.text
    end
  end

  def explicit_multipart_with_any(hash = {})
    mail(hash) do |format|
      format.any(:text, :html){ render text: "Format with any!" }
    end
  end

  def explicit_without_specifying_format_with_any(hash = {})
    mail(hash) do |format|
      format.any
    end
  end

  def explicit_multipart_with_options(include_html = false)
    mail do |format|
      format.text(content_transfer_encoding: "base64"){ render "welcome" }
      format.html{ render "welcome" } if include_html
    end
  end

  def explicit_multipart_with_one_template(hash = {})
    mail(hash) do |format|
      format.html
      format.text
    end
  end

  def implicit_different_template(template_name="")
    mail(template_name: template_name)
  end

  def explicit_different_template(template_name="")
    mail do |format|
      format.text { render template: "#{mailer_name}/#{template_name}" }
      format.html { render template: "#{mailer_name}/#{template_name}" }
    end
  end

  def different_layout(layout_name="")
    mail do |format|
      format.text { render layout: layout_name }
      format.html { render layout: layout_name }
    end
  end

  def email_with_translations
    mail body: render("email_with_translations", formats: [:html])
  end

  def without_mail_call
  end

  def with_nil_as_return_value
    mail(template_name: "welcome")
    nil
  end

  def with_subject_interpolations
    mail(subject: default_i18n_subject(rapper_or_impersonator: "Slim Shady"), body: "")
  end
end
require "erubis"
require "abstract_controller/error"
require "active_support/configurable"
require "active_support/descendants_tracker"
require "active_support/core_ext/module/anonymous"
require "active_support/core_ext/module/attr_internal"

module AbstractController
  # Raised when a non-existing controller action is triggered.
  class ActionNotFound < StandardError
  end

  # AbstractController::Base is a low-level API. Nobody should be
  # using it directly, and subclasses (like ActionController::Base) are
  # expected to provide their own +render+ method, since rendering means
  # different things depending on the context.
  class Base
    attr_internal :response_body
    attr_internal :action_name
    attr_internal :formats

    include ActiveSupport::Configurable
    extend ActiveSupport::DescendantsTracker

    undef_method :not_implemented
    class << self
      attr_reader :abstract
      alias_method :abstract?, :abstract

      # Define a controller as abstract. See internal_methods for more
      # details.
      def abstract!
        @abstract = true
      end

      def inherited(klass) # :nodoc:
        # Define the abstract ivar on subclasses so that we don't get
        # uninitialized ivar warnings
        unless klass.instance_variable_defined?(:@abstract)
          klass.instance_variable_set(:@abstract, false)
        end
        super
      end

      # A list of all internal methods for a controller. This finds the first
      # abstract superclass of a controller, and gets a list of all public
      # instance methods on that abstract class. Public instance methods of
      # a controller would normally be considered action methods, so methods
      # declared on abstract classes are being removed.
      # (<tt>ActionController::Metal</tt> and ActionController::Base are defined as abstract)
      def internal_methods
        controller = self

        controller = controller.superclass until controller.abstract?
        controller.public_instance_methods(true)
      end

      # A list of method names that should be considered actions. This
      # includes all public instance methods on a controller, less
      # any internal methods (see internal_methods), adding back in
      # any methods that are internal, but still exist on the class
      # itself.
      #
      # ==== Returns
      # * <tt>Set</tt> - A set of all methods that should be considered actions.
      def action_methods
        @action_methods ||= begin
          # All public instance methods of this class, including ancestors
          methods = (public_instance_methods(true) -
            # Except for public instance methods of Base and its ancestors
            internal_methods +
            # Be sure to include shadowed public instance methods of this class
            public_instance_methods(false)).uniq.map(&:to_s)

          methods.to_set
        end
      end

      # action_methods are cached and there is sometimes a need to refresh
      # them. ::clear_action_methods! allows you to do that, so next time
      # you run action_methods, they will be recalculated.
      def clear_action_methods!
        @action_methods = nil
      end

      # Returns the full controller name, underscored, without the ending Controller.
      #
      #   class MyApp::MyPostsController < AbstractController::Base
      #
      #   end
      #
      #   MyApp::MyPostsController.controller_path # => "my_app/my_posts"
      #
      # ==== Returns
      # * <tt>String</tt>
      def controller_path
        @controller_path ||= name.sub(/Controller$/, "".freeze).underscore unless anonymous?
      end

      # Refresh the cached action_methods when a new action_method is added.
      def method_added(name)
        super
        clear_action_methods!
      end
    end

    abstract!

    # Calls the action going through the entire action dispatch stack.
    #
    # The actual method that is called is determined by calling
    # #method_for_action. If no method can handle the action, then an
    # AbstractController::ActionNotFound error is raised.
    #
    # ==== Returns
    # * <tt>self</tt>
    def process(action, *args)
      @_action_name = action.to_s

      unless action_name = _find_action_name(@_action_name)
        raise ActionNotFound, "The action '#{action}' could not be found for #{self.class.name}"
      end

      @_response_body = nil

      process_action(action_name, *args)
    end

    # Delegates to the class' ::controller_path
    def controller_path
      self.class.controller_path
    end

    # Delegates to the class' ::action_methods
    def action_methods
      self.class.action_methods
    end

    # Returns true if a method for the action is available and
    # can be dispatched, false otherwise.
    #
    # Notice that <tt>action_methods.include?("foo")</tt> may return
    # false and <tt>available_action?("foo")</tt> returns true because
    # this method considers actions that are also available
    # through other means, for example, implicit render ones.
    #
    # ==== Parameters
    # * <tt>action_name</tt> - The name of an action to be tested
    def available_action?(action_name)
      _find_action_name(action_name)
    end

    # Tests if a response body is set. Used to determine if the
    # +process_action+ callback needs to be terminated in
    # +AbstractController::Callbacks+.
    def performed?
      response_body
    end

    # Returns true if the given controller is capable of rendering
    # a path. A subclass of +AbstractController::Base+
    # may return false. An Email controller for example does not
    # support paths, only full URLs.
    def self.supports_path?
      true
    end

    private

      # Returns true if the name can be considered an action because
      # it has a method defined in the controller.
      #
      # ==== Parameters
      # * <tt>name</tt> - The name of an action to be tested
      #
      # :api: private
      def action_method?(name)
        self.class.action_methods.include?(name)
      end

      # Call the action. Override this in a subclass to modify the
      # behavior around processing an action. This, and not #process,
      # is the intended way to override action dispatching.
      #
      # Notice that the first argument is the method to be dispatched
      # which is *not* necessarily the same as the action name.
      def process_action(method_name, *args)
        send_action(method_name, *args)
      end

      # Actually call the method associated with the action. Override
      # this method if you wish to change how action methods are called,
      # not to add additional behavior around it. For example, you would
      # override #send_action if you want to inject arguments into the
      # method.
      alias send_action send

      # If the action name was not found, but a method called "action_missing"
      # was found, #method_for_action will return "_handle_action_missing".
      # This method calls #action_missing with the current action name.
      def _handle_action_missing(*args)
        action_missing(@_action_name, *args)
      end

      # Takes an action name and returns the name of the method that will
      # handle the action.
      #
      # It checks if the action name is valid and returns false otherwise.
      #
      # See method_for_action for more information.
      #
      # ==== Parameters
      # * <tt>action_name</tt> - An action name to find a method name for
      #
      # ==== Returns
      # * <tt>string</tt> - The name of the method that handles the action
      # * false           - No valid method name could be found.
      # Raise AbstractController::ActionNotFound.
      def _find_action_name(action_name)
        _valid_action_name?(action_name) && method_for_action(action_name)
      end

      # Takes an action name and returns the name of the method that will
      # handle the action. In normal cases, this method returns the same
      # name as it receives. By default, if #method_for_action receives
      # a name that is not an action, it will look for an #action_missing
      # method and return "_handle_action_missing" if one is found.
      #
      # Subclasses may override this method to add additional conditions
      # that should be considered an action. For instance, an HTTP controller
      # with a template matching the action name is considered to exist.
      #
      # If you override this method to handle additional cases, you may
      # also provide a method (like _handle_method_missing) to handle
      # the case.
      #
      # If none of these conditions are true, and method_for_action
      # returns nil, an AbstractController::ActionNotFound exception will be raised.
      #
      # ==== Parameters
      # * <tt>action_name</tt> - An action name to find a method name for
      #
      # ==== Returns
      # * <tt>string</tt> - The name of the method that handles the action
      # * <tt>nil</tt>    - No method name could be found.
      def method_for_action(action_name)
        if action_method?(action_name)
          action_name
        elsif respond_to?(:action_missing, true)
          "_handle_action_missing"
        end
      end

      # Checks if the action name is valid and returns false otherwise.
      def _valid_action_name?(action_name)
        !action_name.to_s.include? File::SEPARATOR
      end
  end
end
require "abstract_unit"

# Tests the controller dispatching happy path
module Dispatching
  class SimpleController < ActionController::Base
    before_action :authenticate

    def index
      render body: "success"
    end

    def modify_response_body
      self.response_body = "success"
    end

    def modify_response_body_twice
      ret = (self.response_body = "success")
      self.response_body = "#{ret}!"
    end

    def modify_response_headers
    end

    def show_actions
      render body: "actions: #{action_methods.to_a.sort.join(', ')}"
    end

    protected
      def authenticate
      end
  end

  class EmptyController < ActionController::Base ; end
  class SubEmptyController < EmptyController ; end
  class NonDefaultPathController < ActionController::Base
    def self.controller_path; "i_am_not_default"; end
  end

  module Submodule
    class ContainedEmptyController < ActionController::Base ; end
    class ContainedSubEmptyController < ContainedEmptyController ; end
    class ContainedNonDefaultPathController < ActionController::Base
      def self.controller_path; "i_am_extremely_not_default"; end
    end
  end

  class BaseTest < Rack::TestCase
    # :api: plugin
    test "simple dispatching" do
      get "/dispatching/simple/index"

      assert_body "success"
      assert_status 200
      assert_content_type "text/plain; charset=utf-8"
    end

    # :api: plugin
    test "directly modifying response body" do
      get "/dispatching/simple/modify_response_body"

      assert_body "success"
    end

    # :api: plugin
    test "directly modifying response body twice" do
      get "/dispatching/simple/modify_response_body_twice"

      assert_body "success!"
    end

    test "controller path" do
      assert_equal "dispatching/empty", EmptyController.controller_path
      assert_equal EmptyController.controller_path, EmptyController.new.controller_path
    end

    test "non-default controller path" do
      assert_equal "i_am_not_default", NonDefaultPathController.controller_path
      assert_equal NonDefaultPathController.controller_path, NonDefaultPathController.new.controller_path
    end

    test "sub controller path" do
      assert_equal "dispatching/sub_empty", SubEmptyController.controller_path
      assert_equal SubEmptyController.controller_path, SubEmptyController.new.controller_path
    end

    test "namespaced controller path" do
      assert_equal "dispatching/submodule/contained_empty", Submodule::ContainedEmptyController.controller_path
      assert_equal Submodule::ContainedEmptyController.controller_path, Submodule::ContainedEmptyController.new.controller_path
    end

    test "namespaced non-default controller path" do
      assert_equal "i_am_extremely_not_default", Submodule::ContainedNonDefaultPathController.controller_path
      assert_equal Submodule::ContainedNonDefaultPathController.controller_path, Submodule::ContainedNonDefaultPathController.new.controller_path
    end

    test "namespaced sub controller path" do
      assert_equal "dispatching/submodule/contained_sub_empty", Submodule::ContainedSubEmptyController.controller_path
      assert_equal Submodule::ContainedSubEmptyController.controller_path, Submodule::ContainedSubEmptyController.new.controller_path
    end

    test "controller name" do
      assert_equal "empty", EmptyController.controller_name
      assert_equal "contained_empty", Submodule::ContainedEmptyController.controller_name
    end

    test "non-default path controller name" do
      assert_equal "non_default_path", NonDefaultPathController.controller_name
      assert_equal "contained_non_default_path", Submodule::ContainedNonDefaultPathController.controller_name
    end

    test "sub controller name" do
      assert_equal "sub_empty", SubEmptyController.controller_name
      assert_equal "contained_sub_empty", Submodule::ContainedSubEmptyController.controller_name
    end

    test "action methods" do
      assert_equal Set.new(%w(
        index
        modify_response_headers
        modify_response_body_twice
        modify_response_body
        show_actions
      )), SimpleController.action_methods

      assert_equal Set.new, EmptyController.action_methods
      assert_equal Set.new, Submodule::ContainedEmptyController.action_methods

      get "/dispatching/simple/show_actions"
      assert_body "actions: index, modify_response_body, modify_response_body_twice, modify_response_headers, show_actions"
    end
  end
end
module ActionController
  module BasicImplicitRender # :nodoc:
    def send_action(method, *args)
      super.tap { default_render unless performed? }
    end

    def default_render(*args)
      head :no_content
    end
  end
end
module ActiveRecord
  class PredicateBuilder
    class BasicObjectHandler # :nodoc:
      def call(attribute, value)
        attribute.eq(value)
      end
    end
  end
end
module ActiveRecord
  module Batches
    class BatchEnumerator
      include Enumerable

      def initialize(of: 1000, start: nil, finish: nil, relation:) #:nodoc:
        @of       = of
        @relation = relation
        @start = start
        @finish   = finish
      end

      # Looping through a collection of records from the database (using the
      # +all+ method, for example) is very inefficient since it will try to
      # instantiate all the objects at once.
      #
      # In that case, batch processing methods allow you to work with the
      # records in batches, thereby greatly reducing memory consumption.
      #
      #   Person.in_batches.each_record do |person|
      #     person.do_awesome_stuff
      #   end
      #
      #   Person.where("age > 21").in_batches(of: 10).each_record do |person|
      #     person.party_all_night!
      #   end
      #
      # If you do not provide a block to #each_record, it will return an Enumerator
      # for chaining with other methods:
      #
      #   Person.in_batches.each_record.with_index do |person, index|
      #     person.award_trophy(index + 1)
      #   end
      def each_record
        return to_enum(:each_record) unless block_given?

        @relation.to_enum(:in_batches, of: @of, start: @start, finish: @finish, load: true).each do |relation|
          relation.records.each { |record| yield record }
        end
      end

      # Delegates #delete_all, #update_all, #destroy_all methods to each batch.
      #
      #   People.in_batches.delete_all
      #   People.where('age < 10').in_batches.destroy_all
      #   People.in_batches.update_all('age = age + 1')
      [:delete_all, :update_all, :destroy_all].each do |method|
        define_method(method) do |*args, &block|
          @relation.to_enum(:in_batches, of: @of, start: @start, finish: @finish, load: false).each do |relation|
            relation.send(method, *args, &block)
          end
        end
      end

      # Yields an ActiveRecord::Relation object for each batch of records.
      #
      #   Person.in_batches.each do |relation|
      #     relation.update_all(awesome: true)
      #   end
      def each
        enum = @relation.to_enum(:in_batches, of: @of, start: @start, finish: @finish, load: false)
        return enum.each { |relation| yield relation } if block_given?
        enum
      end
    end
  end
end
require "active_record/relation/batches/batch_enumerator"

module ActiveRecord
  module Batches
    ORDER_IGNORE_MESSAGE = "Scoped order is ignored, it's forced to be batch order."

    # Looping through a collection of records from the database
    # (using the Scoping::Named::ClassMethods.all method, for example)
    # is very inefficient since it will try to instantiate all the objects at once.
    #
    # In that case, batch processing methods allow you to work
    # with the records in batches, thereby greatly reducing memory consumption.
    #
    # The #find_each method uses #find_in_batches with a batch size of 1000 (or as
    # specified by the +:batch_size+ option).
    #
    #   Person.find_each do |person|
    #     person.do_awesome_stuff
    #   end
    #
    #   Person.where("age > 21").find_each do |person|
    #     person.party_all_night!
    #   end
    #
    # If you do not provide a block to #find_each, it will return an Enumerator
    # for chaining with other methods:
    #
    #   Person.find_each.with_index do |person, index|
    #     person.award_trophy(index + 1)
    #   end
    #
    # ==== Options
    # * <tt>:batch_size</tt> - Specifies the size of the batch. Default to 1000.
    # * <tt>:start</tt> - Specifies the primary key value to start from, inclusive of the value.
    # * <tt>:finish</tt> - Specifies the primary key value to end at, inclusive of the value.
    # * <tt>:error_on_ignore</tt> - Overrides the application config to specify if an error should be raised when
    #                               an order is present in the relation.
    #
    # Limits are honored, and if present there is no requirement for the batch
    # size, it can be less than, equal, or greater than the limit.
    #
    # The options +start+ and +finish+ are especially useful if you want
    # multiple workers dealing with the same processing queue. You can make
    # worker 1 handle all the records between id 1 and 9999 and worker 2
    # handle from 10000 and beyond by setting the +:start+ and +:finish+
    # option on each worker.
    #
    #   # Let's process from record 10_000 on.
    #   Person.find_each(start: 10_000) do |person|
    #     person.party_all_night!
    #   end
    #
    # NOTE: It's not possible to set the order. That is automatically set to
    # ascending on the primary key ("id ASC") to make the batch ordering
    # work. This also means that this method only works when the primary key is
    # orderable (e.g. an integer or string).
    #
    # NOTE: By its nature, batch processing is subject to race conditions if
    # other processes are modifying the database.
    def find_each(start: nil, finish: nil, batch_size: 1000, error_on_ignore: nil)
      if block_given?
        find_in_batches(start: start, finish: finish, batch_size: batch_size, error_on_ignore: error_on_ignore) do |records|
          records.each { |record| yield record }
        end
      else
        enum_for(:find_each, start: start, finish: finish, batch_size: batch_size, error_on_ignore: error_on_ignore) do
          relation = self
          apply_limits(relation, start, finish).size
        end
      end
    end

    # Yields each batch of records that was found by the find options as
    # an array.
    #
    #   Person.where("age > 21").find_in_batches do |group|
    #     sleep(50) # Make sure it doesn't get too crowded in there!
    #     group.each { |person| person.party_all_night! }
    #   end
    #
    # If you do not provide a block to #find_in_batches, it will return an Enumerator
    # for chaining with other methods:
    #
    #   Person.find_in_batches.with_index do |group, batch|
    #     puts "Processing group ##{batch}"
    #     group.each(&:recover_from_last_night!)
    #   end
    #
    # To be yielded each record one by one, use #find_each instead.
    #
    # ==== Options
    # * <tt>:batch_size</tt> - Specifies the size of the batch. Default to 1000.
    # * <tt>:start</tt> - Specifies the primary key value to start from, inclusive of the value.
    # * <tt>:finish</tt> - Specifies the primary key value to end at, inclusive of the value.
    # * <tt>:error_on_ignore</tt> - Overrides the application config to specify if an error should be raised when
    #                               an order is present in the relation.
    #
    # Limits are honored, and if present there is no requirement for the batch
    # size, it can be less than, equal, or greater than the limit.
    #
    # The options +start+ and +finish+ are especially useful if you want
    # multiple workers dealing with the same processing queue. You can make
    # worker 1 handle all the records between id 1 and 9999 and worker 2
    # handle from 10000 and beyond by setting the +:start+ and +:finish+
    # option on each worker.
    #
    #   # Let's process from record 10_000 on.
    #   Person.find_in_batches(start: 10_000) do |group|
    #     group.each { |person| person.party_all_night! }
    #   end
    #
    # NOTE: It's not possible to set the order. That is automatically set to
    # ascending on the primary key ("id ASC") to make the batch ordering
    # work. This also means that this method only works when the primary key is
    # orderable (e.g. an integer or string).
    #
    # NOTE: By its nature, batch processing is subject to race conditions if
    # other processes are modifying the database.
    def find_in_batches(start: nil, finish: nil, batch_size: 1000, error_on_ignore: nil)
      relation = self
      unless block_given?
        return to_enum(:find_in_batches, start: start, finish: finish, batch_size: batch_size, error_on_ignore: error_on_ignore) do
          total = apply_limits(relation, start, finish).size
          (total - 1).div(batch_size) + 1
        end
      end

      in_batches(of: batch_size, start: start, finish: finish, load: true, error_on_ignore: error_on_ignore) do |batch|
        yield batch.to_a
      end
    end

    # Yields ActiveRecord::Relation objects to work with a batch of records.
    #
    #   Person.where("age > 21").in_batches do |relation|
    #     relation.delete_all
    #     sleep(10) # Throttle the delete queries
    #   end
    #
    # If you do not provide a block to #in_batches, it will return a
    # BatchEnumerator which is enumerable.
    #
    #   Person.in_batches.with_index do |relation, batch_index|
    #     puts "Processing relation ##{batch_index}"
    #     relation.each { |relation| relation.delete_all }
    #   end
    #
    # Examples of calling methods on the returned BatchEnumerator object:
    #
    #   Person.in_batches.delete_all
    #   Person.in_batches.update_all(awesome: true)
    #   Person.in_batches.each_record(&:party_all_night!)
    #
    # ==== Options
    # * <tt>:of</tt> - Specifies the size of the batch. Default to 1000.
    # * <tt>:load</tt> - Specifies if the relation should be loaded. Default to false.
    # * <tt>:start</tt> - Specifies the primary key value to start from, inclusive of the value.
    # * <tt>:finish</tt> - Specifies the primary key value to end at, inclusive of the value.
    # * <tt>:error_on_ignore</tt> - Overrides the application config to specify if an error should be raised when
    #                               an order is present in the relation.
    #
    # Limits are honored, and if present there is no requirement for the batch
    # size, it can be less than, equal, or greater than the limit.
    #
    # The options +start+ and +finish+ are especially useful if you want
    # multiple workers dealing with the same processing queue. You can make
    # worker 1 handle all the records between id 1 and 9999 and worker 2
    # handle from 10000 and beyond by setting the +:start+ and +:finish+
    # option on each worker.
    #
    #   # Let's process from record 10_000 on.
    #   Person.in_batches(start: 10_000).update_all(awesome: true)
    #
    # An example of calling where query method on the relation:
    #
    #   Person.in_batches.each do |relation|
    #     relation.update_all('age = age + 1')
    #     relation.where('age > 21').update_all(should_party: true)
    #     relation.where('age <= 21').delete_all
    #   end
    #
    # NOTE: If you are going to iterate through each record, you should call
    # #each_record on the yielded BatchEnumerator:
    #
    #   Person.in_batches.each_record(&:party_all_night!)
    #
    # NOTE: It's not possible to set the order. That is automatically set to
    # ascending on the primary key ("id ASC") to make the batch ordering
    # consistent. Therefore the primary key must be orderable, e.g an integer
    # or a string.
    #
    # NOTE: By its nature, batch processing is subject to race conditions if
    # other processes are modifying the database.
    def in_batches(of: 1000, start: nil, finish: nil, load: false, error_on_ignore: nil)
      relation = self
      unless block_given?
        return BatchEnumerator.new(of: of, start: start, finish: finish, relation: self)
      end

      if arel.orders.present?
        act_on_ignored_order(error_on_ignore)
      end

      batch_limit = of
      if limit_value
        remaining   = limit_value
        batch_limit = remaining if remaining < batch_limit
      end

      relation = relation.reorder(batch_order).limit(batch_limit)
      relation = apply_limits(relation, start, finish)
      batch_relation = relation

      loop do
        if load
          records = batch_relation.records
          ids = records.map(&:id)
          yielded_relation = where(primary_key => ids)
          yielded_relation.load_records(records)
        else
          ids = batch_relation.pluck(primary_key)
          yielded_relation = where(primary_key => ids)
        end

        break if ids.empty?

        primary_key_offset = ids.last
        raise ArgumentError.new("Primary key not included in the custom select clause") unless primary_key_offset

        yield yielded_relation

        break if ids.length < batch_limit

        if limit_value
          remaining -= ids.length

          if remaining == 0
            # Saves a useless iteration when the limit is a multiple of the
            # batch size.
            break
          elsif remaining < batch_limit
            relation = relation.limit(remaining)
          end
        end

        batch_relation = relation.where(arel_attribute(primary_key).gt(primary_key_offset))
      end
    end

    private

      def apply_limits(relation, start, finish)
        relation = relation.where(arel_attribute(primary_key).gteq(start)) if start
        relation = relation.where(arel_attribute(primary_key).lteq(finish)) if finish
        relation
      end

      def batch_order
        "#{quoted_table_name}.#{quoted_primary_key} ASC"
      end

      def act_on_ignored_order(error_on_ignore)
        raise_error = (error_on_ignore.nil? ? self.klass.error_on_ignored_order : error_on_ignore)

        if raise_error
          raise ArgumentError.new(ORDER_IGNORE_MESSAGE)
        elsif logger
          logger.warn(ORDER_IGNORE_MESSAGE)
        end
      end
  end
end
require "cases/helper"
require "models/post"
require "models/subscriber"

class EachTest < ActiveRecord::TestCase
  fixtures :posts, :subscribers

  def setup
    @posts = Post.order("id asc")
    @total = Post.count
    Post.count("id") # preheat arel's table cache
  end

  def test_each_should_execute_one_query_per_batch
    assert_queries(@total + 1) do
      Post.find_each(batch_size: 1) do |post|
        assert_kind_of Post, post
      end
    end
  end

  def test_each_should_not_return_query_chain_and_execute_only_one_query
    assert_queries(1) do
      result = Post.find_each(batch_size: 100000){ }
      assert_nil result
    end
  end

  def test_each_should_return_an_enumerator_if_no_block_is_present
    assert_queries(1) do
      Post.find_each(batch_size: 100000).with_index do |post, index|
        assert_kind_of Post, post
        assert_kind_of Integer, index
      end
    end
  end

  if Enumerator.method_defined? :size
    def test_each_should_return_a_sized_enumerator
      assert_equal 11, Post.find_each(batch_size: 1).size
      assert_equal 5, Post.find_each(batch_size:  2, start: 7).size
      assert_equal 11, Post.find_each(batch_size: 10_000).size
    end
  end

  def test_each_enumerator_should_execute_one_query_per_batch
    assert_queries(@total + 1) do
      Post.find_each(batch_size: 1).with_index do |post, index|
        assert_kind_of Post, post
        assert_kind_of Integer, index
      end
    end
  end

  def test_each_should_raise_if_select_is_set_without_id
    assert_raise(ArgumentError) do
      Post.select(:title).find_each(batch_size: 1) { |post|
        flunk "should not call this block"
      }
    end
  end

  def test_each_should_execute_if_id_is_in_select
    assert_queries(6) do
      Post.select("id, title, type").find_each(batch_size: 2) do |post|
        assert_kind_of Post, post
      end
    end
  end

  test "find_each should honor limit if passed a block" do
    limit = @total - 1
    total = 0

    Post.limit(limit).find_each do |post|
      total += 1
    end

    assert_equal limit, total
  end

  test "find_each should honor limit if no block is passed" do
    limit = @total - 1
    total = 0

    Post.limit(limit).find_each.each do |post|
      total += 1
    end

    assert_equal limit, total
  end

  def test_warn_if_order_scope_is_set
    assert_called(ActiveRecord::Base.logger, :warn) do
      Post.order("title").find_each { |post| post }
    end
  end

  def test_logger_not_required
    previous_logger = ActiveRecord::Base.logger
    ActiveRecord::Base.logger = nil
    assert_nothing_raised do
      Post.order("comments_count DESC").find_each { |post| post }
    end
  ensure
    ActiveRecord::Base.logger = previous_logger
  end

  def test_find_in_batches_should_return_batches
    assert_queries(@total + 1) do
      Post.find_in_batches(batch_size: 1) do |batch|
        assert_kind_of Array, batch
        assert_kind_of Post, batch.first
      end
    end
  end

  def test_find_in_batches_should_start_from_the_start_option
    assert_queries(@total) do
      Post.find_in_batches(batch_size: 1, start: 2) do |batch|
        assert_kind_of Array, batch
        assert_kind_of Post, batch.first
      end
    end
  end

  def test_find_in_batches_should_end_at_the_finish_option
    assert_queries(6) do
      Post.find_in_batches(batch_size: 1, finish: 5) do |batch|
        assert_kind_of Array, batch
        assert_kind_of Post, batch.first
      end
    end
  end

  def test_find_in_batches_shouldnt_execute_query_unless_needed
    assert_queries(2) do
      Post.find_in_batches(batch_size: @total) {|batch| assert_kind_of Array, batch }
    end

    assert_queries(1) do
      Post.find_in_batches(batch_size: @total + 1) {|batch| assert_kind_of Array, batch }
    end
  end

  def test_find_in_batches_should_quote_batch_order
    c = Post.connection
    assert_sql(/ORDER BY #{c.quote_table_name('posts')}.#{c.quote_column_name('id')}/) do
      Post.find_in_batches(batch_size: 1) do |batch|
        assert_kind_of Array, batch
        assert_kind_of Post, batch.first
      end
    end
  end

  def test_find_in_batches_should_not_use_records_after_yielding_them_in_case_original_array_is_modified
    not_a_post = "not a post"
    def not_a_post.id; end
    not_a_post.stub(:id, ->{ raise StandardError.new("not_a_post had #id called on it") }) do
      assert_nothing_raised do
        Post.find_in_batches(batch_size: 1) do |batch|
          assert_kind_of Array, batch
          assert_kind_of Post, batch.first

          batch.map! { not_a_post }
        end
      end
    end
  end

  def test_find_in_batches_should_ignore_the_order_default_scope
    # First post is with title scope
    first_post = PostWithDefaultScope.first
    posts = []
    PostWithDefaultScope.find_in_batches  do |batch|
      posts.concat(batch)
    end
    # posts.first will be ordered using id only. Title order scope should not apply here
    assert_not_equal first_post, posts.first
    assert_equal posts(:welcome).id, posts.first.id
  end

  def test_find_in_batches_should_error_on_ignore_the_order
    assert_raise(ArgumentError) do
      PostWithDefaultScope.find_in_batches(error_on_ignore: true){}
    end
  end

  def test_find_in_batches_should_not_error_if_config_overridden
    # Set the config option which will be overridden
    prev = ActiveRecord::Base.error_on_ignored_order
    ActiveRecord::Base.error_on_ignored_order = true
    assert_nothing_raised do
      PostWithDefaultScope.find_in_batches(error_on_ignore: false){}
    end
  ensure
    # Set back to default
    ActiveRecord::Base.error_on_ignored_order = prev
  end

  def test_find_in_batches_should_error_on_config_specified_to_error
    # Set the config option
    prev = ActiveRecord::Base.error_on_ignored_order
    ActiveRecord::Base.error_on_ignored_order = true
    assert_raise(ArgumentError) do
      PostWithDefaultScope.find_in_batches(){}
    end
  ensure
    # Set back to default
    ActiveRecord::Base.error_on_ignored_order = prev
  end

  def test_find_in_batches_should_not_error_by_default
    assert_nothing_raised do
      PostWithDefaultScope.find_in_batches(){}
    end
  end

  def test_find_in_batches_should_not_ignore_the_default_scope_if_it_is_other_then_order
    special_posts_ids = SpecialPostWithDefaultScope.all.map(&:id).sort
    posts = []
    SpecialPostWithDefaultScope.find_in_batches do |batch|
      posts.concat(batch)
    end
    assert_equal special_posts_ids, posts.map(&:id)
  end

  def test_find_in_batches_should_not_modify_passed_options
    assert_nothing_raised do
      Post.find_in_batches({ batch_size: 42, start: 1 }.freeze){}
    end
  end

  def test_find_in_batches_should_use_any_column_as_primary_key
    nick_order_subscribers = Subscriber.order("nick asc")
    start_nick = nick_order_subscribers.second.nick

    subscribers = []
    Subscriber.find_in_batches(batch_size: 1, start: start_nick) do |batch|
      subscribers.concat(batch)
    end

    assert_equal nick_order_subscribers[1..-1].map(&:id), subscribers.map(&:id)
  end

  def test_find_in_batches_should_use_any_column_as_primary_key_when_start_is_not_specified
    assert_queries(Subscriber.count + 1) do
      Subscriber.find_in_batches(batch_size: 1) do |batch|
        assert_kind_of Array, batch
        assert_kind_of Subscriber, batch.first
      end
    end
  end

  def test_find_in_batches_should_return_an_enumerator
    enum = nil
    assert_no_queries do
      enum = Post.find_in_batches(batch_size: 1)
    end
    assert_queries(4) do
      enum.first(4) do |batch|
        assert_kind_of Array, batch
        assert_kind_of Post, batch.first
      end
    end
  end

  test "find_in_batches should honor limit if passed a block" do
    limit = @total - 1
    total = 0

    Post.limit(limit).find_in_batches do |batch|
      total += batch.size
    end

    assert_equal limit, total
  end

  test "find_in_batches should honor limit if no block is passed" do
    limit = @total - 1
    total = 0

    Post.limit(limit).find_in_batches.each do |batch|
      total += batch.size
    end

    assert_equal limit, total
  end

  def test_in_batches_should_not_execute_any_query
    assert_no_queries do
      assert_kind_of ActiveRecord::Batches::BatchEnumerator, Post.in_batches(of: 2)
    end
  end

  def test_in_batches_should_yield_relation_if_block_given
    assert_queries(6) do
      Post.in_batches(of: 2) do |relation|
        assert_kind_of ActiveRecord::Relation, relation
      end
    end
  end

  def test_in_batches_should_be_enumerable_if_no_block_given
    assert_queries(6) do
      Post.in_batches(of: 2).each do |relation|
        assert_kind_of ActiveRecord::Relation, relation
      end
    end
  end

  def test_in_batches_each_record_should_yield_record_if_block_is_given
    assert_queries(6) do
      Post.in_batches(of: 2).each_record do |post|
        assert post.title.present?
        assert_kind_of Post, post
      end
    end
  end

  def test_in_batches_each_record_should_return_enumerator_if_no_block_given
    assert_queries(6) do
      Post.in_batches(of: 2).each_record.with_index do |post, i|
        assert post.title.present?
        assert_kind_of Post, post
      end
    end
  end

  def test_in_batches_each_record_should_be_ordered_by_id
    ids = Post.order("id ASC").pluck(:id)
    assert_queries(6) do
      Post.in_batches(of: 2).each_record.with_index do |post, i|
        assert_equal ids[i], post.id
      end
    end
  end

  def test_in_batches_update_all_affect_all_records
    assert_queries(6 + 6) do # 6 selects, 6 updates
      Post.in_batches(of: 2).update_all(title: "updated-title")
    end
    assert_equal Post.all.pluck(:title), ["updated-title"] * Post.count
  end

  def test_in_batches_delete_all_should_not_delete_records_in_other_batches
    not_deleted_count = Post.where("id <= 2").count
    Post.where("id > 2").in_batches(of: 2).delete_all
    assert_equal 0, Post.where("id > 2").count
    assert_equal not_deleted_count, Post.count
  end

  def test_in_batches_should_not_be_loaded
    Post.in_batches(of: 1) do |relation|
      assert_not relation.loaded?
    end

    Post.in_batches(of: 1, load: false) do |relation|
      assert_not relation.loaded?
    end
  end

  def test_in_batches_should_be_loaded
    Post.in_batches(of: 1, load: true) do |relation|
      assert relation.loaded?
    end
  end

  def test_in_batches_if_not_loaded_executes_more_queries
    assert_queries(@total + 1) do
      Post.in_batches(of: 1, load: false) do |relation|
        assert_not relation.loaded?
      end
    end
  end

  def test_in_batches_should_return_relations
    assert_queries(@total + 1) do
      Post.in_batches(of: 1) do |relation|
        assert_kind_of ActiveRecord::Relation, relation
      end
    end
  end

  def test_in_batches_should_start_from_the_start_option
    post = Post.order("id ASC").where("id >= ?", 2).first
    assert_queries(2) do
      relation = Post.in_batches(of: 1, start: 2).first
      assert_equal post, relation.first
    end
  end

  def test_in_batches_should_end_at_the_finish_option
    post = Post.order("id DESC").where("id <= ?", 5).first
    assert_queries(7) do
      relation = Post.in_batches(of: 1, finish: 5, load: true).reverse_each.first
      assert_equal post, relation.last
    end
  end

  def test_in_batches_shouldnt_execute_query_unless_needed
    assert_queries(2) do
      Post.in_batches(of: @total) { |relation| assert_kind_of ActiveRecord::Relation, relation }
    end

    assert_queries(1) do
      Post.in_batches(of: @total + 1) { |relation| assert_kind_of ActiveRecord::Relation, relation }
    end
  end

  def test_in_batches_should_quote_batch_order
    c = Post.connection
    assert_sql(/ORDER BY #{c.quote_table_name('posts')}.#{c.quote_column_name('id')}/) do
      Post.in_batches(of: 1) do |relation|
        assert_kind_of ActiveRecord::Relation, relation
        assert_kind_of Post, relation.first
      end
    end
  end

  def test_in_batches_should_not_use_records_after_yielding_them_in_case_original_array_is_modified
    not_a_post = "not a post"
    def not_a_post.id
      raise StandardError.new("not_a_post had #id called on it")
    end

    assert_nothing_raised do
      Post.in_batches(of: 1) do |relation|
        assert_kind_of ActiveRecord::Relation, relation
        assert_kind_of Post, relation.first

        relation = [not_a_post] * relation.count
      end
    end
  end

  def test_in_batches_should_not_ignore_default_scope_without_order_statements
    special_posts_ids = SpecialPostWithDefaultScope.all.map(&:id).sort
    posts = []
    SpecialPostWithDefaultScope.in_batches do |relation|
      posts.concat(relation)
    end
    assert_equal special_posts_ids, posts.map(&:id)
  end

  def test_in_batches_should_not_modify_passed_options
    assert_nothing_raised do
      Post.in_batches({ of: 42, start: 1 }.freeze){}
    end
  end

  def test_in_batches_should_use_any_column_as_primary_key
    nick_order_subscribers = Subscriber.order("nick asc")
    start_nick = nick_order_subscribers.second.nick

    subscribers = []
    Subscriber.in_batches(of: 1, start: start_nick) do |relation|
      subscribers.concat(relation)
    end

    assert_equal nick_order_subscribers[1..-1].map(&:id), subscribers.map(&:id)
  end

  def test_in_batches_should_use_any_column_as_primary_key_when_start_is_not_specified
    assert_queries(Subscriber.count + 1) do
      Subscriber.in_batches(of: 1, load: true) do |relation|
        assert_kind_of ActiveRecord::Relation, relation
        assert_kind_of Subscriber, relation.first
      end
    end
  end

  def test_in_batches_should_return_an_enumerator
    enum = nil
    assert_no_queries do
      enum = Post.in_batches(of: 1)
    end
    assert_queries(4) do
      enum.first(4) do |relation|
        assert_kind_of ActiveRecord::Relation, relation
        assert_kind_of Post, relation.first
      end
    end
  end

  def test_in_batches_relations_should_not_overlap_with_each_other
    seen_posts = []
    Post.in_batches(of: 2, load: true) do |relation|
      relation.to_a.each do |post|
        assert_not seen_posts.include?(post)
        seen_posts << post
      end
    end
  end

  def test_in_batches_relations_with_condition_should_not_overlap_with_each_other
    seen_posts = []
    author_id = Post.first.author_id
    posts_by_author = Post.where(author_id: author_id)
    Post.in_batches(of: 2) do |batch|
      seen_posts += batch.where(author_id: author_id)
    end

    assert_equal posts_by_author.pluck(:id).sort, seen_posts.map(&:id).sort
  end

  def test_in_batches_relations_update_all_should_not_affect_matching_records_in_other_batches
    Post.update_all(author_id: 0)
    person = Post.last
    person.update_attributes(author_id: 1)

    Post.in_batches(of: 2) do |batch|
      batch.where("author_id >= 1").update_all("author_id = author_id + 1")
    end
    assert_equal 2, person.reload.author_id # incremented only once
  end

  if Enumerator.method_defined? :size
    def test_find_in_batches_should_return_a_sized_enumerator
      assert_equal 11, Post.find_in_batches(batch_size: 1).size
      assert_equal 6, Post.find_in_batches(batch_size: 2).size
      assert_equal 4, Post.find_in_batches(batch_size: 2, start: 4).size
      assert_equal 4, Post.find_in_batches(batch_size: 3).size
      assert_equal 1, Post.find_in_batches(batch_size: 10_000).size
    end
  end

  [true, false].each do |load|
    test "in_batches should return limit records when limit is less than batch size and load is #{load}" do
      limit      = 3
      batch_size = 5
      total      = 0

      Post.limit(limit).in_batches(of: batch_size, load: load) do |batch|
        total += batch.count
      end

      assert_equal limit, total
    end

    test "in_batches should return limit records when limit is greater than batch size and load is #{load}" do
      limit      = 5
      batch_size = 3
      total      = 0

      Post.limit(limit).in_batches(of: batch_size, load: load) do |batch|
        total += batch.count
      end

      assert_equal limit, total
    end

    test "in_batches should return limit records when limit is a multiple of the batch size and load is #{load}" do
      limit      = 6
      batch_size = 3
      total      = 0

      Post.limit(limit).in_batches(of: batch_size, load: load) do |batch|
        total += batch.count
      end

      assert_equal limit, total
    end

    test "in_batches should return no records if the limit is 0 and load is #{load}" do
      limit      = 0
      batch_size = 1
      total      = 0

      Post.limit(limit).in_batches(of: batch_size, load: load) do |batch|
        total += batch.count
      end

      assert_equal limit, total
    end

    test "in_batches should return all if the limit is greater than the number of records when load is #{load}" do
      limit      = @total + 1
      batch_size = 1
      total      = 0

      Post.limit(limit).in_batches(of: batch_size, load: load) do |batch|
        total += batch.count
      end

      assert_equal @total, total
    end
  end

  test ".error_on_ignored_order_or_limit= is deprecated" do
    begin
      prev = ActiveRecord::Base.error_on_ignored_order
      assert_deprecated "Please use error_on_ignored_order= instead." do
        ActiveRecord::Base.error_on_ignored_order_or_limit = true
      end
      assert ActiveRecord::Base.error_on_ignored_order
    ensure
      ActiveRecord::Base.error_on_ignored_order = prev
    end
  end

  test ".error_on_ignored_order_or_limit is deprecated" do
    expected = ActiveRecord::Base.error_on_ignored_order
    actual = assert_deprecated "Please use error_on_ignored_order instead." do
      ActiveRecord::Base.error_on_ignored_order_or_limit
    end
    assert_equal expected, actual
  end

  test "#error_on_ignored_order_or_limit is deprecated" do
    expected = ActiveRecord::Base.error_on_ignored_order
    actual = assert_deprecated "Please use error_on_ignored_order instead." do
      Post.new.error_on_ignored_order_or_limit
    end
    assert_equal expected, actual
  end
end
module ActiveRecord
  module AttributeMethods
    # = Active Record Attribute Methods Before Type Cast
    #
    # ActiveRecord::AttributeMethods::BeforeTypeCast provides a way to
    # read the value of the attributes before typecasting and deserialization.
    #
    #   class Task < ActiveRecord::Base
    #   end
    #
    #   task = Task.new(id: '1', completed_on: '2012-10-21')
    #   task.id           # => 1
    #   task.completed_on # => Sun, 21 Oct 2012
    #
    #   task.attributes_before_type_cast
    #   # => {"id"=>"1", "completed_on"=>"2012-10-21", ... }
    #   task.read_attribute_before_type_cast('id')           # => "1"
    #   task.read_attribute_before_type_cast('completed_on') # => "2012-10-21"
    #
    # In addition to #read_attribute_before_type_cast and #attributes_before_type_cast,
    # it declares a method for all attributes with the <tt>*_before_type_cast</tt>
    # suffix.
    #
    #   task.id_before_type_cast           # => "1"
    #   task.completed_on_before_type_cast # => "2012-10-21"
    module BeforeTypeCast
      extend ActiveSupport::Concern

      included do
        attribute_method_suffix "_before_type_cast"
        attribute_method_suffix "_came_from_user?"
      end

      # Returns the value of the attribute identified by +attr_name+ before
      # typecasting and deserialization.
      #
      #   class Task < ActiveRecord::Base
      #   end
      #
      #   task = Task.new(id: '1', completed_on: '2012-10-21')
      #   task.read_attribute('id')                            # => 1
      #   task.read_attribute_before_type_cast('id')           # => '1'
      #   task.read_attribute('completed_on')                  # => Sun, 21 Oct 2012
      #   task.read_attribute_before_type_cast('completed_on') # => "2012-10-21"
      #   task.read_attribute_before_type_cast(:completed_on)  # => "2012-10-21"
      def read_attribute_before_type_cast(attr_name)
        @attributes[attr_name.to_s].value_before_type_cast
      end

      # Returns a hash of attributes before typecasting and deserialization.
      #
      #   class Task < ActiveRecord::Base
      #   end
      #
      #   task = Task.new(title: nil, is_done: true, completed_on: '2012-10-21')
      #   task.attributes
      #   # => {"id"=>nil, "title"=>nil, "is_done"=>true, "completed_on"=>Sun, 21 Oct 2012, "created_at"=>nil, "updated_at"=>nil}
      #   task.attributes_before_type_cast
      #   # => {"id"=>nil, "title"=>nil, "is_done"=>true, "completed_on"=>"2012-10-21", "created_at"=>nil, "updated_at"=>nil}
      def attributes_before_type_cast
        @attributes.values_before_type_cast
      end

      private

      # Handle *_before_type_cast for method_missing.
        def attribute_before_type_cast(attribute_name)
          read_attribute_before_type_cast(attribute_name)
        end

        def attribute_came_from_user?(attribute_name)
          @attributes[attribute_name].came_from_user?
        end
    end
  end
end
class String
  # Enables more predictable duck-typing on String-like classes. See <tt>Object#acts_like?</tt>.
  def acts_like_string?
    true
  end
end
require "active_support/notifications"

module ActiveSupport
  # Raised when <tt>ActiveSupport::Deprecation::Behavior#behavior</tt> is set with <tt>:raise</tt>.
  # You would set <tt>:raise</tt>, as a behavior to raise errors and proactively report exceptions from deprecations.
  class DeprecationException < StandardError
  end

  class Deprecation
    # Default warning behaviors per Rails.env.
    DEFAULT_BEHAVIORS = {
      raise: ->(message, callstack) {
        e = DeprecationException.new(message)
        e.set_backtrace(callstack.map(&:to_s))
        raise e
      },

      stderr: ->(message, callstack) {
        $stderr.puts(message)
        $stderr.puts callstack.join("\n  ") if debug
      },

      log: ->(message, callstack) {
        logger =
            if defined?(Rails.logger) && Rails.logger
              Rails.logger
            else
              require "active_support/logger"
              ActiveSupport::Logger.new($stderr)
            end
        logger.warn message
        logger.debug callstack.join("\n  ") if debug
      },

      notify: ->(message, callstack) {
        ActiveSupport::Notifications.instrument("deprecation.rails",
                                                message: message, callstack: callstack)
      },

      silence: ->(message, callstack) {},
    }

    # Behavior module allows to determine how to display deprecation messages.
    # You can create a custom behavior or set any from the +DEFAULT_BEHAVIORS+
    # constant. Available behaviors are:
    #
    # [+raise+]   Raise <tt>ActiveSupport::DeprecationException</tt>.
    # [+stderr+]  Log all deprecation warnings to +$stderr+.
    # [+log+]     Log all deprecation warnings to +Rails.logger+.
    # [+notify+]  Use +ActiveSupport::Notifications+ to notify +deprecation.rails+.
    # [+silence+] Do nothing.
    #
    # Setting behaviors only affects deprecations that happen after boot time.
    # For more information you can read the documentation of the +behavior=+ method.
    module Behavior
      # Whether to print a backtrace along with the warning.
      attr_accessor :debug

      # Returns the current behavior or if one isn't set, defaults to +:stderr+.
      def behavior
        @behavior ||= [DEFAULT_BEHAVIORS[:stderr]]
      end

      # Sets the behavior to the specified value. Can be a single value, array,
      # or an object that responds to +call+.
      #
      # Available behaviors:
      #
      # [+raise+]   Raise <tt>ActiveSupport::DeprecationException</tt>.
      # [+stderr+]  Log all deprecation warnings to +$stderr+.
      # [+log+]     Log all deprecation warnings to +Rails.logger+.
      # [+notify+]  Use +ActiveSupport::Notifications+ to notify +deprecation.rails+.
      # [+silence+] Do nothing.
      #
      # Setting behaviors only affects deprecations that happen after boot time.
      # Deprecation warnings raised by gems are not affected by this setting
      # because they happen before Rails boots up.
      #
      #   ActiveSupport::Deprecation.behavior = :stderr
      #   ActiveSupport::Deprecation.behavior = [:stderr, :log]
      #   ActiveSupport::Deprecation.behavior = MyCustomHandler
      #   ActiveSupport::Deprecation.behavior = ->(message, callstack) {
      #     # custom stuff
      #   }
      def behavior=(behavior)
        @behavior = Array(behavior).map { |b| DEFAULT_BEHAVIORS[b] || b }
      end
    end
  end
end
require "active_support/core_ext/class/attribute"
require "active_support/core_ext/module/delegation"
require "active_support/core_ext/hash/reverse_merge"
require "active_support/core_ext/kernel/reporting"
require "active_support/testing/stream"
require "active_support/concern"
require "rails/generators"

module Rails
  module Generators
    module Testing
      module Behaviour
        extend ActiveSupport::Concern
        include ActiveSupport::Testing::Stream

        included do
          class_attribute :destination_root, :current_path, :generator_class, :default_arguments

          # Generators frequently change the current path using +FileUtils.cd+.
          # So we need to store the path at file load and revert back to it after each test.
          self.current_path = File.expand_path(Dir.pwd)
          self.default_arguments = []
        end

        module ClassMethods
          # Sets which generator should be tested:
          #
          #   tests AppGenerator
          def tests(klass)
            self.generator_class = klass
          end

          # Sets default arguments on generator invocation. This can be overwritten when
          # invoking it.
          #
          #   arguments %w(app_name --skip-active-record)
          def arguments(array)
            self.default_arguments = array
          end

          # Sets the destination of generator files:
          #
          #   destination File.expand_path("../tmp", File.dirname(__FILE__))
          def destination(path)
            self.destination_root = path
          end
        end

        # Runs the generator configured for this class. The first argument is an array like
        # command line arguments:
        #
        #   class AppGeneratorTest < Rails::Generators::TestCase
        #     tests AppGenerator
        #     destination File.expand_path("../tmp", File.dirname(__FILE__))
        #     setup :prepare_destination
        #
        #     test "database.yml is not created when skipping Active Record" do
        #       run_generator %w(myapp --skip-active-record)
        #       assert_no_file "config/database.yml"
        #     end
        #   end
        #
        # You can provide a configuration hash as second argument. This method returns the output
        # printed by the generator.
        def run_generator(args = default_arguments, config = {})
          capture(:stdout) do
            args += ["--skip-bundle"] unless args.include? "--dev"
            generator_class.start(args, config.reverse_merge(destination_root: destination_root))
          end
        end

        # Instantiate the generator.
        def generator(args = default_arguments, options = {}, config = {})
          @generator ||= generator_class.new(args, options, config.reverse_merge(destination_root: destination_root))
        end

        # Create a Rails::Generators::GeneratedAttribute by supplying the
        # attribute type and, optionally, the attribute name:
        #
        #   create_generated_attribute(:string, 'name')
        def create_generated_attribute(attribute_type, name = "test", index = nil)
          Rails::Generators::GeneratedAttribute.parse([name, attribute_type, index].compact.join(":"))
        end

        protected

          def destination_root_is_set? # :nodoc:
            raise "You need to configure your Rails::Generators::TestCase destination root." unless destination_root
          end

          def ensure_current_path # :nodoc:
            cd current_path
          end

          # Clears all files and directories in destination.
          def prepare_destination
            rm_rf(destination_root)
            mkdir_p(destination_root)
          end

          def migration_file_name(relative) # :nodoc:
            absolute = File.expand_path(relative, destination_root)
            dirname, file_name = File.dirname(absolute), File.basename(absolute).sub(/\.rb$/, "")
            Dir.glob("#{dirname}/[0-9]*_*.rb").grep(/\d+_#{file_name}.rb$/).first
          end
      end
    end
  end
end
module ActiveRecord
  # = Active Record Belongs To Association
  module Associations
    class BelongsToAssociation < SingularAssociation #:nodoc:
      def handle_dependency
        target.send(options[:dependent]) if load_target
      end

      def replace(record)
        if record
          raise_on_type_mismatch!(record)
          update_counters_on_replace(record)
          replace_keys(record)
          set_inverse_instance(record)
          @updated = true
        else
          decrement_counters
          remove_keys
        end

        self.target = record
      end

      def reset
        super
        @updated = false
      end

      def updated?
        @updated
      end

      def decrement_counters # :nodoc:
        update_counters(-1)
      end

      def increment_counters # :nodoc:
        update_counters(1)
      end

      private

        def update_counters(by)
          if require_counter_update? && foreign_key_present?
            if target && !stale_target?
              target.increment!(reflection.counter_cache_column, by)
            else
              klass.update_counters(target_id, reflection.counter_cache_column => by)
            end
          end
        end

        def find_target?
          !loaded? && foreign_key_present? && klass
        end

        def require_counter_update?
          reflection.counter_cache_column && owner.persisted?
        end

        def update_counters_on_replace(record)
          if require_counter_update? && different_target?(record)
            owner.instance_variable_set :@_after_replace_counter_called, true
            record.increment!(reflection.counter_cache_column)
            decrement_counters
          end
        end

        # Checks whether record is different to the current target, without loading it
        def different_target?(record)
          record.id != owner._read_attribute(reflection.foreign_key)
        end

        def replace_keys(record)
          owner[reflection.foreign_key] = record._read_attribute(reflection.association_primary_key(record.class))
        end

        def remove_keys
          owner[reflection.foreign_key] = nil
        end

        def foreign_key_present?
          owner._read_attribute(reflection.foreign_key)
        end

        # NOTE - for now, we're only supporting inverse setting from belongs_to back onto
        # has_one associations.
        def invertible_for?(record)
          inverse = inverse_reflection_for(record)
          inverse && inverse.has_one?
        end

        def target_id
          if options[:primary_key]
            owner.send(reflection.name).try(:id)
          else
            owner._read_attribute(reflection.foreign_key)
          end
        end

        def stale_state
          result = owner._read_attribute(reflection.foreign_key) { |n| owner.send(:missing_attribute, n, caller) }
          result && result.to_s
        end
    end
  end
end
require "cases/helper"
require "models/developer"
require "models/project"
require "models/company"
require "models/topic"
require "models/reply"
require "models/computer"
require "models/post"
require "models/author"
require "models/tag"
require "models/tagging"
require "models/comment"
require "models/sponsor"
require "models/member"
require "models/essay"
require "models/toy"
require "models/invoice"
require "models/line_item"
require "models/column"
require "models/record"
require "models/admin"
require "models/admin/user"
require "models/ship"
require "models/treasure"
require "models/parrot"

class BelongsToAssociationsTest < ActiveRecord::TestCase
  fixtures :accounts, :companies, :developers, :projects, :topics,
           :developers_projects, :computers, :authors, :author_addresses,
           :posts, :tags, :taggings, :comments, :sponsors, :members

  def test_belongs_to
    firm = Client.find(3).firm
    assert_not_nil firm
    assert_equal companies(:first_firm).name, firm.name
  end

  def test_missing_attribute_error_is_raised_when_no_foreign_key_attribute
    assert_raises(ActiveModel::MissingAttributeError) { Client.select(:id).first.firm }
  end

  def test_belongs_to_does_not_use_order_by
    ActiveRecord::SQLCounter.clear_log
    Client.find(3).firm
  ensure
    assert ActiveRecord::SQLCounter.log_all.all? { |sql| /order by/i !~ sql }, "ORDER BY was used in the query"
  end

  def test_belongs_to_with_primary_key
    client = Client.create(name: "Primary key client", firm_name: companies(:first_firm).name)
    assert_equal companies(:first_firm).name, client.firm_with_primary_key.name
  end

  def test_belongs_to_with_primary_key_joins_on_correct_column
    sql = Client.joins(:firm_with_primary_key).to_sql
    if current_adapter?(:Mysql2Adapter)
      assert_no_match(/`firm_with_primary_keys_companies`\.`id`/, sql)
      assert_match(/`firm_with_primary_keys_companies`\.`name`/, sql)
    elsif current_adapter?(:OracleAdapter)
      # on Oracle aliases are truncated to 30 characters and are quoted in uppercase
      assert_no_match(/"firm_with_primary_keys_compani"\."id"/i, sql)
      assert_match(/"firm_with_primary_keys_compani"\."name"/i, sql)
    else
      assert_no_match(/"firm_with_primary_keys_companies"\."id"/, sql)
      assert_match(/"firm_with_primary_keys_companies"\."name"/, sql)
    end
  end

  def test_optional_relation
    original_value = ActiveRecord::Base.belongs_to_required_by_default
    ActiveRecord::Base.belongs_to_required_by_default = true

    model = Class.new(ActiveRecord::Base) do
      self.table_name = "accounts"
      def self.name; "Temp"; end
      belongs_to :company, optional: true
    end

    account = model.new
    assert account.valid?
  ensure
    ActiveRecord::Base.belongs_to_required_by_default = original_value
  end

  def test_not_optional_relation
    original_value = ActiveRecord::Base.belongs_to_required_by_default
    ActiveRecord::Base.belongs_to_required_by_default = true

    model = Class.new(ActiveRecord::Base) do
      self.table_name = "accounts"
      def self.name; "Temp"; end
      belongs_to :company, optional: false
    end

    account = model.new
    assert_not account.valid?
    assert_equal [{error: :blank}], account.errors.details[:company]
  ensure
    ActiveRecord::Base.belongs_to_required_by_default = original_value
  end

  def test_required_belongs_to_config
    original_value = ActiveRecord::Base.belongs_to_required_by_default
    ActiveRecord::Base.belongs_to_required_by_default = true

    model = Class.new(ActiveRecord::Base) do
      self.table_name = "accounts"
      def self.name; "Temp"; end
      belongs_to :company
    end

    account = model.new
    assert_not account.valid?
    assert_equal [{error: :blank}], account.errors.details[:company]
  ensure
    ActiveRecord::Base.belongs_to_required_by_default = original_value
  end

  def test_default_scope_on_relations_is_not_cached
    counter = 0

    comments = Class.new(ActiveRecord::Base) {
      self.table_name = "comments"
      self.inheritance_column = "not_there"

      posts = Class.new(ActiveRecord::Base) {
        self.table_name = "posts"
        self.inheritance_column = "not_there"

        default_scope -> {
          counter += 1
          where("id = :inc", inc: counter)
        }

        has_many :comments, anonymous_class: comments
      }
      belongs_to :post, anonymous_class: posts, inverse_of: false
    }

    assert_equal 0, counter
    comment = comments.first
    assert_equal 0, counter
    sql = capture_sql { comment.post }
    comment.reload
    assert_not_equal sql, capture_sql { comment.post }
  end

  def test_proxy_assignment
    account = Account.find(1)
    assert_nothing_raised { account.firm = account.firm }
  end

  def test_type_mismatch
    assert_raise(ActiveRecord::AssociationTypeMismatch) { Account.find(1).firm = 1 }
    assert_raise(ActiveRecord::AssociationTypeMismatch) { Account.find(1).firm = Project.find(1) }
  end

  def test_raises_type_mismatch_with_namespaced_class
    assert_nil defined?(Region), "This test requires that there is no top-level Region class"

    ActiveRecord::Base.connection.instance_eval do
      create_table(:admin_regions) { |t| t.string :name }
      add_column :admin_users, :region_id, :integer
    end
    Admin.const_set "RegionalUser", Class.new(Admin::User) { belongs_to(:region) }
    Admin.const_set "Region", Class.new(ActiveRecord::Base)

    e = assert_raise(ActiveRecord::AssociationTypeMismatch) {
      Admin::RegionalUser.new(region: "wrong value")
    }
    assert_match(/^Region\([^)]+\) expected, got "wrong value" which is an instance of String\([^)]+\)$/, e.message)
  ensure
    Admin.send :remove_const, "Region" if Admin.const_defined?("Region")
    Admin.send :remove_const, "RegionalUser" if Admin.const_defined?("RegionalUser")

    ActiveRecord::Base.connection.instance_eval do
      remove_column :admin_users, :region_id if column_exists?(:admin_users, :region_id)
      drop_table :admin_regions, if_exists: true
    end
  end

  def test_natural_assignment
    apple = Firm.create("name" => "Apple")
    citibank = Account.create("credit_limit" => 10)
    citibank.firm = apple
    assert_equal apple.id, citibank.firm_id
  end

  def test_id_assignment
    apple = Firm.create("name" => "Apple")
    citibank = Account.create("credit_limit" => 10)
    citibank.firm_id = apple
    assert_nil citibank.firm_id
  end

  def test_natural_assignment_with_primary_key
    apple = Firm.create("name" => "Apple")
    citibank = Client.create("name" => "Primary key client")
    citibank.firm_with_primary_key = apple
    assert_equal apple.name, citibank.firm_name
  end

  def test_eager_loading_with_primary_key
    Firm.create("name" => "Apple")
    Client.create("name" => "Citibank", :firm_name => "Apple")
    citibank_result = Client.all.merge!(where: {name: "Citibank"}, includes: :firm_with_primary_key).first
    assert citibank_result.association(:firm_with_primary_key).loaded?
  end

  def test_eager_loading_with_primary_key_as_symbol
    Firm.create("name" => "Apple")
    Client.create("name" => "Citibank", :firm_name => "Apple")
    citibank_result = Client.all.merge!(where: {name: "Citibank"}, includes: :firm_with_primary_key_symbols).first
    assert citibank_result.association(:firm_with_primary_key_symbols).loaded?
  end

  def test_creating_the_belonging_object
    citibank = Account.create("credit_limit" => 10)
    apple    = citibank.create_firm("name" => "Apple")
    assert_equal apple, citibank.firm
    citibank.save
    citibank.reload
    assert_equal apple, citibank.firm
  end

  def test_creating_the_belonging_object_with_primary_key
    client = Client.create(name: "Primary key client")
    apple  = client.create_firm_with_primary_key("name" => "Apple")
    assert_equal apple, client.firm_with_primary_key
    client.save
    client.reload
    assert_equal apple, client.firm_with_primary_key
  end

  def test_building_the_belonging_object
    citibank = Account.create("credit_limit" => 10)
    apple    = citibank.build_firm("name" => "Apple")
    citibank.save
    assert_equal apple.id, citibank.firm_id
  end

  def test_building_the_belonging_object_with_implicit_sti_base_class
    account = Account.new
    company = account.build_firm
    assert_kind_of Company, company, "Expected #{company.class} to be a Company"
  end

  def test_building_the_belonging_object_with_explicit_sti_base_class
    account = Account.new
    company = account.build_firm(type: "Company")
    assert_kind_of Company, company, "Expected #{company.class} to be a Company"
  end

  def test_building_the_belonging_object_with_sti_subclass
    account = Account.new
    company = account.build_firm(type: "Firm")
    assert_kind_of Firm, company, "Expected #{company.class} to be a Firm"
  end

  def test_building_the_belonging_object_with_an_invalid_type
    account = Account.new
    assert_raise(ActiveRecord::SubclassNotFound) { account.build_firm(type: "InvalidType") }
  end

  def test_building_the_belonging_object_with_an_unrelated_type
    account = Account.new
    assert_raise(ActiveRecord::SubclassNotFound) { account.build_firm(type: "Account") }
  end

  def test_building_the_belonging_object_with_primary_key
    client = Client.create(name: "Primary key client")
    apple  = client.build_firm_with_primary_key("name" => "Apple")
    client.save
    assert_equal apple.name, client.firm_name
  end

  def test_create!
    client  = Client.create!(name: "Jimmy")
    account = client.create_account!(credit_limit: 10)
    assert_equal account, client.account
    assert account.persisted?
    client.save
    client.reload
    assert_equal account, client.account
  end

  def test_failing_create!
    client  = Client.create!(name: "Jimmy")
    assert_raise(ActiveRecord::RecordInvalid) { client.create_account! }
    assert_not_nil client.account
    assert client.account.new_record?
  end

  def test_natural_assignment_to_nil
    client = Client.find(3)
    client.firm = nil
    client.save
    client.association(:firm).reload
    assert_nil client.firm
    assert_nil client.client_of
  end

  def test_natural_assignment_to_nil_with_primary_key
    client = Client.create(name: "Primary key client", firm_name: companies(:first_firm).name)
    client.firm_with_primary_key = nil
    client.save
    client.association(:firm_with_primary_key).reload
    assert_nil client.firm_with_primary_key
    assert_nil client.client_of
  end

  def test_with_different_class_name
    assert_equal Company.find(1).name, Company.find(3).firm_with_other_name.name
    assert_not_nil Company.find(3).firm_with_other_name, "Microsoft should have a firm"
  end

  def test_with_condition
    assert_equal Company.find(1).name, Company.find(3).firm_with_condition.name
    assert_not_nil Company.find(3).firm_with_condition, "Microsoft should have a firm"
  end

  def test_polymorphic_association_class
    sponsor = Sponsor.new
    assert_nil sponsor.association(:sponsorable).send(:klass)
    sponsor.association(:sponsorable).reload
    assert_nil sponsor.sponsorable

    sponsor.sponsorable_type = "" # the column doesn't have to be declared NOT NULL
    assert_nil sponsor.association(:sponsorable).send(:klass)
    sponsor.association(:sponsorable).reload
    assert_nil sponsor.sponsorable

    sponsor.sponsorable = Member.new name: "Bert"
    assert_equal Member, sponsor.association(:sponsorable).send(:klass)
    assert_equal "members", sponsor.association(:sponsorable).aliased_table_name
  end

  def test_with_polymorphic_and_condition
    sponsor = Sponsor.create
    member = Member.create name: "Bert"
    sponsor.sponsorable = member

    assert_equal member, sponsor.sponsorable
    assert_nil sponsor.sponsorable_with_conditions
  end

  def test_with_select
    assert_equal 1, Company.find(2).firm_with_select.attributes.size
    assert_equal 1, Company.all.merge!(includes: :firm_with_select ).find(2).firm_with_select.attributes.size
  end

  def test_belongs_to_without_counter_cache_option
    # Ship has a conventionally named `treasures_count` column, but the counter_cache
    # option is not given on the association.
    ship = Ship.create(name: "Countless")

    assert_no_difference lambda { ship.reload.treasures_count }, "treasures_count should not be changed unless counter_cache is given on the relation" do
      treasure = Treasure.new(name: "Gold", ship: ship)
      treasure.save
    end

    assert_no_difference lambda { ship.reload.treasures_count }, "treasures_count should not be changed unless counter_cache is given on the relation" do
      treasure = ship.treasures.first
      treasure.destroy
    end
  end

  def test_belongs_to_counter
    debate = Topic.create("title" => "debate")
    assert_equal 0, debate.read_attribute("replies_count"), "No replies yet"

    trash = debate.replies.create("title" => "blah!", "content" => "world around!")
    assert_equal 1, Topic.find(debate.id).read_attribute("replies_count"), "First reply created"

    trash.destroy
    assert_equal 0, Topic.find(debate.id).read_attribute("replies_count"), "First reply deleted"
  end

  def test_belongs_to_counter_with_assigning_nil
    post = Post.find(1)
    comment = Comment.find(1)

    assert_equal post.id, comment.post_id
    assert_equal 2, Post.find(post.id).comments.size

    comment.post = nil

    assert_equal 1, Post.find(post.id).comments.size
  end

  def test_belongs_to_with_primary_key_counter
    debate  = Topic.create("title" => "debate")
    debate2 = Topic.create("title" => "debate2")
    reply   = Reply.create("title" => "blah!", "content" => "world around!", "parent_title" => "debate")

    assert_equal 1, debate.reload.replies_count
    assert_equal 0, debate2.reload.replies_count

    reply.topic_with_primary_key = debate2

    assert_equal 0, debate.reload.replies_count
    assert_equal 1, debate2.reload.replies_count

    reply.topic_with_primary_key = nil

    assert_equal 0, debate.reload.replies_count
    assert_equal 0, debate2.reload.replies_count
  end

  def test_belongs_to_counter_with_reassigning
    topic1 = Topic.create("title" => "t1")
    topic2 = Topic.create("title" => "t2")
    reply1 = Reply.new("title" => "r1", "content" => "r1")
    reply1.topic = topic1

    assert reply1.save
    assert_equal 1, Topic.find(topic1.id).replies.size
    assert_equal 0, Topic.find(topic2.id).replies.size

    reply1.topic = Topic.find(topic2.id)

    assert_no_queries do
      reply1.topic = topic2
    end

    assert reply1.save
    assert_equal 0, Topic.find(topic1.id).replies.size
    assert_equal 1, Topic.find(topic2.id).replies.size

    reply1.topic = nil

    assert_equal 0, Topic.find(topic1.id).replies.size
    assert_equal 0, Topic.find(topic2.id).replies.size

    reply1.topic = topic1

    assert_equal 1, Topic.find(topic1.id).replies.size
    assert_equal 0, Topic.find(topic2.id).replies.size

    reply1.destroy

    assert_equal 0, Topic.find(topic1.id).replies.size
    assert_equal 0, Topic.find(topic2.id).replies.size
  end

  def test_belongs_to_reassign_with_namespaced_models_and_counters
    topic1 = Web::Topic.create("title" => "t1")
    topic2 = Web::Topic.create("title" => "t2")
    reply1 = Web::Reply.new("title" => "r1", "content" => "r1")
    reply1.topic = topic1

    assert reply1.save
    assert_equal 1, Web::Topic.find(topic1.id).replies.size
    assert_equal 0, Web::Topic.find(topic2.id).replies.size

    reply1.topic = Web::Topic.find(topic2.id)

    assert reply1.save
    assert_equal 0, Web::Topic.find(topic1.id).replies.size
    assert_equal 1, Web::Topic.find(topic2.id).replies.size
  end

  def test_belongs_to_counter_after_save
    topic = Topic.create!(title: "monday night")
    topic.replies.create!(title: "re: monday night", content: "football")
    assert_equal 1, Topic.find(topic.id)[:replies_count]

    topic.save!
    assert_equal 1, Topic.find(topic.id)[:replies_count]
  end

  def test_belongs_to_with_touch_option_on_touch
    line_item = LineItem.create!
    Invoice.create!(line_items: [line_item])

    assert_queries(1) { line_item.touch }
  end

  def test_belongs_to_with_touch_on_multiple_records
    line_item = LineItem.create!(amount: 1)
    line_item2 = LineItem.create!(amount: 2)
    Invoice.create!(line_items: [line_item, line_item2])

    assert_queries(1) do
      LineItem.transaction do
        line_item.touch
        line_item2.touch
      end
    end

    assert_queries(2) do
      line_item.touch
      line_item2.touch
    end
  end

  def test_belongs_to_with_touch_option_on_touch_without_updated_at_attributes
    assert_not LineItem.column_names.include?("updated_at")

    line_item = LineItem.create!
    invoice = Invoice.create!(line_items: [line_item])
    initial = invoice.updated_at
    travel(1.second) do
      line_item.touch
    end

    assert_not_equal initial, invoice.reload.updated_at
  end

  def test_belongs_to_with_touch_option_on_touch_and_removed_parent
    line_item = LineItem.create!
    Invoice.create!(line_items: [line_item])

    line_item.invoice = nil

    assert_queries(2) { line_item.touch }
  end

  def test_belongs_to_with_touch_option_on_update
    line_item = LineItem.create!
    Invoice.create!(line_items: [line_item])

    assert_queries(2) { line_item.update amount: 10 }
  end

  def test_belongs_to_with_touch_option_on_empty_update
    line_item = LineItem.create!
    Invoice.create!(line_items: [line_item])

    assert_queries(0) { line_item.save }
  end

  def test_belongs_to_with_touch_option_on_destroy
    line_item = LineItem.create!
    Invoice.create!(line_items: [line_item])

    assert_queries(2) { line_item.destroy }
  end

  def test_belongs_to_with_touch_option_on_destroy_with_destroyed_parent
    line_item = LineItem.create!
    invoice   = Invoice.create!(line_items: [line_item])
    invoice.destroy

    assert_queries(1) { line_item.destroy }
  end

  def test_belongs_to_with_touch_option_on_touch_and_reassigned_parent
    line_item = LineItem.create!
    Invoice.create!(line_items: [line_item])

    line_item.invoice = Invoice.create!

    assert_queries(3) { line_item.touch }
  end

  def test_belongs_to_counter_after_update
    topic = Topic.create!(title: "37s")
    topic.replies.create!(title: "re: 37s", content: "rails")
    assert_equal 1, Topic.find(topic.id)[:replies_count]

    topic.update(title: "37signals")
    assert_equal 1, Topic.find(topic.id)[:replies_count]
  end

  def test_belongs_to_counter_when_update_columns
    topic = Topic.create!(title: "37s")
    topic.replies.create!(title: "re: 37s", content: "rails")
    assert_equal 1, Topic.find(topic.id)[:replies_count]

    topic.update_columns(content: "rails is wonderful")
    assert_equal 1, Topic.find(topic.id)[:replies_count]
  end

  def test_assignment_before_child_saved
    final_cut = Client.new("name" => "Final Cut")
    firm = Firm.find(1)
    final_cut.firm = firm
    assert !final_cut.persisted?
    assert final_cut.save
    assert final_cut.persisted?
    assert firm.persisted?
    assert_equal firm, final_cut.firm
    final_cut.association(:firm).reload
    assert_equal firm, final_cut.firm
  end

  def test_assignment_before_child_saved_with_primary_key
    final_cut = Client.new("name" => "Final Cut")
    firm = Firm.find(1)
    final_cut.firm_with_primary_key = firm
    assert !final_cut.persisted?
    assert final_cut.save
    assert final_cut.persisted?
    assert firm.persisted?
    assert_equal firm, final_cut.firm_with_primary_key
    final_cut.association(:firm_with_primary_key).reload
    assert_equal firm, final_cut.firm_with_primary_key
  end

  def test_new_record_with_foreign_key_but_no_object
    client = Client.new("firm_id" => 1)
    # sometimes tests on Oracle fail if ORDER BY is not provided therefore add always :order with :first
    assert_equal Firm.all.merge!(order: "id").first, client.firm_with_basic_id
  end

  def test_setting_foreign_key_after_nil_target_loaded
    client = Client.new
    client.firm_with_basic_id
    client.firm_id = 1

    assert_equal companies(:first_firm), client.firm_with_basic_id
  end

  def test_polymorphic_setting_foreign_key_after_nil_target_loaded
    sponsor = Sponsor.new
    sponsor.sponsorable
    sponsor.sponsorable_id = 1
    sponsor.sponsorable_type = "Member"

    assert_equal members(:groucho), sponsor.sponsorable
  end

  def test_dont_find_target_when_foreign_key_is_null
    tagging = taggings(:thinking_general)
    assert_queries(0) { tagging.super_tag }
  end

  def test_field_name_same_as_foreign_key
    computer = Computer.find(1)
    assert_not_nil computer.developer, ":foreign key == attribute didn't lock up" # '
  end

  def test_counter_cache
    topic = Topic.create title: "Zoom-zoom-zoom"
    assert_equal 0, topic[:replies_count]

    reply = Reply.create(title: "re: zoom", content: "speedy quick!")
    reply.topic = topic

    assert_equal 1, topic.reload[:replies_count]
    assert_equal 1, topic.replies.size

    topic[:replies_count] = 15
    assert_equal 15, topic.replies.size
  end

  def test_counter_cache_double_destroy
    topic = Topic.create title: "Zoom-zoom-zoom"

    5.times do
      topic.replies.create(title: "re: zoom", content: "speedy quick!")
    end

    assert_equal 5, topic.reload[:replies_count]
    assert_equal 5, topic.replies.size

    reply = topic.replies.first

    reply.destroy
    assert_equal 4, topic.reload[:replies_count]

    reply.destroy
    assert_equal 4, topic.reload[:replies_count]
    assert_equal 4, topic.replies.size
  end

  def test_concurrent_counter_cache_double_destroy
    topic = Topic.create title: "Zoom-zoom-zoom"

    5.times do
      topic.replies.create(title: "re: zoom", content: "speedy quick!")
    end

    assert_equal 5, topic.reload[:replies_count]
    assert_equal 5, topic.replies.size

    reply = topic.replies.first
    reply_clone = Reply.find(reply.id)

    reply.destroy
    assert_equal 4, topic.reload[:replies_count]

    reply_clone.destroy
    assert_equal 4, topic.reload[:replies_count]
    assert_equal 4, topic.replies.size
  end

  def test_custom_counter_cache
    reply = Reply.create(title: "re: zoom", content: "speedy quick!")
    assert_equal 0, reply[:replies_count]

    silly = SillyReply.create(title: "gaga", content: "boo-boo")
    silly.reply = reply

    assert_equal 1, reply.reload[:replies_count]
    assert_equal 1, reply.replies.size

    reply[:replies_count] = 17
    assert_equal 17, reply.replies.size
  end

  def test_replace_counter_cache
    topic = Topic.create(title: "Zoom-zoom-zoom")
    reply = Reply.create(title: "re: zoom", content: "speedy quick!")

    reply.topic = topic
    reply.save
    topic.reload

    assert_equal 1, topic.replies_count
  end

  def test_association_assignment_sticks
    post = Post.first

    author1, author2 = Author.all.merge!(limit: 2).to_a
    assert_not_nil author1
    assert_not_nil author2

    # make sure the association is loaded
    post.author

    # set the association by id, directly
    post.author_id = author2.id

    # save and reload
    post.save!
    post.reload

    # the author id of the post should be the id we set
    assert_equal post.author_id, author2.id
  end

  def test_cant_save_readonly_association
    assert_raise(ActiveRecord::ReadOnlyRecord) { companies(:first_client).readonly_firm.save! }
    assert companies(:first_client).readonly_firm.readonly?
  end

  def test_polymorphic_assignment_foreign_key_type_string
    comment = Comment.first
    comment.author   = Author.first
    comment.resource = Member.first
    comment.save

    assert_equal Comment.all.to_a,
      Comment.includes(:author).to_a

    assert_equal Comment.all.to_a,
      Comment.includes(:resource).to_a
  end

  def test_polymorphic_assignment_foreign_type_field_updating
    # should update when assigning a saved record
    sponsor = Sponsor.new
    member = Member.create
    sponsor.sponsorable = member
    assert_equal "Member", sponsor.sponsorable_type

    # should update when assigning a new record
    sponsor = Sponsor.new
    member = Member.new
    sponsor.sponsorable = member
    assert_equal "Member", sponsor.sponsorable_type
  end

  def test_polymorphic_assignment_with_primary_key_foreign_type_field_updating
    # should update when assigning a saved record
    essay = Essay.new
    writer = Author.create(name: "David")
    essay.writer = writer
    assert_equal "Author", essay.writer_type

    # should update when assigning a new record
    essay = Essay.new
    writer = Author.new
    essay.writer = writer
    assert_equal "Author", essay.writer_type
  end

  def test_polymorphic_assignment_updates_foreign_id_field_for_new_and_saved_records
    sponsor = Sponsor.new
    saved_member = Member.create
    new_member = Member.new

    sponsor.sponsorable = saved_member
    assert_equal saved_member.id, sponsor.sponsorable_id

    sponsor.sponsorable = new_member
    assert_nil sponsor.sponsorable_id
  end

  def test_assignment_updates_foreign_id_field_for_new_and_saved_records
    client = Client.new
    saved_firm = Firm.create name: "Saved"
    new_firm = Firm.new

    client.firm = saved_firm
    assert_equal saved_firm.id, client.client_of

    client.firm = new_firm
    assert_nil client.client_of
  end

  def test_polymorphic_assignment_with_primary_key_updates_foreign_id_field_for_new_and_saved_records
    essay = Essay.new
    saved_writer = Author.create(name: "David")
    new_writer = Author.new

    essay.writer = saved_writer
    assert_equal saved_writer.name, essay.writer_id

    essay.writer = new_writer
    assert_nil essay.writer_id
  end

  def test_polymorphic_assignment_with_nil
    essay = Essay.new
    assert_nil essay.writer_id
    assert_nil essay.writer_type

    essay.writer_id = 1
    essay.writer_type = "Author"

    essay.writer = nil
    assert_nil essay.writer_id
    assert_nil essay.writer_type
  end

  def test_belongs_to_proxy_should_not_respond_to_private_methods
    assert_raise(NoMethodError) { companies(:first_firm).private_method }
    assert_raise(NoMethodError) { companies(:second_client).firm.private_method }
  end

  def test_belongs_to_proxy_should_respond_to_private_methods_via_send
    companies(:first_firm).send(:private_method)
    companies(:second_client).firm.send(:private_method)
  end

  def test_save_of_record_with_loaded_belongs_to
    @account = companies(:first_firm).account

    assert_nothing_raised do
      Account.find(@account.id).save!
      Account.all.merge!(includes: :firm).find(@account.id).save!
    end

    @account.firm.delete

    assert_nothing_raised do
      Account.find(@account.id).save!
      Account.all.merge!(includes: :firm).find(@account.id).save!
    end
  end

  def test_dependent_delete_and_destroy_with_belongs_to
    AuthorAddress.destroyed_author_address_ids.clear

    author_address = author_addresses(:david_address)
    author_address_extra = author_addresses(:david_address_extra)
    assert_equal [], AuthorAddress.destroyed_author_address_ids

    assert_difference "AuthorAddress.count", -2 do
      authors(:david).destroy
    end

    assert_equal [], AuthorAddress.where(id: [author_address.id, author_address_extra.id])
    assert_equal [author_address.id], AuthorAddress.destroyed_author_address_ids
  end

  def test_belongs_to_invalid_dependent_option_raises_exception
    error = assert_raise ArgumentError do
      Class.new(Author).belongs_to :special_author_address, dependent: :nullify
    end
    assert_equal error.message, "The :dependent option must be one of [:destroy, :delete], but is :nullify"
  end

  def test_attributes_are_being_set_when_initialized_from_belongs_to_association_with_where_clause
    new_firm = accounts(:signals37).build_firm(name: "Apple")
    assert_equal new_firm.name, "Apple"
  end

  def test_attributes_are_set_without_error_when_initialized_from_belongs_to_association_with_array_in_where_clause
    new_account = Account.where(credit_limit: [ 50, 60 ]).new
    assert_nil new_account.credit_limit
  end

  def test_reassigning_the_parent_id_updates_the_object
    client = companies(:second_client)

    client.firm
    client.firm_with_condition
    firm_proxy                = client.send(:association_instance_get, :firm)
    firm_with_condition_proxy = client.send(:association_instance_get, :firm_with_condition)

    assert !firm_proxy.stale_target?
    assert !firm_with_condition_proxy.stale_target?
    assert_equal companies(:first_firm), client.firm
    assert_equal companies(:first_firm), client.firm_with_condition

    client.client_of = companies(:another_firm).id

    assert firm_proxy.stale_target?
    assert firm_with_condition_proxy.stale_target?
    assert_equal companies(:another_firm), client.firm
    assert_equal companies(:another_firm), client.firm_with_condition
  end

  def test_polymorphic_reassignment_of_associated_id_updates_the_object
    sponsor = sponsors(:moustache_club_sponsor_for_groucho)

    sponsor.sponsorable
    proxy = sponsor.send(:association_instance_get, :sponsorable)

    assert !proxy.stale_target?
    assert_equal members(:groucho), sponsor.sponsorable

    sponsor.sponsorable_id = members(:some_other_guy).id

    assert proxy.stale_target?
    assert_equal members(:some_other_guy), sponsor.sponsorable
  end

  def test_polymorphic_reassignment_of_associated_type_updates_the_object
    sponsor = sponsors(:moustache_club_sponsor_for_groucho)

    sponsor.sponsorable
    proxy = sponsor.send(:association_instance_get, :sponsorable)

    assert !proxy.stale_target?
    assert_equal members(:groucho), sponsor.sponsorable

    sponsor.sponsorable_type = "Firm"

    assert proxy.stale_target?
    assert_equal companies(:first_firm), sponsor.sponsorable
  end

  def test_reloading_association_with_key_change
    client = companies(:second_client)
    firm = client.association(:firm)

    client.firm = companies(:another_firm)
    firm.reload
    assert_equal companies(:another_firm), firm.target

    client.client_of = companies(:first_firm).id
    firm.reload
    assert_equal companies(:first_firm), firm.target
  end

  def test_polymorphic_counter_cache
    tagging = taggings(:welcome_general)
    post    = posts(:welcome)
    comment = comments(:greetings)

    assert_difference lambda { post.reload.tags_count }, -1 do
      assert_difference "comment.reload.tags_count", +1 do
        tagging.taggable = comment
      end
    end
  end

  def test_polymorphic_with_custom_foreign_type
    sponsor = sponsors(:moustache_club_sponsor_for_groucho)
    groucho = members(:groucho)
    other   = members(:some_other_guy)

    assert_equal groucho, sponsor.sponsorable
    assert_equal groucho, sponsor.thing

    sponsor.thing = other

    assert_equal other, sponsor.sponsorable
    assert_equal other, sponsor.thing

    sponsor.sponsorable = groucho

    assert_equal groucho, sponsor.sponsorable
    assert_equal groucho, sponsor.thing
  end

  def test_build_with_conditions
    client = companies(:second_client)
    firm   = client.build_bob_firm

    assert_equal "Bob", firm.name
  end

  def test_create_with_conditions
    client = companies(:second_client)
    firm   = client.create_bob_firm

    assert_equal "Bob", firm.name
  end

  def test_create_bang_with_conditions
    client = companies(:second_client)
    firm   = client.create_bob_firm!

    assert_equal "Bob", firm.name
  end

  def test_build_with_block
    client = Client.create(name: "Client Company")

    firm = client.build_firm{ |f| f.name = "Agency Company" }
    assert_equal "Agency Company", firm.name
  end

  def test_create_with_block
    client = Client.create(name: "Client Company")

    firm = client.create_firm{ |f| f.name = "Agency Company" }
    assert_equal "Agency Company", firm.name
  end

  def test_create_bang_with_block
    client = Client.create(name: "Client Company")

    firm = client.create_firm!{ |f| f.name = "Agency Company" }
    assert_equal "Agency Company", firm.name
  end

  def test_should_set_foreign_key_on_create_association
    client = Client.create! name: "fuu"

    firm = client.create_firm name: "baa"
    assert_equal firm.id, client.client_of
  end

  def test_should_set_foreign_key_on_create_association!
    client = Client.create! name: "fuu"

    firm = client.create_firm! name: "baa"
    assert_equal firm.id, client.client_of
  end

  def test_self_referential_belongs_to_with_counter_cache_assigning_nil
    comment = Comment.create! post: posts(:thinking), body: "fuu"
    comment.parent = nil
    comment.save!

    assert_equal nil, comment.reload.parent
    assert_equal 0, comments(:greetings).reload.children_count
  end

  def test_belongs_to_with_id_assigning
    post = posts(:welcome)
    comment = Comment.create! body: "foo", post: post
    parent = comments(:greetings)
    assert_equal 0, parent.reload.children_count
    comment.parent_id = parent.id

    comment.save!
    assert_equal 1, parent.reload.children_count
  end

  def test_polymorphic_with_custom_primary_key
    toy = Toy.create!
    sponsor = Sponsor.create!(sponsorable: toy)

    assert_equal toy, sponsor.reload.sponsorable
  end

  test "stale tracking doesn't care about the type" do
    apple = Firm.create("name" => "Apple")
    citibank = Account.create("credit_limit" => 10)

    citibank.firm_id = apple.id
    citibank.firm # load it

    citibank.firm_id = apple.id.to_s

    assert !citibank.association(:firm).stale_target?
  end

  def test_reflect_the_most_recent_change
    author1, author2 = Author.limit(2)
    post = Post.new(title: "foo", body: "bar")

    post.author    = author1
    post.author_id = author2.id

    assert post.save
    assert_equal post.author_id, author2.id
  end

  test "dangerous association name raises ArgumentError" do
    [:errors, "errors", :save, "save"].each do |name|
      assert_raises(ArgumentError, "Association #{name} should not be allowed") do
        Class.new(ActiveRecord::Base) do
          belongs_to name
        end
      end
    end
  end

  test "belongs_to works with model called Record" do
    record = Record.create!
    Column.create! record: record
    assert_equal 1, Column.count
  end

  def test_association_force_reload_with_only_true_is_deprecated
    client = Client.find(3)

    assert_deprecated { client.firm(true) }
  end
end

class BelongsToWithForeignKeyTest < ActiveRecord::TestCase
  fixtures :authors, :author_addresses

  def test_destroy_linked_models
    address = AuthorAddress.create!
    author = Author.create! name: "Author", author_address_id: address.id

    author.destroy!
  end
end
module ActiveRecord
  # = Active Record Belongs To Polymorphic Association
  module Associations
    class BelongsToPolymorphicAssociation < BelongsToAssociation #:nodoc:
      def klass
        type = owner[reflection.foreign_type]
        type.presence && type.constantize
      end

      private

        def replace_keys(record)
          super
          owner[reflection.foreign_type] = record.class.base_class.name
        end

        def remove_keys
          super
          owner[reflection.foreign_type] = nil
        end

        def different_target?(record)
          super || record.class != klass
        end

        def inverse_reflection_for(record)
          reflection.polymorphic_inverse_of(record.class)
        end

        def raise_on_type_mismatch!(record)
          # A polymorphic association cannot have a type mismatch, by definition
        end

        def stale_state
          foreign_key = super
          foreign_key && [foreign_key.to_s, owner[reflection.foreign_type].to_s]
        end
    end
  end
end
module ActiveRecord
  module Associations
    class Preloader
      class BelongsTo < SingularAssociation #:nodoc:
        def association_key_name
          reflection.options[:primary_key] || klass && klass.primary_key
        end

        def owner_key_name
          reflection.foreign_key
        end
      end
    end
  end
end
require "active_support/core_ext/benchmark"
require "active_support/core_ext/hash/keys"

module ActiveSupport
  module Benchmarkable
    # Allows you to measure the execution time of a block in a template and
    # records the result to the log. Wrap this block around expensive operations
    # or possible bottlenecks to get a time reading for the operation. For
    # example, let's say you thought your file processing method was taking too
    # long; you could wrap it in a benchmark block.
    #
    #  <% benchmark 'Process data files' do %>
    #    <%= expensive_files_operation %>
    #  <% end %>
    #
    # That would add something like "Process data files (345.2ms)" to the log,
    # which you can then use to compare timings when optimizing your code.
    #
    # You may give an optional logger level (<tt>:debug</tt>, <tt>:info</tt>,
    # <tt>:warn</tt>, <tt>:error</tt>) as the <tt>:level</tt> option. The
    # default logger level value is <tt>:info</tt>.
    #
    #  <% benchmark 'Low-level files', level: :debug do %>
    #    <%= lowlevel_files_operation %>
    #  <% end %>
    #
    # Finally, you can pass true as the third argument to silence all log
    # activity (other than the timing information) from inside the block. This
    # is great for boiling down a noisy block to just a single statement that
    # produces one log line:
    #
    #  <% benchmark 'Process data files', level: :info, silence: true do %>
    #    <%= expensive_and_chatty_files_operation %>
    #  <% end %>
    def benchmark(message = "Benchmarking", options = {})
      if logger
        options.assert_valid_keys(:level, :silence)
        options[:level] ||= :info

        result = nil
        ms = Benchmark.ms { result = options[:silence] ? logger.silence { yield } : yield }
        logger.send(options[:level], "%s (%.1fms)" % [ message, ms ])
        result
      else
        yield
      end
    end
  end
end
require "abstract_unit"

class BenchmarkableTest < ActiveSupport::TestCase
  include ActiveSupport::Benchmarkable

  attr_reader :buffer, :logger

  class Buffer
    include Enumerable

    def initialize; @lines = []; end
    def each(&block); @lines.each(&block); end
    def write(x); @lines << x; end
    def close; end
    def last; @lines.last; end
    def size; @lines.size; end
    def empty?; @lines.empty?; end
  end

  def setup
    @buffer = Buffer.new
    @logger = ActiveSupport::Logger.new(@buffer)
  end

  def test_without_block
    assert_raise(LocalJumpError) { benchmark }
    assert buffer.empty?
  end

  def test_defaults
    i_was_run = false
    benchmark { i_was_run = true }
    assert i_was_run
    assert_last_logged
  end

  def test_with_message
    i_was_run = false
    benchmark("test_run") { i_was_run = true }
    assert i_was_run
    assert_last_logged "test_run"
  end

  def test_with_silence
    assert_difference "buffer.count", +2 do
      benchmark("test_run") do
        logger.info "SOMETHING"
      end
    end

    assert_difference "buffer.count", +1 do
      benchmark("test_run", silence: true) do
        logger.info "NOTHING"
      end
    end
  end

  def test_within_level
    logger.level = ActiveSupport::Logger::DEBUG
    benchmark("included_debug_run", level: :debug) { }
    assert_last_logged "included_debug_run"
  end

  def test_outside_level
    logger.level = ActiveSupport::Logger::ERROR
    benchmark("skipped_debug_run", level: :debug) { }
    assert_no_match(/skipped_debug_run/, buffer.last)
  ensure
    logger.level = ActiveSupport::Logger::DEBUG
  end

  private
    def assert_last_logged(message = "Benchmarking")
      assert_match(/^#{message} \(.*\)$/, buffer.last)
    end
end
require "benchmark"

class << Benchmark
  # Benchmark realtime in milliseconds.
  #
  #   Benchmark.realtime { User.all }
  #   # => 8.0e-05
  #
  #   Benchmark.ms { User.all }
  #   # => 0.074
  def ms
    1000 * realtime { yield }
  end
end
require "cases/helper"
require "models/content"

class BidirectionalDestroyDependenciesTest < ActiveRecord::TestCase
  fixtures :content, :content_positions

  def setup
    Content.destroyed_ids.clear
    ContentPosition.destroyed_ids.clear
  end

  def test_bidirectional_dependence_when_destroying_item_with_belongs_to_association
    content_position = ContentPosition.find(1)
    content = content_position.content
    assert_not_nil content

    content_position.destroy

    assert_equal [content_position.id], ContentPosition.destroyed_ids
    assert_equal [content.id], Content.destroyed_ids
  end

  def test_bidirectional_dependence_when_destroying_item_with_has_one_association
    content = Content.find(1)
    content_position = content.content_position
    assert_not_nil content_position

    content.destroy

    assert_equal [content.id], Content.destroyed_ids
    assert_equal [content_position.id], ContentPosition.destroyed_ids
  end

  def test_bidirectional_dependence_when_destroying_item_with_has_one_association_fails_first_time
    content = ContentWhichRequiresTwoDestroyCalls.find(1)

    2.times { content.destroy }

    assert_equal content.destroyed?, true
  end
end
require "active_support/core_ext/big_decimal/conversions"
require "abstract_unit"
require "active_support/core_ext/big_decimal"

class BigDecimalTest < ActiveSupport::TestCase
  def test_to_s
    bd = BigDecimal.new "0.01"
    assert_equal "0.01", bd.to_s
    assert_equal "+0.01", bd.to_s("+F")
    assert_equal "+0.0 1", bd.to_s("+1F")
  end
end
require "active_model/type/integer"

module ActiveModel
  module Type
    class BigInteger < Integer # :nodoc:
      private

        def max_value
          ::Float::INFINITY
        end
    end
  end
end
module ActiveModel
  module Type
    class Binary < Value # :nodoc:
      def type
        :binary
      end

      def binary?
        true
      end

      def cast(value)
        if value.is_a?(Data)
          value.to_s
        else
          super
        end
      end

      def serialize(value)
        return if value.nil?
        Data.new(super)
      end

      def changed_in_place?(raw_old_value, value)
        old_value = deserialize(raw_old_value)
        old_value != value
      end

      class Data # :nodoc:
        def initialize(value)
          @value = value.to_s
        end

        def to_s
          @value
        end
        alias_method :to_str, :to_s

        def hex
          @value.unpack("H*")[0]
        end

        def ==(other)
          other == to_s || super
        end
      end
    end
  end
end
require "cases/helper"

# Without using prepared statements, it makes no sense to test
# BLOB data with DB2, because the length of a statement
# is limited to 32KB.
unless current_adapter?(:DB2Adapter)
  require "models/binary"

  class BinaryTest < ActiveRecord::TestCase
    FIXTURES = %w(flowers.jpg example.log test.txt)

    def test_mixed_encoding
      str = "\x80"
      str.force_encoding("ASCII-8BIT")

      binary = Binary.new name: "いただきます！", data: str
      binary.save!
      binary.reload
      assert_equal str, binary.data

      name = binary.name

      assert_equal "いただきます！", name
    end

    def test_load_save
      Binary.delete_all

      FIXTURES.each do |filename|
        data = File.read(ASSETS_ROOT + "/#{filename}")
        data.force_encoding("ASCII-8BIT")
        data.freeze

        bin = Binary.new(data: data)
        assert_equal data, bin.data, "Newly assigned data differs from original"

        bin.save!
        assert_equal data, bin.data, "Data differs from original after save"

        assert_equal data, bin.reload.data, "Reloaded data differs from original"
      end
    end
  end
end
require "cases/helper"
require "models/topic"

module ActiveRecord
  module ConnectionAdapters
    class Mysql2Adapter
      class BindParameterTest < ActiveRecord::Mysql2TestCase
        fixtures :topics

        def test_update_question_marks
          str       = "foo?bar"
          x         = Topic.first
          x.title   = str
          x.content = str
          x.save!
          x.reload
          assert_equal str, x.title
          assert_equal str, x.content
        end

        def test_create_question_marks
          str = "foo?bar"
          x   = Topic.create!(title: str, content: str)
          x.reload
          assert_equal str, x.title
          assert_equal str, x.content
        end

        def test_update_null_bytes
          str       = "foo\0bar"
          x         = Topic.first
          x.title   = str
          x.content = str
          x.save!
          x.reload
          assert_equal str, x.title
          assert_equal str, x.content
        end

        def test_create_null_bytes
          str = "foo\0bar"
          x   = Topic.create!(title: str, content: str)
          x.reload
          assert_equal str, x.title
          assert_equal str, x.content
        end
      end
    end
  end
end
require "isolation/abstract_unit"

module ApplicationTests
  class BinSetupTest < ActiveSupport::TestCase
    include ActiveSupport::Testing::Isolation

    def setup
      build_app
    end

    def teardown
      teardown_app
    end

    def test_bin_setup
      Dir.chdir(app_path) do
        app_file "db/schema.rb", <<-RUBY
          ActiveRecord::Schema.define(version: 20140423102712) do
            create_table(:articles) {}
          end
        RUBY

        list_tables = lambda { `bin/rails runner 'p ActiveRecord::Base.connection.tables'`.strip }
        File.write("log/test.log", "zomg!")

        assert_equal "[]", list_tables.call
        assert_equal 5, File.size("log/test.log")
        assert_not File.exist?("tmp/restart.txt")
        `bin/setup 2>&1`
        assert_equal 0, File.size("log/test.log")
        assert_equal '["articles", "schema_migrations", "ar_internal_metadata"]', list_tables.call
        assert File.exist?("tmp/restart.txt")
      end
    end

    def test_bin_setup_output
      Dir.chdir(app_path) do
        app_file "db/schema.rb", ""

        output = `bin/setup 2>&1`
        assert_equal(<<-OUTPUT, output)
== Installing dependencies ==
The Gemfile's dependencies are satisfied

== Preparing database ==
Created database 'db/development.sqlite3'
Created database 'db/test.sqlite3'

== Removing old logs and tempfiles ==

== Restarting application server ==
        OUTPUT
      end
    end
  end
end
class Bird < ActiveRecord::Base
  belongs_to :pirate
  validates_presence_of :name

  accepts_nested_attributes_for :pirate

  attr_accessor :cancel_save_from_callback
  before_save :cancel_save_callback_method, if: :cancel_save_from_callback
  def cancel_save_callback_method
    throw(:abort)
  end
end
module ActiveRecord
  module ConnectionAdapters
    module PostgreSQL
      module OID # :nodoc:
        class Bit < Type::Value # :nodoc:
          def type
            :bit
          end

          def cast(value)
            if ::String === value
              case value
              when /^0x/i
                value[2..-1].hex.to_s(2) # Hexadecimal notation
              else
                value                    # Bit-string notation
              end
            else
              value
            end
          end

          def serialize(value)
            Data.new(super) if value
          end

          class Data
            def initialize(value)
              @value = value
            end

            def to_s
              value
            end

            def binary?
              /\A[01]*\Z/ === value
            end

            def hex?
              /\A[0-9A-F]*\Z/i === value
            end

            protected

              attr_reader :value
          end
        end
      end
    end
  end
end
require "cases/helper"
require "support/connection_helper"
require "support/schema_dumping_helper"

class PostgresqlBitStringTest < ActiveRecord::PostgreSQLTestCase
  include ConnectionHelper
  include SchemaDumpingHelper

  class PostgresqlBitString < ActiveRecord::Base; end

  def setup
    @connection = ActiveRecord::Base.connection
    @connection.create_table("postgresql_bit_strings", force: true) do |t|
      t.bit :a_bit, default: "00000011", limit: 8
      t.bit_varying :a_bit_varying, default: "0011", limit: 4
      t.bit :another_bit
      t.bit_varying :another_bit_varying
    end
  end

  def teardown
    return unless @connection
    @connection.drop_table "postgresql_bit_strings", if_exists: true
  end

  def test_bit_string_column
    column = PostgresqlBitString.columns_hash["a_bit"]
    assert_equal :bit, column.type
    assert_equal "bit(8)", column.sql_type
    assert_not column.array?

    type = PostgresqlBitString.type_for_attribute("a_bit")
    assert_not type.binary?
  end

  def test_bit_string_varying_column
    column = PostgresqlBitString.columns_hash["a_bit_varying"]
    assert_equal :bit_varying, column.type
    assert_equal "bit varying(4)", column.sql_type
    assert_not column.array?

    type = PostgresqlBitString.type_for_attribute("a_bit_varying")
    assert_not type.binary?
  end

  def test_default
    assert_equal "00000011", PostgresqlBitString.column_defaults["a_bit"]
    assert_equal "00000011", PostgresqlBitString.new.a_bit

    assert_equal "0011", PostgresqlBitString.column_defaults["a_bit_varying"]
    assert_equal "0011", PostgresqlBitString.new.a_bit_varying
  end

  def test_schema_dumping
    output = dump_table_schema("postgresql_bit_strings")
    assert_match %r{t\.bit\s+"a_bit",\s+limit: 8,\s+default: "00000011"$}, output
    assert_match %r{t\.bit_varying\s+"a_bit_varying",\s+limit: 4,\s+default: "0011"$}, output
  end

  if ActiveRecord::Base.connection.prepared_statements
    def test_assigning_invalid_hex_string_raises_exception
      assert_raises(ActiveRecord::StatementInvalid) { PostgresqlBitString.create! a_bit: "FF" }
      assert_raises(ActiveRecord::StatementInvalid) { PostgresqlBitString.create! a_bit_varying: "F" }
    end
  end

  def test_roundtrip
    PostgresqlBitString.create! a_bit: "00001010", a_bit_varying: "0101"
    record = PostgresqlBitString.first
    assert_equal "00001010", record.a_bit
    assert_equal "0101", record.a_bit_varying

    record.a_bit = "11111111"
    record.a_bit_varying = "0xF"
    record.save!

    assert record.reload
    assert_equal "11111111", record.a_bit
    assert_equal "1111", record.a_bit_varying
  end
end
module ActiveRecord
  module ConnectionAdapters
    module PostgreSQL
      module OID # :nodoc:
        class BitVarying < OID::Bit # :nodoc:
          def type
            :bit_varying
          end
        end
      end
    end
  end
end
require "date"

class Date #:nodoc:
  # No Date is blank:
  #
  #   Date.today.blank? # => false
  #
  # @return [false]
  def blank?
    false
  end
end
require "abstract_unit"
require "active_support/core_ext/object/blank"

class BlankTest < ActiveSupport::TestCase
  class EmptyTrue
    def empty?
      0
    end
  end

  class EmptyFalse
    def empty?
      nil
    end
  end

  BLANK = [ EmptyTrue.new, nil, false, "", "   ", "  \n\t  \r ", "　", "\u00a0", [], {} ]
  NOT   = [ EmptyFalse.new, Object.new, true, 0, 1, "a", [nil], { nil => 0 } ]

  def test_blank
    BLANK.each { |v| assert_equal true, v.blank?,  "#{v.inspect} should be blank" }
    NOT.each   { |v| assert_equal false, v.blank?, "#{v.inspect} should not be blank" }
  end

  def test_present
    BLANK.each { |v| assert_equal false, v.present?, "#{v.inspect} should not be present" }
    NOT.each   { |v| assert_equal true, v.present?,  "#{v.inspect} should be present" }
  end

  def test_presence
    BLANK.each { |v| assert_equal nil, v.presence, "#{v.inspect}.presence should return nil" }
    NOT.each   { |v| assert_equal v,   v.presence, "#{v.inspect}.presence should return self" }
  end
end
module Blog
  def self.use_relative_model_naming?
    true
  end

  class Post
    extend ActiveModel::Naming
  end
end
class Book < ActiveRecord::Base
  has_many :authors

  has_many :citations, foreign_key: "book1_id"
  has_many :references, -> { distinct }, through: :citations, source: :reference_of

  has_many :subscriptions
  has_many :subscribers, through: :subscriptions

  enum status: [:proposed, :written, :published]
  enum read_status: {unread: 0, reading: 2, read: 3}
  enum nullable_status: [:single, :married]
  enum language: [:english, :spanish, :french], _prefix: :in
  enum author_visibility: [:visible, :invisible], _prefix: true
  enum illustrator_visibility: [:visible, :invisible], _prefix: true
  enum font_size: [:small, :medium, :large], _prefix: :with, _suffix: true
  enum cover: { hard: "hard", soft: "soft" }

  def published!
    super
    "do publish work..."
  end
end
module ActiveModel
  module Type
    # == Active \Model \Type \Boolean
    #
    # A class that behaves like a boolean type, including rules for coercion of user input.
    #
    # === Coercion
    # Values set from user input will first be coerced into the appropriate ruby type.
    # Coercion behavior is roughly mapped to Ruby's boolean semantics.
    #
    # - "false", "f" , "0", +0+ or any other value in +FALSE_VALUES+ will be coerced to +false+
    # - Empty strings are coerced to +nil+
    # - All other values will be coerced to +true+
    class Boolean < Value
      FALSE_VALUES = [false, 0, "0", "f", "F", "false", "FALSE", "off", "OFF"].to_set

      def type # :nodoc:
        :boolean
      end

      private

        def cast_value(value)
          if value == ""
            nil
          else
            !FALSE_VALUES.include?(value)
          end
        end
    end
  end
end
require "cases/helper"

class Mysql2BooleanTest < ActiveRecord::Mysql2TestCase
  self.use_transactional_tests = false

  class BooleanType < ActiveRecord::Base
    self.table_name = "mysql_booleans"
  end

  setup do
    @connection = ActiveRecord::Base.connection
    @connection.clear_cache!
    @connection.create_table("mysql_booleans") do |t|
      t.boolean "archived"
      t.string "published", limit: 1
    end
    BooleanType.reset_column_information

    @emulate_booleans = ActiveRecord::ConnectionAdapters::Mysql2Adapter.emulate_booleans
  end

  teardown do
    emulate_booleans @emulate_booleans
    @connection.drop_table "mysql_booleans"
  end

  test "column type with emulated booleans" do
    emulate_booleans true

    assert_equal :boolean, boolean_column.type
    assert_equal :string, string_column.type
  end

  test "column type without emulated booleans" do
    emulate_booleans false

    assert_equal :integer, boolean_column.type
    assert_equal :string, string_column.type
  end

  test "test type casting with emulated booleans" do
    emulate_booleans true

    boolean = BooleanType.create!(archived: true, published: true)
    attributes = boolean.reload.attributes_before_type_cast
    assert_equal 1, attributes["archived"]
    assert_equal "1", attributes["published"]

    boolean = BooleanType.create!(archived: false, published: false)
    attributes = boolean.reload.attributes_before_type_cast
    assert_equal 0, attributes["archived"]
    assert_equal "0", attributes["published"]

    assert_equal 1, @connection.type_cast(true)
    assert_equal 0, @connection.type_cast(false)
  end

  test "test type casting without emulated booleans" do
    emulate_booleans false

    boolean = BooleanType.create!(archived: true, published: true)
    attributes = boolean.reload.attributes_before_type_cast
    assert_equal 1, attributes["archived"]
    assert_equal "1", attributes["published"]

    boolean = BooleanType.create!(archived: false, published: false)
    attributes = boolean.reload.attributes_before_type_cast
    assert_equal 0, attributes["archived"]
    assert_equal "0", attributes["published"]

    assert_equal 1, @connection.type_cast(true)
    assert_equal 0, @connection.type_cast(false)
  end

  test "with booleans stored as 1 and 0" do
    @connection.execute "INSERT INTO mysql_booleans(archived, published) VALUES(1, '1')"
    boolean = BooleanType.first
    assert_equal true, boolean.archived
    assert_equal "1", boolean.published
  end

  test "with booleans stored as t" do
    @connection.execute "INSERT INTO mysql_booleans(published) VALUES('t')"
    boolean = BooleanType.first
    assert_equal "t", boolean.published
  end

  def boolean_column
    BooleanType.columns.find { |c| c.name == "archived" }
  end

  def string_column
    BooleanType.columns.find { |c| c.name == "published" }
  end

  def emulate_booleans(value)
    ActiveRecord::ConnectionAdapters::Mysql2Adapter.emulate_booleans = value
    BooleanType.reset_column_information
  end
end
ENV['BUNDLE_GEMFILE'] ||= File.expand_path('../Gemfile', __dir__)

require 'bundler/setup' # Set up gems listed in the Gemfile.
require "fileutils"
require "active_support/notifications"
require "active_support/dependencies"
require "active_support/descendants_tracker"

module Rails
  class Application
    module Bootstrap
      include Initializable

      initializer :load_environment_hook, group: :all do end

      initializer :load_active_support, group: :all do
        require "active_support/all" unless config.active_support.bare
      end

      initializer :set_eager_load, group: :all do
        if config.eager_load.nil?
          warn <<-INFO
config.eager_load is set to nil. Please update your config/environments/*.rb files accordingly:

  * development - set it to false
  * test - set it to false (unless you use a tool that preloads your test environment)
  * production - set it to true

INFO
          config.eager_load = config.cache_classes
        end
      end

      # Initialize the logger early in the stack in case we need to log some deprecation.
      initializer :initialize_logger, group: :all do
        Rails.logger ||= config.logger || begin
          path = config.paths["log"].first
          unless File.exist? File.dirname path
            FileUtils.mkdir_p File.dirname path
          end

          f = File.open path, "a"
          f.binmode
          f.sync = config.autoflush_log # if true make sure every write flushes

          logger = ActiveSupport::Logger.new f
          logger.formatter = config.log_formatter
          logger = ActiveSupport::TaggedLogging.new(logger)
          logger
        rescue StandardError
          logger = ActiveSupport::TaggedLogging.new(ActiveSupport::Logger.new(STDERR))
          logger.level = ActiveSupport::Logger::WARN
          logger.warn(
            "Rails Error: Unable to access log file. Please ensure that #{path} exists and is writable " +
            "(ie, make it writable for user and group: chmod 0664 #{path}). " +
            "The log level has been raised to WARN and the output directed to STDERR until the problem is fixed."
          )
          logger
        end

        Rails.logger.level = ActiveSupport::Logger.const_get(config.log_level.to_s.upcase)
      end

      # Initialize cache early in the stack so railties can make use of it.
      initializer :initialize_cache, group: :all do
        unless Rails.cache
          Rails.cache = ActiveSupport::Cache.lookup_store(config.cache_store)

          if Rails.cache.respond_to?(:middleware)
            config.middleware.insert_before(::Rack::Runtime, Rails.cache.middleware)
          end
        end
      end

      # Sets the dependency loading mechanism.
      initializer :initialize_dependency_mechanism, group: :all do
        ActiveSupport::Dependencies.mechanism = config.cache_classes ? :require : :load
      end

      initializer :bootstrap_hook, group: :all do |app|
        ActiveSupport.run_load_hooks(:before_initialize, app)
      end
    end
  end
end
class A::B
end
require "active_support/core_ext/object/to_param"

module ActionCable
  module Channel
    module Broadcasting
      extend ActiveSupport::Concern

      delegate :broadcasting_for, to: :class

      class_methods do
        # Broadcast a hash to a unique broadcasting for this <tt>model</tt> in this channel.
        def broadcast_to(model, message)
          ActionCable.server.broadcast(broadcasting_for([ channel_name, model ]), message)
        end

        def broadcasting_for(model) #:nodoc:
          case
          when model.is_a?(Array)
            model.map { |m| broadcasting_for(m) }.join(":")
          when model.respond_to?(:to_gid_param)
            model.to_gid_param
          else
            model.to_param
          end
        end
      end
    end
  end
end
require "test_helper"
require "stubs/test_connection"
require "stubs/room"

class ActionCable::Channel::BroadcastingTest < ActiveSupport::TestCase
  class ChatChannel < ActionCable::Channel::Base
  end

  setup do
    @connection = TestConnection.new
  end

  test "broadcasts_to" do
    ActionCable.stubs(:server).returns mock().tap { |m| m.expects(:broadcast).with("action_cable:channel:broadcasting_test:chat:Room#1-Campfire", "Hello World") }
    ChatChannel.broadcast_to(Room.new(1), "Hello World")
  end

  test "broadcasting_for with an object" do
    assert_equal "Room#1-Campfire", ChatChannel.broadcasting_for(Room.new(1))
  end

  test "broadcasting_for with an array" do
    assert_equal "Room#1-Campfire:Room#2-Campfire", ChatChannel.broadcasting_for([ Room.new(1), Room.new(2) ])
  end

  test "broadcasting_for with a string" do
    assert_equal "hello", ChatChannel.broadcasting_for("hello")
  end
end
require "abstract_unit"

module ActiveSupport
  class BroadcastLoggerTest < TestCase
    attr_reader :logger, :log1, :log2

    setup do
      @log1 = FakeLogger.new
      @log2 = FakeLogger.new
      @log1.extend Logger.broadcast @log2
      @logger = @log1
    end

    Logger::Severity.constants.each do |level_name|
      method = level_name.downcase
      level = Logger::Severity.const_get(level_name)

      test "##{method} adds the message to all loggers" do
        logger.send(method, "msg")

        assert_equal [level, "msg", nil], log1.adds.first
        assert_equal [level, "msg", nil], log2.adds.first
      end
    end

    test "#close broadcasts to all loggers" do
      logger.close

      assert log1.closed, "should be closed"
      assert log2.closed, "should be closed"
    end

    test "#<< shovels the value into all loggers" do
      logger << "foo"

      assert_equal %w{ foo }, log1.chevrons
      assert_equal %w{ foo }, log2.chevrons
    end

    test "#level= assigns the level to all loggers" do
      assert_equal ::Logger::DEBUG, logger.level
      logger.level = ::Logger::FATAL

      assert_equal ::Logger::FATAL, log1.level
      assert_equal ::Logger::FATAL, log2.level
    end

    test "#progname= assigns to all the loggers" do
      assert_nil logger.progname
      logger.progname = ::Logger::FATAL

      assert_equal ::Logger::FATAL, log1.progname
      assert_equal ::Logger::FATAL, log2.progname
    end

    test "#formatter= assigns to all the loggers" do
      assert_nil logger.formatter
      logger.formatter = ::Logger::FATAL

      assert_equal ::Logger::FATAL, log1.formatter
      assert_equal ::Logger::FATAL, log2.formatter
    end

    test "#local_level= assigns the local_level to all loggers" do
      assert_equal ::Logger::DEBUG, logger.local_level
      logger.local_level = ::Logger::FATAL

      assert_equal ::Logger::FATAL, log1.local_level
      assert_equal ::Logger::FATAL, log2.local_level
    end

    test "#silence silences all loggers below the default level of ERROR" do
      logger.silence do
        logger.debug "test"
      end

      assert_equal [], log1.adds
      assert_equal [], log2.adds
    end

    test "#silence does not silence at or above ERROR" do
      logger.silence do
        logger.error "from error"
        logger.unknown "from unknown"
      end

      assert_equal [[::Logger::ERROR, "from error", nil], [::Logger::UNKNOWN, "from unknown", nil]], log1.adds
      assert_equal [[::Logger::ERROR, "from error", nil], [::Logger::UNKNOWN, "from unknown", nil]], log2.adds
    end

    test "#silence allows you to override the silence level" do
      logger.silence(::Logger::FATAL) do
        logger.error "unseen"
        logger.fatal "seen"
      end

      assert_equal [[::Logger::FATAL, "seen", nil]], log1.adds
      assert_equal [[::Logger::FATAL, "seen", nil]], log2.adds
    end

    class FakeLogger
      include LoggerSilence

      attr_reader :adds, :closed, :chevrons
      attr_accessor :level, :progname, :formatter, :local_level

      def initialize
        @adds        = []
        @closed      = false
        @chevrons    = []
        @level       = ::Logger::DEBUG
        @local_level = ::Logger::DEBUG
        @progname    = nil
        @formatter   = nil
      end

      def debug(message, &block)
        add(::Logger::DEBUG, message, &block)
      end

      def info(message, &block)
        add(::Logger::INFO, message, &block)
      end

      def warn(message, &block)
        add(::Logger::WARN, message, &block)
      end

      def error(message, &block)
        add(::Logger::ERROR, message, &block)
      end

      def fatal(message, &block)
        add(::Logger::FATAL, message, &block)
      end

      def unknown(message, &block)
        add(::Logger::UNKNOWN, message, &block)
      end

      def <<(x)
        @chevrons << x
      end

      def add(message_level, message=nil, progname=nil, &block)
        @adds << [message_level, message, progname] if message_level >= local_level
      end

      def close
        @closed = true
      end
    end
  end
end
require "active_support/core_ext/string/output_safety"

module ActionView
  class OutputBuffer < ActiveSupport::SafeBuffer #:nodoc:
    def initialize(*)
      super
      encode!
    end

    def <<(value)
      return self if value.nil?
      super(value.to_s)
    end
    alias :append= :<<

    def safe_expr_append=(val)
      return self if val.nil?
      safe_concat val.to_s
    end

    alias :safe_append= :safe_concat
  end

  class StreamingBuffer #:nodoc:
    def initialize(block)
      @block = block
    end

    def <<(value)
      value = value.to_s
      value = ERB::Util.h(value) unless value.html_safe?
      @block.call(value)
    end
    alias :concat  :<<
    alias :append= :<<

    def safe_concat(value)
      @block.call(value.to_s)
    end
    alias :safe_append= :safe_concat

    def html_safe?
      true
    end

    def html_safe
      self
    end
  end
end
require "action_dispatch/journey/gtg/transition_table"

module ActionDispatch
  module Journey # :nodoc:
    module GTG # :nodoc:
      class Builder # :nodoc:
        DUMMY = Nodes::Dummy.new

        attr_reader :root, :ast, :endpoints

        def initialize(root)
          @root      = root
          @ast       = Nodes::Cat.new root, DUMMY
          @followpos = nil
        end

        def transition_table
          dtrans   = TransitionTable.new
          marked   = {}
          state_id = Hash.new { |h,k| h[k] = h.length }

          start   = firstpos(root)
          dstates = [start]
          until dstates.empty?
            s = dstates.shift
            next if marked[s]
            marked[s] = true # mark s

            s.group_by { |state| symbol(state) }.each do |sym, ps|
              u = ps.flat_map { |l| followpos(l) }
              next if u.empty?

              if u.uniq == [DUMMY]
                from = state_id[s]
                to   = state_id[Object.new]
                dtrans[from, to] = sym

                dtrans.add_accepting(to)
                ps.each { |state| dtrans.add_memo(to, state.memo) }
              else
                dtrans[state_id[s], state_id[u]] = sym

                if u.include?(DUMMY)
                  to = state_id[u]

                  accepting = ps.find_all { |l| followpos(l).include?(DUMMY) }

                  accepting.each { |accepting_state|
                    dtrans.add_memo(to, accepting_state.memo)
                  }

                  dtrans.add_accepting(state_id[u])
                end
              end

              dstates << u
            end
          end

          dtrans
        end

        def nullable?(node)
          case node
          when Nodes::Group
            true
          when Nodes::Star
            true
          when Nodes::Or
            node.children.any? { |c| nullable?(c) }
          when Nodes::Cat
            nullable?(node.left) && nullable?(node.right)
          when Nodes::Terminal
            !node.left
          when Nodes::Unary
            nullable?(node.left)
          else
            raise ArgumentError, "unknown nullable: %s" % node.class.name
          end
        end

        def firstpos(node)
          case node
          when Nodes::Star
            firstpos(node.left)
          when Nodes::Cat
            if nullable?(node.left)
              firstpos(node.left) | firstpos(node.right)
            else
              firstpos(node.left)
            end
          when Nodes::Or
            node.children.flat_map { |c| firstpos(c) }.uniq
          when Nodes::Unary
            firstpos(node.left)
          when Nodes::Terminal
            nullable?(node) ? [] : [node]
          else
            raise ArgumentError, "unknown firstpos: %s" % node.class.name
          end
        end

        def lastpos(node)
          case node
          when Nodes::Star
            firstpos(node.left)
          when Nodes::Or
            node.children.flat_map { |c| lastpos(c) }.uniq
          when Nodes::Cat
            if nullable?(node.right)
              lastpos(node.left) | lastpos(node.right)
            else
              lastpos(node.right)
            end
          when Nodes::Terminal
            nullable?(node) ? [] : [node]
          when Nodes::Unary
            lastpos(node.left)
          else
            raise ArgumentError, "unknown lastpos: %s" % node.class.name
          end
        end

        def followpos(node)
          followpos_table[node]
        end

        private

          def followpos_table
            @followpos ||= build_followpos
          end

          def build_followpos
            table = Hash.new { |h, k| h[k] = [] }
            @ast.each do |n|
              case n
              when Nodes::Cat
                lastpos(n.left).each do |i|
                  table[i] += firstpos(n.right)
                end
              when Nodes::Star
                lastpos(n).each do |i|
                  table[i] += firstpos(n)
                end
              end
            end
            table
          end

          def symbol(edge)
            case edge
            when Journey::Nodes::Symbol
              edge.regexp
            else
              edge.left
            end
          end
      end
    end
  end
end
require "abstract_unit"

module ActionDispatch
  module Journey
    module GTG
      class TestBuilder < ActiveSupport::TestCase
        def test_following_states_multi
          table  = tt ["a|a"]
          assert_equal 1, table.move([0], "a").length
        end

        def test_following_states_multi_regexp
          table  = tt [":a|b"]
          assert_equal 1, table.move([0], "fooo").length
          assert_equal 2, table.move([0], "b").length
        end

        def test_multi_path
          table  = tt ["/:a/d", "/b/c"]

          [
            [1, "/"],
            [2, "b"],
            [2, "/"],
            [1, "c"],
          ].inject([0]) { |state, (exp, sym)|
            new = table.move(state, sym)
            assert_equal exp, new.length
            new
          }
        end

        def test_match_data_ambiguous
          table = tt %w{
            /articles(.:format)
            /articles/new(.:format)
            /articles/:id/edit(.:format)
            /articles/:id(.:format)
          }

          sim     = NFA::Simulator.new table

          match = sim.match "/articles/new"
          assert_equal 2, match.memos.length
        end

        ##
        # Identical Routes may have different restrictions.
        def test_match_same_paths
          table = tt %w{
            /articles/new(.:format)
            /articles/new(.:format)
          }

          sim     = NFA::Simulator.new table

          match = sim.match "/articles/new"
          assert_equal 2, match.memos.length
        end

        private
          def ast(strings)
            parser = Journey::Parser.new
            asts   = strings.map { |string|
              memo = Object.new
              ast  = parser.parse string
              ast.each { |n| n.memo = memo }
              ast
            }
            Nodes::Or.new asts
          end

          def tt(strings)
            Builder.new(ast(strings)).transition_table
          end
      end
    end
  end
end
class Bulb < ActiveRecord::Base
  default_scope { where(name: "defaulty") }
  belongs_to :car, touch: true
  scope :awesome, -> { where(frickinawesome: true) }

  attr_reader :scope_after_initialize, :attributes_after_initialize

  after_initialize :record_scope_after_initialize
  def record_scope_after_initialize
    @scope_after_initialize = self.class.all
  end

  after_initialize :record_attributes_after_initialize
  def record_attributes_after_initialize
    @attributes_after_initialize = attributes.dup
  end

  def color=(color)
    self[:color] = color.upcase + "!"
  end

  def self.new(attributes = {}, &block)
    bulb_type = (attributes || {}).delete(:bulb_type)

    if bulb_type.present?
      bulb_class = "#{bulb_type.to_s.camelize}Bulb".constantize
      bulb_class.new(attributes, &block)
    else
      super
    end
  end
end

class CustomBulb < Bulb
  after_initialize :set_awesomeness

  def set_awesomeness
    self.frickinawesome = true if name == "Dude"
  end
end

class FunkyBulb < Bulb
  before_destroy do
    raise "before_destroy was called"
  end
end

class FailedBulb < Bulb
  before_destroy do
    throw(:abort)
  end
end

class TrickyBulb < Bulb
  after_create do |record|
    record.car.bulbs.to_a
  end
end
module ActiveRecord
  module ConnectionAdapters
    module PostgreSQL
      module OID # :nodoc:
        class Bytea < Type::Binary # :nodoc:
          def deserialize(value)
            return if value.nil?
            return value.to_s if value.is_a?(Type::Binary::Data)
            PGconn.unescape_bytea(super)
          end
        end
      end
    end
  end
end
require "cases/helper"
require "support/schema_dumping_helper"

class PostgresqlByteaTest < ActiveRecord::PostgreSQLTestCase
  include SchemaDumpingHelper

  class ByteaDataType < ActiveRecord::Base
    self.table_name = "bytea_data_type"
  end

  def setup
    @connection = ActiveRecord::Base.connection
    begin
      @connection.transaction do
        @connection.create_table("bytea_data_type") do |t|
          t.binary "payload"
          t.binary "serialized"
        end
      end
    end
    @column = ByteaDataType.columns_hash["payload"]
    @type = ByteaDataType.type_for_attribute("payload")
  end

  teardown do
    @connection.drop_table "bytea_data_type", if_exists: true
  end

  def test_column
    assert @column.is_a?(ActiveRecord::ConnectionAdapters::PostgreSQLColumn)
    assert_equal :binary, @column.type
  end

  def test_binary_columns_are_limitless_the_upper_limit_is_one_GB
    assert_equal "bytea", @connection.type_to_sql(:binary, 100_000)
    assert_raise ActiveRecord::ActiveRecordError do
      @connection.type_to_sql :binary, 4294967295
    end
  end

  def test_type_cast_binary_converts_the_encoding
    assert @column

    data = "\u001F\x8B"
    assert_equal("UTF-8", data.encoding.name)
    assert_equal("ASCII-8BIT", @type.deserialize(data).encoding.name)
  end

  def test_type_cast_binary_value
    data = "\u001F\x8B".force_encoding("BINARY")
    assert_equal(data, @type.deserialize(data))
  end

  def test_type_case_nil
    assert_equal(nil, @type.deserialize(nil))
  end

  def test_read_value
    data = "\u001F"
    @connection.execute "insert into bytea_data_type (payload) VALUES ('#{data}')"
    record = ByteaDataType.first
    assert_equal(data, record.payload)
    record.delete
  end

  def test_read_nil_value
    @connection.execute "insert into bytea_data_type (payload) VALUES (null)"
    record = ByteaDataType.first
    assert_equal(nil, record.payload)
    record.delete
  end

  def test_write_value
    data = "\u001F"
    record = ByteaDataType.create(payload: data)
    assert_not record.new_record?
    assert_equal(data, record.payload)
  end

  def test_via_to_sql
    data = "'\u001F\\"
    ByteaDataType.create(payload: data)
    sql = ByteaDataType.where(payload: data).select(:payload).to_sql
    result = @connection.query(sql)
    assert_equal([[data]], result)
  end

  def test_via_to_sql_with_complicating_connection
    Thread.new do
      other_conn = ActiveRecord::Base.connection
      other_conn.execute("SET standard_conforming_strings = off")
    end.join

    test_via_to_sql
  end

  def test_write_binary
    data = File.read(File.join(File.dirname(__FILE__), "..", "..", "..", "assets", "example.log"))
    assert(data.size > 1)
    record = ByteaDataType.create(payload: data)
    assert_not record.new_record?
    assert_equal(data, record.payload)
    assert_equal(data, ByteaDataType.where(id: record.id).first.payload)
  end

  def test_write_nil
    record = ByteaDataType.create(payload: nil)
    assert_not record.new_record?
    assert_equal(nil, record.payload)
    assert_equal(nil, ByteaDataType.where(id: record.id).first.payload)
  end

  class Serializer
    def load(str); str; end
    def dump(str); str; end
  end

  def test_serialize
    klass = Class.new(ByteaDataType) {
      serialize :serialized, Serializer.new
    }
    obj = klass.new
    obj.serialized = "hello world"
    obj.save!
    obj.reload
    assert_equal "hello world", obj.serialized
  end

  def test_schema_dumping
    output = dump_table_schema("bytea_data_type")
    assert_match %r{t\.binary\s+"payload"$}, output
    assert_match %r{t\.binary\s+"serialized"$}, output
  end
end
class Numeric
  KILOBYTE = 1024
  MEGABYTE = KILOBYTE * 1024
  GIGABYTE = MEGABYTE * 1024
  TERABYTE = GIGABYTE * 1024
  PETABYTE = TERABYTE * 1024
  EXABYTE  = PETABYTE * 1024

  # Enables the use of byte calculations and declarations, like 45.bytes + 2.6.megabytes
  #
  #   2.bytes # => 2
  def bytes
    self
  end
  alias :byte :bytes

  # Returns the number of bytes equivalent to the kilobytes provided.
  #
  #   2.kilobytes # => 2048
  def kilobytes
    self * KILOBYTE
  end
  alias :kilobyte :kilobytes

  # Returns the number of bytes equivalent to the megabytes provided.
  #
  #   2.megabytes # => 2_097_152
  def megabytes
    self * MEGABYTE
  end
  alias :megabyte :megabytes

  # Returns the number of bytes equivalent to the gigabytes provided.
  #
  #   2.gigabytes # => 2_147_483_648
  def gigabytes
    self * GIGABYTE
  end
  alias :gigabyte :gigabytes

  # Returns the number of bytes equivalent to the terabytes provided.
  #
  #   2.terabytes # => 2_199_023_255_552
  def terabytes
    self * TERABYTE
  end
  alias :terabyte :terabytes

  # Returns the number of bytes equivalent to the petabytes provided.
  #
  #   2.petabytes # => 2_251_799_813_685_248
  def petabytes
    self * PETABYTE
  end
  alias :petabyte :petabytes

  # Returns the number of bytes equivalent to the exabytes provided.
  #
  #   2.exabytes # => 2_305_843_009_213_693_952
  def exabytes
    self * EXABYTE
  end
  alias :exabyte :exabytes
end
module ActionView
  # = Action View Cache Helper
  module Helpers
    module CacheHelper
      # This helper exposes a method for caching fragments of a view
      # rather than an entire action or page. This technique is useful
      # caching pieces like menus, lists of new topics, static HTML
      # fragments, and so on. This method takes a block that contains
      # the content you wish to cache.
      #
      # The best way to use this is by doing key-based cache expiration
      # on top of a cache store like Memcached that'll automatically
      # kick out old entries. For more on key-based expiration, see:
      # http://signalvnoise.com/posts/3113-how-key-based-cache-expiration-works
      #
      # When using this method, you list the cache dependency as the name of the cache, like so:
      #
      #   <% cache project do %>
      #     <b>All the topics on this project</b>
      #     <%= render project.topics %>
      #   <% end %>
      #
      # This approach will assume that when a new topic is added, you'll touch
      # the project. The cache key generated from this call will be something like:
      #
      #   views/projects/123-20120806214154/7a1156131a6928cb0026877f8b749ac9
      #         ^class   ^id ^updated_at    ^template tree digest
      #
      # The cache is thus automatically bumped whenever the project updated_at is touched.
      #
      # If your template cache depends on multiple sources (try to avoid this to keep things simple),
      # you can name all these dependencies as part of an array:
      #
      #   <% cache [ project, current_user ] do %>
      #     <b>All the topics on this project</b>
      #     <%= render project.topics %>
      #   <% end %>
      #
      # This will include both records as part of the cache key and updating either of them will
      # expire the cache.
      #
      # ==== \Template digest
      #
      # The template digest that's added to the cache key is computed by taking an MD5 of the
      # contents of the entire template file. This ensures that your caches will automatically
      # expire when you change the template file.
      #
      # Note that the MD5 is taken of the entire template file, not just what's within the
      # cache do/end call. So it's possible that changing something outside of that call will
      # still expire the cache.
      #
      # Additionally, the digestor will automatically look through your template file for
      # explicit and implicit dependencies, and include those as part of the digest.
      #
      # The digestor can be bypassed by passing skip_digest: true as an option to the cache call:
      #
      #   <% cache project, skip_digest: true do %>
      #     <b>All the topics on this project</b>
      #     <%= render project.topics %>
      #   <% end %>
      #
      # ==== Implicit dependencies
      #
      # Most template dependencies can be derived from calls to render in the template itself.
      # Here are some examples of render calls that Cache Digests knows how to decode:
      #
      #   render partial: "comments/comment", collection: commentable.comments
      #   render "comments/comments"
      #   render 'comments/comments'
      #   render('comments/comments')
      #
      #   render "header" translates to render("comments/header")
      #
      #   render(@topic)         translates to render("topics/topic")
      #   render(topics)         translates to render("topics/topic")
      #   render(message.topics) translates to render("topics/topic")
      #
      # It's not possible to derive all render calls like that, though.
      # Here are a few examples of things that can't be derived:
      #
      #   render group_of_attachments
      #   render @project.documents.where(published: true).order('created_at')
      #
      # You will have to rewrite those to the explicit form:
      #
      #   render partial: 'attachments/attachment', collection: group_of_attachments
      #   render partial: 'documents/document', collection: @project.documents.where(published: true).order('created_at')
      #
      # === Explicit dependencies
      #
      # Some times you'll have template dependencies that can't be derived at all. This is typically
      # the case when you have template rendering that happens in helpers. Here's an example:
      #
      #   <%= render_sortable_todolists @project.todolists %>
      #
      # You'll need to use a special comment format to call those out:
      #
      #   <%# Template Dependency: todolists/todolist %>
      #   <%= render_sortable_todolists @project.todolists %>
      #
      # In some cases, like a single table inheritance setup, you might have
      # a bunch of explicit dependencies. Instead of writing every template out,
      # you can use a wildcard to match any template in a directory:
      #
      #   <%# Template Dependency: events/* %>
      #   <%= render_categorizable_events @person.events %>
      #
      # This marks every template in the directory as a dependency. To find those
      # templates, the wildcard path must be absolutely defined from app/views or paths
      # otherwise added with +prepend_view_path+ or +append_view_path+.
      # This way the wildcard for `app/views/recordings/events` would be `recordings/events/*` etc.
      #
      # The pattern used to match explicit dependencies is <tt>/# Template Dependency: (\S+)/</tt>,
      # so it's important that you type it out just so.
      # You can only declare one template dependency per line.
      #
      # === External dependencies
      #
      # If you use a helper method, for example, inside a cached block and
      # you then update that helper, you'll have to bump the cache as well.
      # It doesn't really matter how you do it, but the MD5 of the template file
      # must change. One recommendation is to simply be explicit in a comment, like:
      #
      #   <%# Helper Dependency Updated: May 6, 2012 at 6pm %>
      #   <%= some_helper_method(person) %>
      #
      # Now all you have to do is change that timestamp when the helper method changes.
      #
      # === Collection Caching
      #
      # When rendering a collection of objects that each use the same partial, a `cached`
      # option can be passed.
      #
      # For collections rendered such:
      #
      #   <%= render partial: 'projects/project', collection: @projects, cached: true %>
      #
      # The `cached: true` will make Action View's rendering read several templates
      # from cache at once instead of one call per template.
      #
      # Templates in the collection not already cached are written to cache.
      #
      # Works great alongside individual template fragment caching.
      # For instance if the template the collection renders is cached like:
      #
      #   # projects/_project.html.erb
      #   <% cache project do %>
      #     <%# ... %>
      #   <% end %>
      #
      # Any collection renders will find those cached templates when attempting
      # to read multiple templates at once.
      #
      # If your collection cache depends on multiple sources (try to avoid this to keep things simple),
      # you can name all these dependencies as part of a block that returns an array:
      #
      #   <%= render partial: 'projects/project', collection: @projects, cached: -> project { [ project, current_user ] } %>
      #
      # This will include both records as part of the cache key and updating either of them will
      # expire the cache.
      def cache(name = {}, options = {}, &block)
        if controller.respond_to?(:perform_caching) && controller.perform_caching
          name_options = options.slice(:skip_digest, :virtual_path)
          safe_concat(fragment_for(cache_fragment_name(name, name_options), options, &block))
        else
          yield
        end

        nil
      end

      # Cache fragments of a view if +condition+ is true
      #
      #   <% cache_if admin?, project do %>
      #     <b>All the topics on this project</b>
      #     <%= render project.topics %>
      #   <% end %>
      def cache_if(condition, name = {}, options = {}, &block)
        if condition
          cache(name, options, &block)
        else
          yield
        end

        nil
      end

      # Cache fragments of a view unless +condition+ is true
      #
      #   <% cache_unless admin?, project do %>
      #     <b>All the topics on this project</b>
      #     <%= render project.topics %>
      #   <% end %>
      def cache_unless(condition, name = {}, options = {}, &block)
        cache_if !condition, name, options, &block
      end

      # This helper returns the name of a cache key for a given fragment cache
      # call. By supplying +skip_digest:+ true to cache, the digestion of cache
      # fragments can be manually bypassed. This is useful when cache fragments
      # cannot be manually expired unless you know the exact key which is the
      # case when using memcached.
      #
      # The digest will be generated using +virtual_path:+ if it is provided.
      #
      def cache_fragment_name(name = {}, skip_digest: nil, virtual_path: nil)
        if skip_digest
          name
        else
          fragment_name_with_digest(name, virtual_path)
        end
      end

    private

      def fragment_name_with_digest(name, virtual_path) #:nodoc:
        virtual_path ||= @virtual_path
        if virtual_path
          name  = controller.url_for(name).split("://").last if name.is_a?(Hash)
          digest = Digestor.digest name: virtual_path, finder: lookup_context, dependencies: view_cache_dependencies
          [ name, digest ]
        else
          name
        end
      end

      # TODO: Create an object that has caching read/write on it
      def fragment_for(name = {}, options = nil, &block) #:nodoc:
        if content = read_fragment_for(name, options)
          @log_payload_for_partial_render[:cache_hit] = true if defined?(@log_payload_for_partial_render)
          content
        else
          @log_payload_for_partial_render[:cache_hit] = false if defined?(@log_payload_for_partial_render)
          write_fragment_for(name, options, &block)
        end
      end

      def read_fragment_for(name, options) #:nodoc:
        controller.read_fragment(name, options)
      end

      def write_fragment_for(name, options) #:nodoc:
        # VIEW TODO: Make #capture usable outside of ERB
        # This dance is needed because Builder can't use capture
        pos = output_buffer.length
        yield
        output_safe = output_buffer.html_safe?
        fragment = output_buffer.slice!(pos..-1)
        if output_safe
          self.output_buffer = output_buffer.class.new(output_buffer)
        end
        controller.write_fragment(name, fragment, options)
      end
    end
  end
end
require "cases/helper"

module ActiveRecord
  class CacheKeyTest < ActiveRecord::TestCase
    self.use_transactional_tests = false

    class CacheMe < ActiveRecord::Base; end

    setup do
      @connection = ActiveRecord::Base.connection
      @connection.create_table(:cache_mes) { |t| t.timestamps }
    end

    teardown do
      @connection.drop_table :cache_mes, if_exists: true
    end

    test "test_cache_key_format_is_not_too_precise" do
      record = CacheMe.create
      key = record.cache_key

      assert_equal key, record.reload.cache_key
    end
  end
end
module ActionDispatch
  module Http
    module Cache
      module Request
        HTTP_IF_MODIFIED_SINCE = "HTTP_IF_MODIFIED_SINCE".freeze
        HTTP_IF_NONE_MATCH     = "HTTP_IF_NONE_MATCH".freeze

        def if_modified_since
          if since = get_header(HTTP_IF_MODIFIED_SINCE)
            Time.rfc2822(since) rescue nil
          end
        end

        def if_none_match
          get_header HTTP_IF_NONE_MATCH
        end

        def if_none_match_etags
          if_none_match ? if_none_match.split(/\s*,\s*/) : []
        end

        def not_modified?(modified_at)
          if_modified_since && modified_at && if_modified_since >= modified_at
        end

        def etag_matches?(etag)
          if etag
            validators = if_none_match_etags
            validators.include?(etag) || validators.include?("*")
          end
        end

        # Check response freshness (Last-Modified and ETag) against request
        # If-Modified-Since and If-None-Match conditions. If both headers are
        # supplied, both must match, or the request is not considered fresh.
        def fresh?(response)
          last_modified = if_modified_since
          etag          = if_none_match

          return false unless last_modified || etag

          success = true
          success &&= not_modified?(response.last_modified) if last_modified
          success &&= etag_matches?(response.etag) if etag
          success
        end
      end

      module Response
        attr_reader :cache_control

        def last_modified
          if last = get_header(LAST_MODIFIED)
            Time.httpdate(last)
          end
        end

        def last_modified?
          has_header? LAST_MODIFIED
        end

        def last_modified=(utc_time)
          set_header LAST_MODIFIED, utc_time.httpdate
        end

        def date
          if date_header = get_header(DATE)
            Time.httpdate(date_header)
          end
        end

        def date?
          has_header? DATE
        end

        def date=(utc_time)
          set_header DATE, utc_time.httpdate
        end

        # This method sets a weak ETag validator on the response so browsers
        # and proxies may cache the response, keyed on the ETag. On subsequent
        # requests, the If-None-Match header is set to the cached ETag. If it
        # matches the current ETag, we can return a 304 Not Modified response
        # with no body, letting the browser or proxy know that their cache is
        # current. Big savings in request time and network bandwidth.
        #
        # Weak ETags are considered to be semantically equivalent but not
        # byte-for-byte identical. This is perfect for browser caching of HTML
        # pages where we don't care about exact equality, just what the user
        # is viewing.
        #
        # Strong ETags are considered byte-for-byte identical. They allow a
        # browser or proxy cache to support Range requests, useful for paging
        # through a PDF file or scrubbing through a video. Some CDNs only
        # support strong ETags and will ignore weak ETags entirely.
        #
        # Weak ETags are what we almost always need, so they're the default.
        # Check out `#strong_etag=` to provide a strong ETag validator.
        def etag=(weak_validators)
          self.weak_etag = weak_validators
        end

        def weak_etag=(weak_validators)
          set_header "ETag", generate_weak_etag(weak_validators)
        end

        def strong_etag=(strong_validators)
          set_header "ETag", generate_strong_etag(strong_validators)
        end

        def etag?; etag; end

        # True if an ETag is set and it's a weak validator (preceded with W/)
        def weak_etag?
          etag? && etag.starts_with?('W/"')
        end

        # True if an ETag is set and it isn't a weak validator (not preceded with W/)
        def strong_etag?
          etag? && !weak_etag?
        end

      private

        DATE          = "Date".freeze
        LAST_MODIFIED = "Last-Modified".freeze
        SPECIAL_KEYS  = Set.new(%w[extras no-cache max-age public private must-revalidate])

        def generate_weak_etag(validators)
          "W/#{generate_strong_etag(validators)}"
        end

        def generate_strong_etag(validators)
          %("#{Digest::MD5.hexdigest(ActiveSupport::Cache.expand_cache_key(validators))}")
        end

        def cache_control_segments
          if cache_control = _cache_control
            cache_control.delete(" ").split(",")
          else
            []
          end
        end

        def cache_control_headers
          cache_control = {}

          cache_control_segments.each do |segment|
            directive, argument = segment.split("=", 2)

            if SPECIAL_KEYS.include? directive
              key = directive.tr("-", "_")
              cache_control[key.to_sym] = argument || true
            else
              cache_control[:extras] ||= []
              cache_control[:extras] << segment
            end
          end

          cache_control
        end

        def prepare_cache_control!
          @cache_control = cache_control_headers
        end

        def handle_conditional_get!
          if etag? || last_modified? || !@cache_control.empty?
            set_conditional_cache_control!(@cache_control)
          end
        end

        DEFAULT_CACHE_CONTROL = "max-age=0, private, must-revalidate".freeze
        NO_CACHE              = "no-cache".freeze
        PUBLIC                = "public".freeze
        PRIVATE               = "private".freeze
        MUST_REVALIDATE       = "must-revalidate".freeze

        def set_conditional_cache_control!(cache_control)
          control = {}
          cc_headers = cache_control_headers
          if extras = cc_headers.delete(:extras)
            cache_control[:extras] ||= []
            cache_control[:extras] += extras
            cache_control[:extras].uniq!
          end

          control.merge! cc_headers
          control.merge! cache_control

          if control.empty?
            self._cache_control = DEFAULT_CACHE_CONTROL
          elsif control[:no_cache]
            self._cache_control = NO_CACHE
            if control[:extras]
              self._cache_control = _cache_control + ", #{control[:extras].join(', ')}"
            end
          else
            extras  = control[:extras]
            max_age = control[:max_age]

            options = []
            options << "max-age=#{max_age.to_i}" if max_age
            options << (control[:public] ? PUBLIC : PRIVATE)
            options << MUST_REVALIDATE if control[:must_revalidate]
            options.concat(extras) if extras

            self._cache_control = options.join(", ")
          end
        end
      end
    end
  end
end
require "action_dispatch/middleware/session/abstract_store"

module ActionDispatch
  module Session
    # A session store that uses an ActiveSupport::Cache::Store to store the sessions. This store is most useful
    # if you don't store critical data in your sessions and you don't need them to live for extended periods
    # of time.
    #
    # ==== Options
    # * <tt>cache</tt>         - The cache to use. If it is not specified, <tt>Rails.cache</tt> will be used.
    # * <tt>expire_after</tt>  - The length of time a session will be stored before automatically expiring.
    #   By default, the <tt>:expires_in</tt> option of the cache is used.
    class CacheStore < AbstractStore
      def initialize(app, options = {})
        @cache = options[:cache] || Rails.cache
        options[:expire_after] ||= @cache.options[:expires_in]
        super
      end

      # Get a session from the cache.
      def find_session(env, sid)
        unless sid and session = @cache.read(cache_key(sid))
          sid, session = generate_sid, {}
        end
        [sid, session]
      end

      # Set a session in the cache.
      def write_session(env, sid, session, options)
        key = cache_key(sid)
        if session
          @cache.write(key, session, expires_in: options[:expire_after])
        else
          @cache.delete(key)
        end
        sid
      end

      # Remove a session from the cache.
      def delete_session(env, sid, options)
        @cache.delete(cache_key(sid))
        generate_sid
      end

      private
        # Turn the session id into a cache key.
        def cache_key(sid)
          "_session_id:#{sid}"
        end
    end
  end
end
require "abstract_unit"
require "fixtures/session_autoload_test/session_autoload_test/foo"

class CacheStoreTest < ActionDispatch::IntegrationTest
  class TestController < ActionController::Base
    def no_session_access
      head :ok
    end

    def set_session_value
      session[:foo] = "bar"
      head :ok
    end

    def set_serialized_session_value
      session[:foo] = SessionAutoloadTest::Foo.new
      head :ok
    end

    def get_session_value
      render plain: "foo: #{session[:foo].inspect}"
    end

    def get_session_id
      render plain: "#{request.session.id}"
    end

    def call_reset_session
      session[:bar]
      reset_session
      session[:bar] = "baz"
      head :ok
    end
  end

  def test_setting_and_getting_session_value
    with_test_route_set do
      get "/set_session_value"
      assert_response :success
      assert cookies["_session_id"]

      get "/get_session_value"
      assert_response :success
      assert_equal 'foo: "bar"', response.body
    end
  end

  def test_getting_nil_session_value
    with_test_route_set do
      get "/get_session_value"
      assert_response :success
      assert_equal "foo: nil", response.body
    end
  end

  def test_getting_session_value_after_session_reset
    with_test_route_set do
      get "/set_session_value"
      assert_response :success
      assert cookies["_session_id"]
      session_cookie = cookies.send(:hash_for)["_session_id"]

      get "/call_reset_session"
      assert_response :success
      assert_not_equal [], headers["Set-Cookie"]

      cookies << session_cookie # replace our new session_id with our old, pre-reset session_id

      get "/get_session_value"
      assert_response :success
      assert_equal "foo: nil", response.body, "data for this session should have been obliterated from cache"
    end
  end

  def test_getting_from_nonexistent_session
    with_test_route_set do
      get "/get_session_value"
      assert_response :success
      assert_equal "foo: nil", response.body
      assert_nil cookies["_session_id"], "should only create session on write, not read"
    end
  end

  def test_setting_session_value_after_session_reset
    with_test_route_set do
      get "/set_session_value"
      assert_response :success
      assert cookies["_session_id"]
      session_id = cookies["_session_id"]

      get "/call_reset_session"
      assert_response :success
      assert_not_equal [], headers["Set-Cookie"]

      get "/get_session_value"
      assert_response :success
      assert_equal "foo: nil", response.body

      get "/get_session_id"
      assert_response :success
      assert_not_equal session_id, response.body
    end
  end

  def test_getting_session_id
    with_test_route_set do
      get "/set_session_value"
      assert_response :success
      assert cookies["_session_id"]
      session_id = cookies["_session_id"]

      get "/get_session_id"
      assert_response :success
      assert_equal session_id, response.body, "should be able to read session id without accessing the session hash"
    end
  end

  def test_deserializes_unloaded_class
    with_test_route_set do
      with_autoload_path "session_autoload_test" do
        get "/set_serialized_session_value"
        assert_response :success
        assert cookies["_session_id"]
      end
      with_autoload_path "session_autoload_test" do
        get "/get_session_id"
        assert_response :success
      end
      with_autoload_path "session_autoload_test" do
        get "/get_session_value"
        assert_response :success
        assert_equal 'foo: #<SessionAutoloadTest::Foo bar:"baz">', response.body, "should auto-load unloaded class"
      end
    end
  end

  def test_doesnt_write_session_cookie_if_session_id_is_already_exists
    with_test_route_set do
      get "/set_session_value"
      assert_response :success
      assert cookies["_session_id"]

      get "/get_session_value"
      assert_response :success
      assert_equal nil, headers["Set-Cookie"], "should not resend the cookie again if session_id cookie is already exists"
    end
  end

  def test_prevents_session_fixation
    with_test_route_set do
      assert_equal nil, @cache.read("_session_id:0xhax")

      cookies["_session_id"] = "0xhax"
      get "/set_session_value"

      assert_response :success
      assert_not_equal "0xhax", cookies["_session_id"]
      assert_equal nil, @cache.read("_session_id:0xhax")
      assert_equal({"foo" => "bar"}, @cache.read("_session_id:#{cookies['_session_id']}"))
    end
  end

  private
    def with_test_route_set
      with_routing do |set|
        set.draw do
          ActiveSupport::Deprecation.silence do
            get ":action", to: ::CacheStoreTest::TestController
          end
        end

        @app = self.class.build_app(set) do |middleware|
          @cache = ActiveSupport::Cache::MemoryStore.new
          middleware.use ActionDispatch::Session::CacheStore, key: "_session_id", cache: @cache
          middleware.delete ActionDispatch::ShowExceptions
        end

        yield
      end
    end
end
require "isolation/abstract_unit"

module ApplicationTests
  class CacheTest < ActiveSupport::TestCase
    include ActiveSupport::Testing::Isolation

    def setup
      build_app
      require "rack/test"
      extend Rack::Test::Methods
    end

    def teardown
      teardown_app
    end

    def simple_controller
      controller :expires, <<-RUBY
        class ExpiresController < ApplicationController
          def expires_header
            expires_in 10, public: !params[:private]
            render text: SecureRandom.hex(16)
          end

          def expires_etag
            render_conditionally(etag: "1")
          end

          def expires_last_modified
            $last_modified ||= Time.now.utc
            render_conditionally(last_modified: $last_modified)
          end

          def keeps_if_modified_since
            render :text => request.headers['If-Modified-Since']
          end
        private
          def render_conditionally(headers)
            if stale?(headers.merge(public: !params[:private]))
              render text: SecureRandom.hex(16)
            end
          end
        end
      RUBY

      app_file "config/routes.rb", <<-RUBY
        Rails.application.routes.draw do
          get ':controller(/:action)'
        end
      RUBY
    end

    def test_cache_keeps_if_modified_since
      simple_controller
      expected = "Wed, 30 May 1984 19:43:31 GMT"

      get "/expires/keeps_if_modified_since", {}, "HTTP_IF_MODIFIED_SINCE" => expected

      assert_equal 200, last_response.status
      assert_equal expected, last_response.body, "cache should have kept If-Modified-Since"
    end

    def test_cache_is_disabled_in_dev_mode
      simple_controller
      app("development")

      get "/expires/expires_header"
      assert_nil last_response.headers["X-Rack-Cache"]

      body = last_response.body

      get "/expires/expires_header"
      assert_nil last_response.headers["X-Rack-Cache"]
      assert_not_equal body, last_response.body
    end

    def test_cache_works_with_expires
      simple_controller

      add_to_config "config.action_dispatch.rack_cache = true"

      get "/expires/expires_header"
      assert_equal "miss, store", last_response.headers["X-Rack-Cache"]
      assert_equal "max-age=10, public", last_response.headers["Cache-Control"]

      body = last_response.body

      get "/expires/expires_header"

      assert_equal "fresh", last_response.headers["X-Rack-Cache"]

      assert_equal body, last_response.body
    end

    def test_cache_works_with_expires_private
      simple_controller

      add_to_config "config.action_dispatch.rack_cache = true"

      get "/expires/expires_header", private: true
      assert_equal "miss",                last_response.headers["X-Rack-Cache"]
      assert_equal "private, max-age=10", last_response.headers["Cache-Control"]

      body = last_response.body

      get "/expires/expires_header", private: true
      assert_equal "miss",           last_response.headers["X-Rack-Cache"]
      assert_not_equal body,         last_response.body
    end

    def test_cache_works_with_etags
      simple_controller

      add_to_config "config.action_dispatch.rack_cache = true"

      get "/expires/expires_etag"
      assert_equal "miss, store", last_response.headers["X-Rack-Cache"]
      assert_equal "public", last_response.headers["Cache-Control"]

      body = last_response.body
      etag = last_response.headers["ETag"]

      get "/expires/expires_etag", {}, "If-None-Match" => etag
      assert_equal "stale, valid, store", last_response.headers["X-Rack-Cache"]
      assert_equal body,                  last_response.body
    end

    def test_cache_works_with_etags_private
      simple_controller

      add_to_config "config.action_dispatch.rack_cache = true"

      get "/expires/expires_etag", private: true
      assert_equal "miss",                                last_response.headers["X-Rack-Cache"]
      assert_equal "must-revalidate, private, max-age=0", last_response.headers["Cache-Control"]

      body = last_response.body
      etag = last_response.headers["ETag"]

      get "/expires/expires_etag", {private: true}, "If-None-Match" => etag
      assert_equal     "miss", last_response.headers["X-Rack-Cache"]
      assert_not_equal body,   last_response.body
    end

    def test_cache_works_with_last_modified
      simple_controller

      add_to_config "config.action_dispatch.rack_cache = true"

      get "/expires/expires_last_modified"
      assert_equal "miss, store", last_response.headers["X-Rack-Cache"]
      assert_equal "public", last_response.headers["Cache-Control"]

      body = last_response.body
      last = last_response.headers["Last-Modified"]

      get "/expires/expires_last_modified", {}, "If-Modified-Since" => last
      assert_equal "stale, valid, store", last_response.headers["X-Rack-Cache"]
      assert_equal body,                  last_response.body
    end

    def test_cache_works_with_last_modified_private
      simple_controller

      add_to_config "config.action_dispatch.rack_cache = true"

      get "/expires/expires_last_modified", private: true
      assert_equal "miss",                                last_response.headers["X-Rack-Cache"]
      assert_equal "must-revalidate, private, max-age=0", last_response.headers["Cache-Control"]

      body = last_response.body
      last = last_response.headers["Last-Modified"]

      get "/expires/expires_last_modified", {private: true}, "If-Modified-Since" => last
      assert_equal     "miss", last_response.headers["X-Rack-Cache"]
      assert_not_equal body,   last_response.body
    end
  end
end
class CachingMailer < ActionMailer::Base
  self.mailer_name = "caching_mailer"

  def fragment_cache
    mail(subject: "welcome", template_name: "fragment_cache")
  end

  def fragment_cache_in_partials
    mail(subject: "welcome", template_name: "fragment_cache_in_partials")
  end

  def skip_fragment_cache_digesting
    mail(subject: "welcome", template_name: "skip_fragment_cache_digesting")
  end

  def fragment_caching_options
    mail(subject: "welcome", template_name: "fragment_caching_options")
  end

  def multipart_cache
    mail(subject: "welcome", template_name: "multipart_cache")
  end
end
module AbstractController
  module Caching
    extend ActiveSupport::Concern
    extend ActiveSupport::Autoload

    eager_autoload do
      autoload :Fragments
    end

    module ConfigMethods
      def cache_store
        config.cache_store
      end

      def cache_store=(store)
        config.cache_store = ActiveSupport::Cache.lookup_store(store)
      end

      private
        def cache_configured?
          perform_caching && cache_store
        end
    end

    include ConfigMethods
    include AbstractController::Caching::Fragments

    included do
      extend ConfigMethods

      config_accessor :default_static_extension
      self.default_static_extension ||= ".html"

      config_accessor :perform_caching
      self.perform_caching = true if perform_caching.nil?

      config_accessor :enable_fragment_cache_logging
      self.enable_fragment_cache_logging = false

      class_attribute :_view_cache_dependencies
      self._view_cache_dependencies = []
      helper_method :view_cache_dependencies if respond_to?(:helper_method)
    end

    module ClassMethods
      def view_cache_dependency(&dependency)
        self._view_cache_dependencies += [dependency]
      end
    end

    def view_cache_dependencies
      self.class._view_cache_dependencies.map { |dep| instance_exec(&dep) }.compact
    end

    protected
      # Convenience accessor.
      def cache(key, options = {}, &block)
        if cache_configured?
          cache_store.fetch(ActiveSupport::Cache.expand_cache_key(key, :controller), options, &block)
        else
          yield
        end
      end
  end
end
require "fileutils"
require "abstract_unit"
require "lib/controller/fake_models"

CACHE_DIR = "test_cache"
# Don't change '/../temp/' cavalierly or you might hose something you don't want hosed
FILE_STORE_PATH = File.join(File.dirname(__FILE__), "/../temp/", CACHE_DIR)

class FragmentCachingMetalTestController < ActionController::Metal
  abstract!

  include ActionController::Caching

  def some_action; end
end

class FragmentCachingMetalTest < ActionController::TestCase
  def setup
    super
    @store = ActiveSupport::Cache::MemoryStore.new
    @controller = FragmentCachingMetalTestController.new
    @controller.perform_caching = true
    @controller.cache_store = @store
    @params = { controller: "posts", action: "index" }
    @controller.params = @params
    @controller.request = @request
    @controller.response = @response
  end

  def test_fragment_cache_key
    assert_equal "views/what a key", @controller.fragment_cache_key("what a key")
  end
end

class CachingController < ActionController::Base
  abstract!

  self.cache_store = :file_store, FILE_STORE_PATH
end

class FragmentCachingTestController < CachingController
  def some_action; end
end

class FragmentCachingTest < ActionController::TestCase
  def setup
    super
    @store = ActiveSupport::Cache::MemoryStore.new
    @controller = FragmentCachingTestController.new
    @controller.perform_caching = true
    @controller.cache_store = @store
    @params = {controller: "posts", action: "index"}
    @controller.params = @params
    @controller.request = @request
    @controller.response = @response
  end

  def test_fragment_cache_key
    assert_equal "views/what a key", @controller.fragment_cache_key("what a key")
    assert_equal "views/test.host/fragment_caching_test/some_action",
                  @controller.fragment_cache_key(controller: "fragment_caching_test",action: "some_action")
  end

  def test_read_fragment_with_caching_enabled
    @store.write("views/name", "value")
    assert_equal "value", @controller.read_fragment("name")
  end

  def test_read_fragment_with_caching_disabled
    @controller.perform_caching = false
    @store.write("views/name", "value")
    assert_nil @controller.read_fragment("name")
  end

  def test_fragment_exist_with_caching_enabled
    @store.write("views/name", "value")
    assert @controller.fragment_exist?("name")
    assert !@controller.fragment_exist?("other_name")
  end

  def test_fragment_exist_with_caching_disabled
    @controller.perform_caching = false
    @store.write("views/name", "value")
    assert !@controller.fragment_exist?("name")
    assert !@controller.fragment_exist?("other_name")
  end

  def test_write_fragment_with_caching_enabled
    assert_nil @store.read("views/name")
    assert_equal "value", @controller.write_fragment("name", "value")
    assert_equal "value", @store.read("views/name")
  end

  def test_write_fragment_with_caching_disabled
    assert_nil @store.read("views/name")
    @controller.perform_caching = false
    assert_equal "value", @controller.write_fragment("name", "value")
    assert_nil @store.read("views/name")
  end

  def test_expire_fragment_with_simple_key
    @store.write("views/name", "value")
    @controller.expire_fragment "name"
    assert_nil @store.read("views/name")
  end

  def test_expire_fragment_with_regexp
    @store.write("views/name", "value")
    @store.write("views/another_name", "another_value")
    @store.write("views/primalgrasp", "will not expire ;-)")

    @controller.expire_fragment(/name/)

    assert_nil @store.read("views/name")
    assert_nil @store.read("views/another_name")
    assert_equal "will not expire ;-)", @store.read("views/primalgrasp")
  end

  def test_fragment_for
    @store.write("views/expensive", "fragment content")
    fragment_computed = false

    view_context = @controller.view_context

    buffer = "generated till now -> ".html_safe
    buffer << view_context.send(:fragment_for, "expensive") { fragment_computed = true }

    assert !fragment_computed
    assert_equal "generated till now -> fragment content", buffer
  end

  def test_html_safety
    assert_nil @store.read("views/name")
    content = "value".html_safe
    assert_equal content, @controller.write_fragment("name", content)

    cached = @store.read("views/name")
    assert_equal content, cached
    assert_equal String, cached.class

    html_safe = @controller.read_fragment("name")
    assert_equal content, html_safe
    assert html_safe.html_safe?
  end
end

class FunctionalCachingController < CachingController
  def fragment_cached
  end

  def html_fragment_cached_with_partial
    respond_to do |format|
      format.html
    end
  end

  def formatted_fragment_cached
    respond_to do |format|
      format.html
      format.xml
    end
  end

  def formatted_fragment_cached_with_variant
    request.variant = :phone if params[:v] == "phone"

    respond_to do |format|
      format.html.phone
      format.html
    end
  end

  def fragment_cached_without_digest
  end

  def fragment_cached_with_options
  end
end

class FunctionalFragmentCachingTest < ActionController::TestCase
  def setup
    super
    @store = ActiveSupport::Cache::MemoryStore.new
    @controller = FunctionalCachingController.new
    @controller.perform_caching = true
    @controller.cache_store = @store
    @controller.enable_fragment_cache_logging = true
  end

  def test_fragment_caching
    get :fragment_cached
    assert_response :success
    expected_body = <<-CACHED
Hello
This bit's fragment cached
Ciao
CACHED
    assert_equal expected_body, @response.body

    assert_equal "This bit's fragment cached",
      @store.read("views/test.host/functional_caching/fragment_cached/#{template_digest("functional_caching/fragment_cached")}")
  end

  def test_fragment_caching_in_partials
    get :html_fragment_cached_with_partial
    assert_response :success
    assert_match(/Old fragment caching in a partial/, @response.body)

    assert_match("Old fragment caching in a partial",
      @store.read("views/test.host/functional_caching/html_fragment_cached_with_partial/#{template_digest("functional_caching/_partial")}"))
  end

  def test_skipping_fragment_cache_digesting
    get :fragment_cached_without_digest, format: "html"
    assert_response :success
    expected_body = "<body>\n<p>ERB</p>\n</body>\n"

    assert_equal expected_body, @response.body
    assert_equal "<p>ERB</p>", @store.read("views/nodigest")
  end

  def test_fragment_caching_with_options
    time = Time.now
    get :fragment_cached_with_options
    assert_response :success
    expected_body = "<body>\n<p>ERB</p>\n</body>\n"

    assert_equal expected_body, @response.body
    Time.stub(:now, time + 11) do
      assert_nil @store.read("views/with_options")
    end
  end

  def test_render_inline_before_fragment_caching
    get :inline_fragment_cached
    assert_response :success
    assert_match(/Some inline content/, @response.body)
    assert_match(/Some cached content/, @response.body)
    assert_match("Some cached content",
      @store.read("views/test.host/functional_caching/inline_fragment_cached/#{template_digest("functional_caching/inline_fragment_cached")}"))
  end

  def test_fragment_cache_instrumentation
    payload = nil

    subscriber = proc do |*args|
      event = ActiveSupport::Notifications::Event.new(*args)
      payload = event.payload
    end

    ActiveSupport::Notifications.subscribed(subscriber, "read_fragment.action_controller") do
      get :inline_fragment_cached
    end

    assert_equal "functional_caching", payload[:controller]
    assert_equal "inline_fragment_cached", payload[:action]
  end

  def test_html_formatted_fragment_caching
    get :formatted_fragment_cached, format: "html"
    assert_response :success
    expected_body = "<body>\n<p>ERB</p>\n</body>\n"

    assert_equal expected_body, @response.body

    assert_equal "<p>ERB</p>",
      @store.read("views/test.host/functional_caching/formatted_fragment_cached/#{template_digest("functional_caching/formatted_fragment_cached")}")
  end

  def test_xml_formatted_fragment_caching
    get :formatted_fragment_cached, format: "xml"
    assert_response :success
    expected_body = "<body>\n  <p>Builder</p>\n</body>\n"

    assert_equal expected_body, @response.body

    assert_equal "  <p>Builder</p>\n",
      @store.read("views/test.host/functional_caching/formatted_fragment_cached/#{template_digest("functional_caching/formatted_fragment_cached")}")
  end

  def test_fragment_caching_with_variant
    get :formatted_fragment_cached_with_variant, format: "html", params: { v: :phone }
    assert_response :success
    expected_body = "<body>\n<p>PHONE</p>\n</body>\n"

    assert_equal expected_body, @response.body

    assert_equal "<p>PHONE</p>",
      @store.read("views/test.host/functional_caching/formatted_fragment_cached_with_variant/#{template_digest("functional_caching/formatted_fragment_cached_with_variant")}")
  end

  private
    def template_digest(name)
      ActionView::Digestor.digest(name: name, finder: @controller.lookup_context)
    end
end

class CacheHelperOutputBufferTest < ActionController::TestCase
  class MockController
    def read_fragment(name, options)
      return false
    end

    def write_fragment(name, fragment, options)
      fragment
    end
  end

  def setup
    super
  end

  def test_output_buffer
    output_buffer = ActionView::OutputBuffer.new
    controller = MockController.new
    cache_helper = Class.new do
      def self.controller; end;
      def self.output_buffer; end;
      def self.output_buffer=; end;
    end
    cache_helper.extend(ActionView::Helpers::CacheHelper)

    cache_helper.stub :controller, controller do
      cache_helper.stub :output_buffer, output_buffer do
        assert_called_with cache_helper, :output_buffer=, [output_buffer.class.new(output_buffer)] do
          assert_nothing_raised do
            cache_helper.send :fragment_for, "Test fragment name", "Test fragment", &Proc.new{ nil }
          end
        end
      end
    end
  end

  def test_safe_buffer
    output_buffer = ActiveSupport::SafeBuffer.new
    controller = MockController.new
    cache_helper = Class.new do
      def self.controller; end;
      def self.output_buffer; end;
      def self.output_buffer=; end;
    end
    cache_helper.extend(ActionView::Helpers::CacheHelper)

    cache_helper.stub :controller, controller do
      cache_helper.stub :output_buffer, output_buffer do
        assert_called_with cache_helper, :output_buffer=, [output_buffer.class.new(output_buffer)] do
          assert_nothing_raised do
            cache_helper.send :fragment_for, "Test fragment name", "Test fragment", &Proc.new{ nil }
          end
        end
      end
    end
  end
end

class ViewCacheDependencyTest < ActionController::TestCase
  class NoDependenciesController < ActionController::Base
  end

  class HasDependenciesController < ActionController::Base
    view_cache_dependency { "trombone" }
    view_cache_dependency { "flute" }
  end

  def test_view_cache_dependencies_are_empty_by_default
    assert NoDependenciesController.new.view_cache_dependencies.empty?
  end

  def test_view_cache_dependencies_are_listed_in_declaration_order
    assert_equal %w(trombone flute), HasDependenciesController.new.view_cache_dependencies
  end
end

class CollectionCacheController < ActionController::Base
  attr_accessor :partial_rendered_times

  def index
    @customers = [Customer.new("david", params[:id] || 1)]
  end

  def index_ordered
    @customers = [Customer.new("david", 1), Customer.new("david", 2), Customer.new("david", 3)]
    render "index"
  end

  def index_explicit_render_in_controller
    @customers = [Customer.new("david", 1)]
    render partial: "customers/customer", collection: @customers, cached: true
  end

  def index_with_comment
    @customers = [Customer.new("david", 1)]
    render partial: "customers/commented_customer", collection: @customers, as: :customer, cached: true
  end

  def index_with_callable_cache_key
    @customers = [Customer.new("david", 1)]
    render partial: "customers/customer", collection: @customers, cached: -> customer { "cached_david" }
  end
end

class CollectionCacheTest < ActionController::TestCase
  def setup
    super
    @controller = CollectionCacheController.new
    @controller.perform_caching = true
    @controller.partial_rendered_times = 0
    @controller.cache_store = ActiveSupport::Cache::MemoryStore.new
    ActionView::PartialRenderer.collection_cache = ActiveSupport::Cache::MemoryStore.new
  end

  def test_collection_fetches_cached_views
    get :index
    assert_equal 1, @controller.partial_rendered_times
    assert_customer_cached "david/1", "david, 1"

    get :index
    assert_equal 1, @controller.partial_rendered_times
  end

  def test_preserves_order_when_reading_from_cache_plus_rendering
    get :index, params: { id: 2 }
    assert_equal 1, @controller.partial_rendered_times
    assert_select ":root", "david, 2"

    get :index_ordered
    assert_equal 3, @controller.partial_rendered_times
    assert_select ":root", "david, 1\n  david, 2\n  david, 3"
  end

  def test_explicit_render_call_with_options
    get :index_explicit_render_in_controller

    assert_select ":root", "david, 1"
  end

  def test_caching_works_with_beginning_comment
    get :index_with_comment
    assert_equal 1, @controller.partial_rendered_times

    get :index_with_comment
    assert_equal 1, @controller.partial_rendered_times
  end

  def test_caching_with_callable_cache_key
    get :index_with_callable_cache_key
    assert_customer_cached "cached_david", "david, 1"
  end

  private
    def assert_customer_cached(key, content)
      assert_match content,
        ActionView::PartialRenderer.collection_cache.read("views/#{key}/7c228ab609f0baf0b1f2367469210937")
    end
end

class FragmentCacheKeyTestController < CachingController
  attr_accessor :account_id

  fragment_cache_key "v1"
  fragment_cache_key { account_id }
end

class FragmentCacheKeyTest < ActionController::TestCase
  def setup
    super
    @store = ActiveSupport::Cache::MemoryStore.new
    @controller = FragmentCacheKeyTestController.new
    @controller.perform_caching = true
    @controller.cache_store = @store
  end

  def test_fragment_cache_key
    @controller.account_id = "123"
    assert_equal "views/v1/123/what a key", @controller.fragment_cache_key("what a key")

    @controller.account_id = nil
    assert_equal "views/v1//what a key", @controller.fragment_cache_key("what a key")
  end
end
class CakeDesigner < ActiveRecord::Base
  has_one :chef, as: :employable
end
require "active_support/core_ext/object/try"

module DateAndTime
  module Calculations
    DAYS_INTO_WEEK = {
      monday: 0,
      tuesday: 1,
      wednesday: 2,
      thursday: 3,
      friday: 4,
      saturday: 5,
      sunday: 6
    }
    WEEKEND_DAYS = [ 6, 0 ]

    # Returns a new date/time representing yesterday.
    def yesterday
      advance(days: -1)
    end

    # Returns a new date/time representing the previous day.
    def prev_day
      advance(days: -1)
    end

    # Returns a new date/time representing tomorrow.
    def tomorrow
      advance(days: 1)
    end

    # Returns a new date/time representing the next day.
    def next_day
      advance(days: 1)
    end

    # Returns true if the date/time is today.
    def today?
      to_date == ::Date.current
    end

    # Returns true if the date/time is in the past.
    def past?
      self < self.class.current
    end

    # Returns true if the date/time is in the future.
    def future?
      self > self.class.current
    end

    # Returns true if the date/time falls on a Saturday or Sunday.
    def on_weekend?
      WEEKEND_DAYS.include?(wday)
    end

    # Returns true if the date/time does not fall on a Saturday or Sunday.
    def on_weekday?
      !WEEKEND_DAYS.include?(wday)
    end

    # Returns a new date/time the specified number of days ago.
    def days_ago(days)
      advance(days: -days)
    end

    # Returns a new date/time the specified number of days in the future.
    def days_since(days)
      advance(days: days)
    end

    # Returns a new date/time the specified number of weeks ago.
    def weeks_ago(weeks)
      advance(weeks: -weeks)
    end

    # Returns a new date/time the specified number of weeks in the future.
    def weeks_since(weeks)
      advance(weeks: weeks)
    end

    # Returns a new date/time the specified number of months ago.
    def months_ago(months)
      advance(months: -months)
    end

    # Returns a new date/time the specified number of months in the future.
    def months_since(months)
      advance(months: months)
    end

    # Returns a new date/time the specified number of years ago.
    def years_ago(years)
      advance(years: -years)
    end

    # Returns a new date/time the specified number of years in the future.
    def years_since(years)
      advance(years: years)
    end

    # Returns a new date/time at the start of the month.
    #
    #   today = Date.today # => Thu, 18 Jun 2015
    #   today.beginning_of_month # => Mon, 01 Jun 2015
    #
    # +DateTime+ objects will have a time set to 0:00.
    #
    #   now = DateTime.current # => Thu, 18 Jun 2015 15:23:13 +0000
    #   now.beginning_of_month # => Mon, 01 Jun 2015 00:00:00 +0000
    def beginning_of_month
      first_hour(change(day: 1))
    end
    alias :at_beginning_of_month :beginning_of_month

    # Returns a new date/time at the start of the quarter.
    #
    #   today = Date.today # => Fri, 10 Jul 2015
    #   today.beginning_of_quarter # => Wed, 01 Jul 2015
    #
    # +DateTime+ objects will have a time set to 0:00.
    #
    #   now = DateTime.current # => Fri, 10 Jul 2015 18:41:29 +0000
    #   now.beginning_of_quarter # => Wed, 01 Jul 2015 00:00:00 +0000
    def beginning_of_quarter
      first_quarter_month = [10, 7, 4, 1].detect { |m| m <= month }
      beginning_of_month.change(month: first_quarter_month)
    end
    alias :at_beginning_of_quarter :beginning_of_quarter

    # Returns a new date/time at the end of the quarter.
    #
    #   today = Date.today # => Fri, 10 Jul 2015
    #   today.end_of_quarter # => Wed, 30 Sep 2015
    #
    # +DateTime+ objects will have a time set to 23:59:59.
    #
    #   now = DateTime.current # => Fri, 10 Jul 2015 18:41:29 +0000
    #   now.end_of_quarter # => Wed, 30 Sep 2015 23:59:59 +0000
    def end_of_quarter
      last_quarter_month = [3, 6, 9, 12].detect { |m| m >= month }
      beginning_of_month.change(month: last_quarter_month).end_of_month
    end
    alias :at_end_of_quarter :end_of_quarter

    # Returns a new date/time at the beginning of the year.
    #
    #   today = Date.today # => Fri, 10 Jul 2015
    #   today.beginning_of_year # => Thu, 01 Jan 2015
    #
    # +DateTime+ objects will have a time set to 0:00.
    #
    #   now = DateTime.current # => Fri, 10 Jul 2015 18:41:29 +0000
    #   now.beginning_of_year # => Thu, 01 Jan 2015 00:00:00 +0000
    def beginning_of_year
      change(month: 1).beginning_of_month
    end
    alias :at_beginning_of_year :beginning_of_year

    # Returns a new date/time representing the given day in the next week.
    #
    #   today = Date.today # => Thu, 07 May 2015
    #   today.next_week    # => Mon, 11 May 2015
    #
    # The +given_day_in_next_week+ defaults to the beginning of the week
    # which is determined by +Date.beginning_of_week+ or +config.beginning_of_week+
    # when set.
    #
    #   today = Date.today       # => Thu, 07 May 2015
    #   today.next_week(:friday) # => Fri, 15 May 2015
    #
    # +DateTime+ objects have their time set to 0:00 unless +same_time+ is true.
    #
    #   now = DateTime.current # => Thu, 07 May 2015 13:31:16 +0000
    #   now.next_week      # => Mon, 11 May 2015 00:00:00 +0000
    def next_week(given_day_in_next_week = Date.beginning_of_week, same_time: false)
      result = first_hour(weeks_since(1).beginning_of_week.days_since(days_span(given_day_in_next_week)))
      same_time ? copy_time_to(result) : result
    end

    # Returns a new date/time representing the next weekday.
    def next_weekday
      if next_day.on_weekend?
        next_week(:monday, same_time: true)
      else
        next_day
      end
    end

    # Short-hand for months_since(1).
    def next_month
      months_since(1)
    end

    # Short-hand for months_since(3)
    def next_quarter
      months_since(3)
    end

    # Short-hand for years_since(1).
    def next_year
      years_since(1)
    end

    # Returns a new date/time representing the given day in the previous week.
    # Week is assumed to start on +start_day+, default is
    # +Date.beginning_of_week+ or +config.beginning_of_week+ when set.
    # DateTime objects have their time set to 0:00 unless +same_time+ is true.
    def prev_week(start_day = Date.beginning_of_week, same_time: false)
      result = first_hour(weeks_ago(1).beginning_of_week.days_since(days_span(start_day)))
      same_time ? copy_time_to(result) : result
    end
    alias_method :last_week, :prev_week

    # Returns a new date/time representing the previous weekday.
    def prev_weekday
      if prev_day.on_weekend?
        copy_time_to(beginning_of_week(:friday))
      else
        prev_day
      end
    end
    alias_method :last_weekday, :prev_weekday

    # Short-hand for months_ago(1).
    def prev_month
      months_ago(1)
    end
    alias_method :last_month, :prev_month

    # Short-hand for months_ago(3).
    def prev_quarter
      months_ago(3)
    end
    alias_method :last_quarter, :prev_quarter

    # Short-hand for years_ago(1).
    def prev_year
      years_ago(1)
    end
    alias_method :last_year, :prev_year

    # Returns the number of days to the start of the week on the given day.
    # Week is assumed to start on +start_day+, default is
    # +Date.beginning_of_week+ or +config.beginning_of_week+ when set.
    def days_to_week_start(start_day = Date.beginning_of_week)
      start_day_number = DAYS_INTO_WEEK[start_day]
      current_day_number = wday != 0 ? wday - 1 : 6
      (current_day_number - start_day_number) % 7
    end

    # Returns a new date/time representing the start of this week on the given day.
    # Week is assumed to start on +start_day+, default is
    # +Date.beginning_of_week+ or +config.beginning_of_week+ when set.
    # +DateTime+ objects have their time set to 0:00.
    def beginning_of_week(start_day = Date.beginning_of_week)
      result = days_ago(days_to_week_start(start_day))
      acts_like?(:time) ? result.midnight : result
    end
    alias :at_beginning_of_week :beginning_of_week

    # Returns Monday of this week assuming that week starts on Monday.
    # +DateTime+ objects have their time set to 0:00.
    def monday
      beginning_of_week(:monday)
    end

    # Returns a new date/time representing the end of this week on the given day.
    # Week is assumed to start on +start_day+, default is
    # +Date.beginning_of_week+ or +config.beginning_of_week+ when set.
    # DateTime objects have their time set to 23:59:59.
    def end_of_week(start_day = Date.beginning_of_week)
      last_hour(days_since(6 - days_to_week_start(start_day)))
    end
    alias :at_end_of_week :end_of_week

    # Returns Sunday of this week assuming that week starts on Monday.
    # +DateTime+ objects have their time set to 23:59:59.
    def sunday
      end_of_week(:monday)
    end

    # Returns a new date/time representing the end of the month.
    # DateTime objects will have a time set to 23:59:59.
    def end_of_month
      last_day = ::Time.days_in_month(month, year)
      last_hour(days_since(last_day - day))
    end
    alias :at_end_of_month :end_of_month

    # Returns a new date/time representing the end of the year.
    # DateTime objects will have a time set to 23:59:59.
    def end_of_year
      change(month: 12).end_of_month
    end
    alias :at_end_of_year :end_of_year

    # Returns a Range representing the whole day of the current date/time.
    def all_day
      beginning_of_day..end_of_day
    end

    # Returns a Range representing the whole week of the current date/time.
    # Week starts on start_day, default is <tt>Date.week_start</tt> or <tt>config.week_start</tt> when set.
    def all_week(start_day = Date.beginning_of_week)
      beginning_of_week(start_day)..end_of_week(start_day)
    end

    # Returns a Range representing the whole month of the current date/time.
    def all_month
      beginning_of_month..end_of_month
    end

    # Returns a Range representing the whole quarter of the current date/time.
    def all_quarter
      beginning_of_quarter..end_of_quarter
    end

    # Returns a Range representing the whole year of the current date/time.
    def all_year
      beginning_of_year..end_of_year
    end

    private
      def first_hour(date_or_time)
        date_or_time.acts_like?(:time) ? date_or_time.beginning_of_day : date_or_time
      end

      def last_hour(date_or_time)
        date_or_time.acts_like?(:time) ? date_or_time.end_of_day : date_or_time
      end

      def days_span(day)
        (DAYS_INTO_WEEK[day] - DAYS_INTO_WEEK[Date.beginning_of_week]) % 7
      end

      def copy_time_to(other)
        other.change(hour: hour, min: min, sec: sec, usec: try(:usec))
      end
  end
end
require "cases/helper"
require "models/book"
require "models/club"
require "models/company"
require "models/contract"
require "models/edge"
require "models/organization"
require "models/possession"
require "models/topic"
require "models/reply"
require "models/minivan"
require "models/speedometer"
require "models/ship_part"
require "models/treasure"
require "models/developer"
require "models/comment"
require "models/rating"
require "models/post"

class NumericData < ActiveRecord::Base
  self.table_name = "numeric_data"

  attribute :world_population, :integer
  attribute :my_house_population, :integer
  attribute :atoms_in_universe, :integer
end

class CalculationsTest < ActiveRecord::TestCase
  fixtures :companies, :accounts, :topics, :speedometers, :minivans, :books

  def test_should_sum_field
    assert_equal 318, Account.sum(:credit_limit)
  end

  def test_should_sum_arel_attribute
    assert_equal 318, Account.sum(Account.arel_table[:credit_limit])
  end

  def test_should_average_field
    value = Account.average(:credit_limit)
    assert_equal 53.0, value
  end

  def test_should_average_arel_attribute
    value = Account.average(Account.arel_table[:credit_limit])
    assert_equal 53.0, value
  end

  def test_should_resolve_aliased_attributes
    assert_equal 318, Account.sum(:available_credit)
  end

  def test_should_return_decimal_average_of_integer_field
    value = Account.average(:id)
    assert_equal 3.5, value
  end

  def test_should_return_integer_average_if_db_returns_such
    ShipPart.delete_all
    ShipPart.create!(id: 3, name: "foo")
    value = ShipPart.average(:id)
    assert_equal 3, value
  end

  def test_should_return_nil_as_average
    assert_nil NumericData.average(:bank_balance)
  end

  def test_should_get_maximum_of_field
    assert_equal 60, Account.maximum(:credit_limit)
  end

  def test_should_get_maximum_of_arel_attribute
    assert_equal 60, Account.maximum(Account.arel_table[:credit_limit])
  end

  def test_should_get_maximum_of_field_with_include
    assert_equal 55, Account.where("companies.name != 'Summit'").references(:companies).includes(:firm).maximum(:credit_limit)
  end

  def test_should_get_maximum_of_arel_attribute_with_include
    assert_equal 55, Account.where("companies.name != 'Summit'").references(:companies).includes(:firm).maximum(Account.arel_table[:credit_limit])
  end

  def test_should_get_minimum_of_field
    assert_equal 50, Account.minimum(:credit_limit)
  end

  def test_should_get_minimum_of_arel_attribute
    assert_equal 50, Account.minimum(Account.arel_table[:credit_limit])
  end

  def test_should_group_by_field
    c = Account.group(:firm_id).sum(:credit_limit)
    [1,6,2].each do |firm_id|
      assert c.keys.include?(firm_id), "Group #{c.inspect} does not contain firm_id #{firm_id}"
    end
  end

  def test_should_group_by_arel_attribute
    c = Account.group(Account.arel_table[:firm_id]).sum(:credit_limit)
    [1,6,2].each do |firm_id|
      assert c.keys.include?(firm_id), "Group #{c.inspect} does not contain firm_id #{firm_id}"
    end
  end

  def test_should_group_by_multiple_fields
    c = Account.group("firm_id", :credit_limit).count(:all)
    [ [nil, 50], [1, 50], [6, 50], [6, 55], [9, 53], [2, 60] ].each { |firm_and_limit| assert c.keys.include?(firm_and_limit) }
  end

  def test_should_group_by_multiple_fields_having_functions
    c = Topic.group(:author_name, "COALESCE(type, title)").count(:all)
    assert_equal 1, c[["Carl", "The Third Topic of the day"]]
    assert_equal 1, c[["Mary", "Reply"]]
    assert_equal 1, c[["David", "The First Topic"]]
    assert_equal 1, c[["Carl", "Reply"]]
  end

  def test_should_group_by_summed_field
    c = Account.group(:firm_id).sum(:credit_limit)
    assert_equal 50,   c[1]
    assert_equal 105,  c[6]
    assert_equal 60,   c[2]
  end

  def test_should_generate_valid_sql_with_joins_and_group
    assert_nothing_raised do
      AuditLog.joins(:developer).group(:id).count
    end
  end

  def test_should_calculate_against_given_relation
    developer = Developer.create!(name: "developer")
    developer.audit_logs.create!(message: "first log")
    developer.audit_logs.create!(message: "second log")

    c = developer.audit_logs.joins(:developer).group(:id).count

    assert_equal developer.audit_logs.count, c.size
    developer.audit_logs.each do |log|
      assert_equal 1, c[log.id]
    end
  end

  def test_should_order_by_grouped_field
    c = Account.group(:firm_id).order("firm_id").sum(:credit_limit)
    assert_equal [1, 2, 6, 9], c.keys.compact
  end

  def test_should_order_by_calculation
    c = Account.group(:firm_id).order("sum_credit_limit desc, firm_id").sum(:credit_limit)
    assert_equal [105, 60, 53, 50, 50], c.keys.collect { |k| c[k] }
    assert_equal [6, 2, 9, 1], c.keys.compact
  end

  def test_should_limit_calculation
    c = Account.where("firm_id IS NOT NULL").group(:firm_id).order("firm_id").limit(2).sum(:credit_limit)
    assert_equal [1, 2], c.keys.compact
  end

  def test_should_limit_calculation_with_offset
    c = Account.where("firm_id IS NOT NULL").group(:firm_id).order("firm_id").
     limit(2).offset(1).sum(:credit_limit)
    assert_equal [2, 6], c.keys.compact
  end

  def test_limit_should_apply_before_count
    accounts = Account.limit(3).where("firm_id IS NOT NULL")

    assert_equal 3, accounts.count(:firm_id)
    assert_equal 3, accounts.select(:firm_id).count
  end

  def test_limit_should_apply_before_count_arel_attribute
    accounts = Account.limit(3).where("firm_id IS NOT NULL")

    firm_id_attribute = Account.arel_table[:firm_id]
    assert_equal 3, accounts.count(firm_id_attribute)
    assert_equal 3, accounts.select(firm_id_attribute).count
  end

  def test_count_should_shortcut_with_limit_zero
    accounts = Account.limit(0)

    assert_no_queries { assert_equal 0, accounts.count }
  end

  def test_limit_is_kept
    return if current_adapter?(:OracleAdapter)

    queries = assert_sql { Account.limit(1).count }
    assert_equal 1, queries.length
    assert_match(/LIMIT/, queries.first)
  end

  def test_offset_is_kept
    return if current_adapter?(:OracleAdapter)

    queries = assert_sql { Account.offset(1).count }
    assert_equal 1, queries.length
    assert_match(/OFFSET/, queries.first)
  end

  def test_limit_with_offset_is_kept
    return if current_adapter?(:OracleAdapter)

    queries = assert_sql { Account.limit(1).offset(1).count }
    assert_equal 1, queries.length
    assert_match(/LIMIT/, queries.first)
    assert_match(/OFFSET/, queries.first)
  end

  def test_no_limit_no_offset
    queries = assert_sql { Account.count }
    assert_equal 1, queries.length
    assert_no_match(/LIMIT/, queries.first)
    assert_no_match(/OFFSET/, queries.first)
  end

  def test_count_on_invalid_columns_raises
    e = assert_raises(A